From 684ab2fa967d562a3bc5a3af6ffad2e77e7d3c14 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 13 Jun 2025 14:46:40 -0400
Subject: [PATCH 101/166] Import WIP atiadlxx and atidxx implementations

---
 configure.ac                              |    1 +
 dlls/atiadlxx/Makefile.in                 |   11 +-
 dlls/atiadlxx/amdheaders/adl_defines.h    | 2596 +++++++++++++
 dlls/atiadlxx/amdheaders/adl_sdk.h        |   46 +
 dlls/atiadlxx/amdheaders/adl_structures.h | 4289 +++++++++++++++++++++
 dlls/atiadlxx/atiadlxx.spec               |  157 +-
 dlls/atiadlxx/atiadlxx_main.c             | 1441 +++++--
 dlls/atiadlxx/dxvk_interfaces.idl         |  153 +
 dlls/atiadlxx/unixlib.c                   |  285 ++
 dlls/atiadlxx/unixlib.h                   |   61 +
 dlls/atidxx64/Makefile.in                 |    9 +
 dlls/atidxx64/atidxx.h                    |  137 +
 dlls/atidxx64/atidxx64.spec               |   17 +
 dlls/atidxx64/dxvk_interfaces.idl         |  153 +
 dlls/atidxx64/main.c                      |  677 ++++
 loader/wine.inf.in                        |    1 +
 16 files changed, 9657 insertions(+), 377 deletions(-)
 create mode 100644 dlls/atiadlxx/amdheaders/adl_defines.h
 create mode 100644 dlls/atiadlxx/amdheaders/adl_sdk.h
 create mode 100644 dlls/atiadlxx/amdheaders/adl_structures.h
 create mode 100644 dlls/atiadlxx/dxvk_interfaces.idl
 create mode 100644 dlls/atiadlxx/unixlib.c
 create mode 100644 dlls/atiadlxx/unixlib.h
 create mode 100644 dlls/atidxx64/Makefile.in
 create mode 100644 dlls/atidxx64/atidxx.h
 create mode 100644 dlls/atidxx64/atidxx64.spec
 create mode 100644 dlls/atidxx64/dxvk_interfaces.idl
 create mode 100644 dlls/atidxx64/main.c

diff --git a/configure.ac b/configure.ac
index dff8f27cedc..67da3de58aa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2465,6 +2465,7 @@ WINE_CONFIG_MAKEFILE(dlls/apphelp/tests)
 WINE_CONFIG_MAKEFILE(dlls/appwiz.cpl)
 WINE_CONFIG_MAKEFILE(dlls/appxdeploymentclient)
 WINE_CONFIG_MAKEFILE(dlls/atiadlxx)
+WINE_CONFIG_MAKEFILE(dlls/atidxx64)
 WINE_CONFIG_MAKEFILE(dlls/atl)
 WINE_CONFIG_MAKEFILE(dlls/atl/tests)
 WINE_CONFIG_MAKEFILE(dlls/atl100)
diff --git a/dlls/atiadlxx/Makefile.in b/dlls/atiadlxx/Makefile.in
index cc6b51bf2bc..8cd80f90414 100644
--- a/dlls/atiadlxx/Makefile.in
+++ b/dlls/atiadlxx/Makefile.in
@@ -1,8 +1,13 @@
-EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE = atiadlxx.dll
-IMPORTS = dxgi
+UNIXLIB   = atiadlxx.so
+UNIX_CFLAGS = $(DRM_CFLAGS)
+UNIX_LIBS = $(DRM_LIBS) $(DRMAMDGPU_LIBS)
+IMPORTS = version vulkan-1 user32 gdi32
+IMPORTLIB = atiadlxx
 
 EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
 
 SOURCES = \
-	atiadlxx_main.c
+	atiadlxx_main.c \
+	unixlib.c \
+	dxvk_interfaces.idl
diff --git a/dlls/atiadlxx/amdheaders/adl_defines.h b/dlls/atiadlxx/amdheaders/adl_defines.h
new file mode 100644
index 00000000000..20ec62b70a0
--- /dev/null
+++ b/dlls/atiadlxx/amdheaders/adl_defines.h
@@ -0,0 +1,2596 @@
+//
+// Copyright (c) 2016 - 2022 Advanced Micro Devices, Inc. All rights reserved.
+//
+// MIT LICENSE:
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+/// \file adl_defines.h
+/// \brief Contains all definitions exposed by ADL for \ALL platforms.\n <b>Included in ADL SDK</b>
+///
+/// This file contains all definitions used by ADL.
+/// The ADL definitions include the following:
+/// \li ADL error codes
+/// \li Enumerations for the ADLDisplayInfo structure
+/// \li Maximum limits
+///
+
+#ifndef ADL_DEFINES_H_
+#define ADL_DEFINES_H_
+
+/// \defgroup DEFINES Constants and Definitions
+/// @{
+
+/// \defgroup define_misc Miscellaneous Constant Definitions
+/// @{
+
+/// \name General Definitions
+/// @{
+
+/// Defines ADL_TRUE
+#define ADL_TRUE    1
+/// Defines ADL_FALSE
+#define ADL_FALSE        0
+
+/// Defines the maximum string length
+#define ADL_MAX_CHAR                                    4096
+/// Defines the maximum string length
+#define ADL_MAX_PATH                                    256
+/// Defines the maximum number of supported adapters
+#define ADL_MAX_ADAPTERS                               250
+/// Defines the maxumum number of supported displays
+#define ADL_MAX_DISPLAYS                                150
+/// Defines the maxumum string length for device name
+#define ADL_MAX_DEVICENAME                                32
+/// Defines for all adapters
+#define ADL_ADAPTER_INDEX_ALL                            -1
+///    Defines APIs with iOption none
+#define ADL_MAIN_API_OPTION_NONE                        0
+/// @}
+
+/// \name Definitions for iOption parameter used by
+/// ADL_Display_DDCBlockAccess_Get()
+/// @{
+
+/// Switch to DDC line 2 before sending the command to the display.
+#define ADL_DDC_OPTION_SWITCHDDC2              0x00000001
+/// Save command in the registry under a unique key, corresponding to parameter \b iCommandIndex
+#define ADL_DDC_OPTION_RESTORECOMMAND 0x00000002
+/// Combine write-read DDC block access command.
+#define ADL_DDC_OPTION_COMBOWRITEREAD 0x00000010
+/// Direct DDC access to the immediate device connected to graphics card.
+/// MST with this option set: DDC command is sent to first branch.
+/// MST with this option not set: DDC command is sent to the end node sink device.
+#define ADL_DDC_OPTION_SENDTOIMMEDIATEDEVICE 0x00000020
+/// @}
+
+/// \name Values for
+/// ADLI2C.iAction used with ADL_Display_WriteAndReadI2C()
+/// @{
+
+#define ADL_DL_I2C_ACTIONREAD								0x00000001
+#define ADL_DL_I2C_ACTIONWRITE								0x00000002
+#define ADL_DL_I2C_ACTIONREAD_REPEATEDSTART    				0x00000003
+#define ADL_DL_I2C_ACTIONIS_PRESENT							0x00000004
+/// @}
+
+
+/// @}        //Misc
+
+/// \defgroup define_adl_results Result Codes
+/// This group of definitions are the various results returned by all ADL functions \n
+/// @{
+/// All OK, but need to wait
+#define ADL_OK_WAIT                4
+/// All OK, but need restart
+#define ADL_OK_RESTART                3
+/// All OK but need mode change
+#define ADL_OK_MODE_CHANGE            2
+/// All OK, but with warning
+#define ADL_OK_WARNING                1
+/// ADL function completed successfully
+#define ADL_OK                    0
+/// Generic Error. Most likely one or more of the Escape calls to the driver failed!
+#define ADL_ERR                    -1
+/// ADL not initialized
+#define ADL_ERR_NOT_INIT            -2
+/// One of the parameter passed is invalid
+#define ADL_ERR_INVALID_PARAM            -3
+/// One of the parameter size is invalid
+#define ADL_ERR_INVALID_PARAM_SIZE        -4
+/// Invalid ADL index passed
+#define ADL_ERR_INVALID_ADL_IDX            -5
+/// Invalid controller index passed
+#define ADL_ERR_INVALID_CONTROLLER_IDX        -6
+/// Invalid display index passed
+#define ADL_ERR_INVALID_DIPLAY_IDX        -7
+/// Function  not supported by the driver
+#define ADL_ERR_NOT_SUPPORTED            -8
+/// Null Pointer error
+#define ADL_ERR_NULL_POINTER            -9
+/// Call can't be made due to disabled adapter
+#define ADL_ERR_DISABLED_ADAPTER        -10
+/// Invalid Callback
+#define ADL_ERR_INVALID_CALLBACK            -11
+/// Display Resource conflict
+#define ADL_ERR_RESOURCE_CONFLICT                -12
+//Failed to update some of the values. Can be returned by set request that include multiple values if not all values were successfully committed.
+#define ADL_ERR_SET_INCOMPLETE                 -20
+/// There's no Linux XDisplay in Linux Console environment
+#define ADL_ERR_NO_XDISPLAY                    -21
+/// escape call failed becuse of incompatiable driver found in driver store
+#define ADL_ERR_CALL_TO_INCOMPATIABLE_DRIVER            -22
+/// not running as administrator
+#define ADL_ERR_NO_ADMINISTRATOR_PRIVILEGES            -23
+/// Feature Sync Start api is not called yet
+#define ADL_ERR_FEATURESYNC_NOT_STARTED            -24
+/// Adapter is in an invalid power state
+#define ADL_ERR_INVALID_POWER_STATE             -25
+
+/// @}
+/// </A>
+
+/// \defgroup define_display_type Display Type
+/// Define Monitor/CRT display type
+/// @{
+/// Define Monitor display type
+#define ADL_DT_MONITOR                  0
+/// Define TV display type
+#define ADL_DT_TELEVISION                    1
+/// Define LCD display type
+#define ADL_DT_LCD_PANEL                       2
+/// Define DFP display type
+#define ADL_DT_DIGITAL_FLAT_PANEL        3
+/// Define Componment Video display type
+#define ADL_DT_COMPONENT_VIDEO               4
+/// Define Projector display type
+#define ADL_DT_PROJECTOR                       5
+/// @}
+
+/// \defgroup define_display_connection_type Display Connection Type
+/// @{
+/// Define unknown display output type
+#define ADL_DOT_UNKNOWN                0
+/// Define composite display output type
+#define ADL_DOT_COMPOSITE            1
+/// Define SVideo display output type
+#define ADL_DOT_SVIDEO                2
+/// Define analog display output type
+#define ADL_DOT_ANALOG                3
+/// Define digital display output type
+#define ADL_DOT_DIGITAL                4
+/// @}
+
+/// \defgroup define_color_type Display Color Type and Source
+/// Define  Display Color Type and Source
+/// @{
+#define ADL_DISPLAY_COLOR_BRIGHTNESS    (1 << 0)
+#define ADL_DISPLAY_COLOR_CONTRAST    (1 << 1)
+#define ADL_DISPLAY_COLOR_SATURATION    (1 << 2)
+#define ADL_DISPLAY_COLOR_HUE        (1 << 3)
+#define ADL_DISPLAY_COLOR_TEMPERATURE    (1 << 4)
+
+/// Color Temperature Source is EDID
+#define ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_EDID    (1 << 5)
+/// Color Temperature Source is User
+#define ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_USER    (1 << 6)
+/// @}
+
+/// \defgroup define_adjustment_capabilities Display Adjustment Capabilities
+/// Display adjustment capabilities values.  Returned by ADL_Display_AdjustCaps_Get
+/// @{
+#define ADL_DISPLAY_ADJUST_OVERSCAN        (1 << 0)
+#define ADL_DISPLAY_ADJUST_VERT_POS        (1 << 1)
+#define ADL_DISPLAY_ADJUST_HOR_POS        (1 << 2)
+#define ADL_DISPLAY_ADJUST_VERT_SIZE        (1 << 3)
+#define ADL_DISPLAY_ADJUST_HOR_SIZE        (1 << 4)
+#define ADL_DISPLAY_ADJUST_SIZEPOS        (ADL_DISPLAY_ADJUST_VERT_POS | ADL_DISPLAY_ADJUST_HOR_POS | ADL_DISPLAY_ADJUST_VERT_SIZE | ADL_DISPLAY_ADJUST_HOR_SIZE)
+#define ADL_DISPLAY_CUSTOMMODES            (1<<5)
+#define ADL_DISPLAY_ADJUST_UNDERSCAN        (1<<6)
+/// @}
+
+///Down-scale support
+#define ADL_DISPLAY_CAPS_DOWNSCALE        (1 << 0)
+
+/// Sharpness support
+#define ADL_DISPLAY_CAPS_SHARPNESS      (1 << 0)
+
+/// \defgroup define_desktop_config Desktop Configuration Flags
+/// These flags are used by ADL_DesktopConfig_xxx
+/// \deprecated This API has been deprecated because it was only used for RandR 1.1 (Red Hat 5.x) distributions which is now not supported.
+/// @{
+#define ADL_DESKTOPCONFIG_UNKNOWN    0          /* UNKNOWN desktop config   */
+#define ADL_DESKTOPCONFIG_SINGLE     (1 <<  0)    /* Single                   */
+#define ADL_DESKTOPCONFIG_CLONE      (1 <<  2)    /* Clone                    */
+#define ADL_DESKTOPCONFIG_BIGDESK_H  (1 <<  4)    /* Big Desktop Horizontal   */
+#define ADL_DESKTOPCONFIG_BIGDESK_V  (1 <<  5)    /* Big Desktop Vertical     */
+#define ADL_DESKTOPCONFIG_BIGDESK_HR (1 <<  6)    /* Big Desktop Reverse Horz */
+#define ADL_DESKTOPCONFIG_BIGDESK_VR (1 <<  7)    /* Big Desktop Reverse Vert */
+#define ADL_DESKTOPCONFIG_RANDR12    (1 <<  8)    /* RandR 1.2 Multi-display */
+/// @}
+
+/// needed for ADLDDCInfo structure
+#define ADL_MAX_DISPLAY_NAME                                256
+
+/// \defgroup define_edid_flags Values for ulDDCInfoFlag
+/// defines for ulDDCInfoFlag EDID flag
+/// @{
+#define ADL_DISPLAYDDCINFOEX_FLAG_PROJECTORDEVICE       (1 << 0)
+#define ADL_DISPLAYDDCINFOEX_FLAG_EDIDEXTENSION         (1 << 1)
+#define ADL_DISPLAYDDCINFOEX_FLAG_DIGITALDEVICE         (1 << 2)
+#define ADL_DISPLAYDDCINFOEX_FLAG_HDMIAUDIODEVICE       (1 << 3)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORTS_AI           (1 << 4)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC601      (1 << 5)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC709      (1 << 6)
+/// @}
+
+/// \defgroup define_displayinfo_connector Display Connector Type
+/// defines for ADLDisplayInfo.iDisplayConnector
+/// @{
+#define ADL_DISPLAY_CONTYPE_UNKNOWN                 0
+#define ADL_DISPLAY_CONTYPE_VGA                     1
+#define ADL_DISPLAY_CONTYPE_DVI_D                   2
+#define ADL_DISPLAY_CONTYPE_DVI_I                   3
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_NTSC        4
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_JPN         5
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_JPN  6
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_NTSC 7
+#define ADL_DISPLAY_CONTYPE_PROPRIETARY                8
+#define ADL_DISPLAY_CONTYPE_HDMI_TYPE_A             10
+#define ADL_DISPLAY_CONTYPE_HDMI_TYPE_B             11
+#define ADL_DISPLAY_CONTYPE_SVIDEO                   12
+#define ADL_DISPLAY_CONTYPE_COMPOSITE               13
+#define ADL_DISPLAY_CONTYPE_RCA_3COMPONENT          14
+#define ADL_DISPLAY_CONTYPE_DISPLAYPORT             15
+#define ADL_DISPLAY_CONTYPE_EDP                     16
+#define ADL_DISPLAY_CONTYPE_WIRELESSDISPLAY         17
+#define ADL_DISPLAY_CONTYPE_USB_TYPE_C              18
+/// @}
+
+/// TV Capabilities and Standards
+/// \defgroup define_tv_caps TV Capabilities and Standards
+/// \deprecated Dropping support for TV displays
+/// @{
+#define ADL_TV_STANDARDS            (1 << 0)
+#define ADL_TV_SCART                (1 << 1)
+
+/// TV Standards Definitions
+#define ADL_STANDARD_NTSC_M        (1 << 0)
+#define ADL_STANDARD_NTSC_JPN        (1 << 1)
+#define ADL_STANDARD_NTSC_N        (1 << 2)
+#define ADL_STANDARD_PAL_B        (1 << 3)
+#define ADL_STANDARD_PAL_COMB_N        (1 << 4)
+#define ADL_STANDARD_PAL_D        (1 << 5)
+#define ADL_STANDARD_PAL_G        (1 << 6)
+#define ADL_STANDARD_PAL_H        (1 << 7)
+#define ADL_STANDARD_PAL_I        (1 << 8)
+#define ADL_STANDARD_PAL_K        (1 << 9)
+#define ADL_STANDARD_PAL_K1        (1 << 10)
+#define ADL_STANDARD_PAL_L        (1 << 11)
+#define ADL_STANDARD_PAL_M        (1 << 12)
+#define ADL_STANDARD_PAL_N        (1 << 13)
+#define ADL_STANDARD_PAL_SECAM_D    (1 << 14)
+#define ADL_STANDARD_PAL_SECAM_K    (1 << 15)
+#define ADL_STANDARD_PAL_SECAM_K1    (1 << 16)
+#define ADL_STANDARD_PAL_SECAM_L    (1 << 17)
+/// @}
+
+
+/// \defgroup define_video_custom_mode Video Custom Mode flags
+/// Component Video Custom Mode flags.  This is used by the iFlags parameter in ADLCustomMode
+/// @{
+#define ADL_CUSTOMIZEDMODEFLAG_MODESUPPORTED    (1 << 0)
+#define ADL_CUSTOMIZEDMODEFLAG_NOTDELETETABLE    (1 << 1)
+#define ADL_CUSTOMIZEDMODEFLAG_INSERTBYDRIVER    (1 << 2)
+#define ADL_CUSTOMIZEDMODEFLAG_INTERLACED    (1 << 3)
+#define ADL_CUSTOMIZEDMODEFLAG_BASEMODE        (1 << 4)
+/// @}
+
+/// \defgroup define_ddcinfoflag Values used for DDCInfoFlag
+/// ulDDCInfoFlag field values used by the ADLDDCInfo structure
+/// @{
+#define ADL_DISPLAYDDCINFOEX_FLAG_PROJECTORDEVICE    (1 << 0)
+#define ADL_DISPLAYDDCINFOEX_FLAG_EDIDEXTENSION        (1 << 1)
+#define ADL_DISPLAYDDCINFOEX_FLAG_DIGITALDEVICE        (1 << 2)
+#define ADL_DISPLAYDDCINFOEX_FLAG_HDMIAUDIODEVICE    (1 << 3)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORTS_AI        (1 << 4)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC601    (1 << 5)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC709    (1 << 6)
+/// @}
+
+/// \defgroup define_cv_dongle Values used by ADL_CV_DongleSettings_xxx
+/// The following is applicable to ADL_DISPLAY_CONTYPE_ATICVDONGLE_JP and ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_D only
+/// \deprecated Dropping support for Component Video displays
+/// @{
+#define ADL_DISPLAY_CV_DONGLE_D1          (1 << 0)
+#define ADL_DISPLAY_CV_DONGLE_D2          (1 << 1)
+#define ADL_DISPLAY_CV_DONGLE_D3          (1 << 2)
+#define ADL_DISPLAY_CV_DONGLE_D4          (1 << 3)
+#define ADL_DISPLAY_CV_DONGLE_D5          (1 << 4)
+
+/// The following is applicable to ADL_DISPLAY_CONTYPE_ATICVDONGLE_NA and ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C only
+
+#define ADL_DISPLAY_CV_DONGLE_480I        (1 << 0)
+#define ADL_DISPLAY_CV_DONGLE_480P        (1 << 1)
+#define ADL_DISPLAY_CV_DONGLE_540P        (1 << 2)
+#define ADL_DISPLAY_CV_DONGLE_720P        (1 << 3)
+#define ADL_DISPLAY_CV_DONGLE_1080I       (1 << 4)
+#define ADL_DISPLAY_CV_DONGLE_1080P       (1 << 5)
+#define ADL_DISPLAY_CV_DONGLE_16_9        (1 << 6)
+#define ADL_DISPLAY_CV_DONGLE_720P50      (1 << 7)
+#define ADL_DISPLAY_CV_DONGLE_1080I25     (1 << 8)
+#define ADL_DISPLAY_CV_DONGLE_576I25      (1 << 9)
+#define ADL_DISPLAY_CV_DONGLE_576P50      (1 << 10)
+#define ADL_DISPLAY_CV_DONGLE_1080P24      (1 << 11)
+#define ADL_DISPLAY_CV_DONGLE_1080P25      (1 << 12)
+#define ADL_DISPLAY_CV_DONGLE_1080P30      (1 << 13)
+#define ADL_DISPLAY_CV_DONGLE_1080P50      (1 << 14)
+/// @}
+
+/// \defgroup define_formats_ovr    Formats Override Settings
+/// Display force modes flags
+/// @{
+///
+#define ADL_DISPLAY_FORMAT_FORCE_720P        0x00000001
+#define ADL_DISPLAY_FORMAT_FORCE_1080I        0x00000002
+#define ADL_DISPLAY_FORMAT_FORCE_1080P        0x00000004
+#define ADL_DISPLAY_FORMAT_FORCE_720P50        0x00000008
+#define ADL_DISPLAY_FORMAT_FORCE_1080I25    0x00000010
+#define ADL_DISPLAY_FORMAT_FORCE_576I25        0x00000020
+#define ADL_DISPLAY_FORMAT_FORCE_576P50        0x00000040
+#define ADL_DISPLAY_FORMAT_FORCE_1080P24    0x00000080
+#define ADL_DISPLAY_FORMAT_FORCE_1080P25    0x00000100
+#define ADL_DISPLAY_FORMAT_FORCE_1080P30    0x00000200
+#define ADL_DISPLAY_FORMAT_FORCE_1080P50    0x00000400
+
+///< Below are \b EXTENDED display mode flags
+
+#define ADL_DISPLAY_FORMAT_CVDONGLEOVERIDE  0x00000001
+#define ADL_DISPLAY_FORMAT_CVMODEUNDERSCAN  0x00000002
+#define ADL_DISPLAY_FORMAT_FORCECONNECT_SUPPORTED  0x00000004
+#define ADL_DISPLAY_FORMAT_RESTRICT_FORMAT_SELECTION 0x00000008
+#define ADL_DISPLAY_FORMAT_SETASPECRATIO 0x00000010
+#define ADL_DISPLAY_FORMAT_FORCEMODES    0x00000020
+#define ADL_DISPLAY_FORMAT_LCDRTCCOEFF   0x00000040
+/// @}
+
+/// Defines used by OD5
+#define ADL_PM_PARAM_DONT_CHANGE    0
+
+/// The following defines Bus types
+/// @{
+#define ADL_BUSTYPE_PCI           0       /* PCI bus                          */
+#define ADL_BUSTYPE_AGP           1       /* AGP bus                          */
+#define ADL_BUSTYPE_PCIE          2       /* PCI Express bus                  */
+#define ADL_BUSTYPE_PCIE_GEN2     3       /* PCI Express 2nd generation bus   */
+#define ADL_BUSTYPE_PCIE_GEN3     4       /* PCI Express 3rd generation bus   */
+#define ADL_BUSTYPE_PCIE_GEN4     5       /* PCI Express 4th generation bus   */
+/// @}
+
+/// \defgroup define_ws_caps    Workstation Capabilities
+/// Workstation values
+/// @{
+
+/// This value indicates that the workstation card supports active stereo though stereo output connector
+#define ADL_STEREO_SUPPORTED        (1 << 2)
+/// This value indicates that the workstation card supports active stereo via "blue-line"
+#define ADL_STEREO_BLUE_LINE        (1 << 3)
+/// This value is used to turn off stereo mode.
+#define ADL_STEREO_OFF                0
+/// This value indicates that the workstation card supports active stereo.  This is also used to set the stereo mode to active though the stereo output connector
+#define ADL_STEREO_ACTIVE             (1 << 1)
+/// This value indicates that the workstation card supports auto-stereo monitors with horizontal interleave. This is also used to set the stereo mode to use the auto-stereo monitor with horizontal interleave
+#define ADL_STEREO_AUTO_HORIZONTAL    (1 << 30)
+/// This value indicates that the workstation card supports auto-stereo monitors with vertical interleave. This is also used to set the stereo mode to use the auto-stereo monitor with vertical interleave
+#define ADL_STEREO_AUTO_VERTICAL    (1 << 31)
+/// This value indicates that the workstation card supports passive stereo, ie. non stereo sync
+#define ADL_STEREO_PASSIVE              (1 << 6)
+/// This value indicates that the workstation card supports auto-stereo monitors with vertical interleave. This is also used to set the stereo mode to use the auto-stereo monitor with vertical interleave
+#define ADL_STEREO_PASSIVE_HORIZ        (1 << 7)
+/// This value indicates that the workstation card supports auto-stereo monitors with vertical interleave. This is also used to set the stereo mode to use the auto-stereo monitor with vertical interleave
+#define ADL_STEREO_PASSIVE_VERT         (1 << 8)
+/// This value indicates that the workstation card supports auto-stereo monitors with Samsung.
+#define ADL_STEREO_AUTO_SAMSUNG        (1 << 11)
+/// This value indicates that the workstation card supports auto-stereo monitors with Tridility.
+#define ADL_STEREO_AUTO_TSL         (1 << 12)
+/// This value indicates that the workstation card supports DeepBitDepth (10 bpp)
+#define ADL_DEEPBITDEPTH_10BPP_SUPPORTED   (1 << 5)
+
+/// This value indicates that the workstation supports 8-Bit Grayscale
+#define ADL_8BIT_GREYSCALE_SUPPORTED   (1 << 9)
+/// This value indicates that the workstation supports CUSTOM TIMING
+#define ADL_CUSTOM_TIMING_SUPPORTED   (1 << 10)
+
+/// Load balancing is supported.
+#define ADL_WORKSTATION_LOADBALANCING_SUPPORTED         0x00000001
+/// Load balancing is available.
+#define ADL_WORKSTATION_LOADBALANCING_AVAILABLE         0x00000002
+
+/// Load balancing is disabled.
+#define ADL_WORKSTATION_LOADBALANCING_DISABLED          0x00000000
+/// Load balancing is Enabled.
+#define ADL_WORKSTATION_LOADBALANCING_ENABLED           0x00000001
+
+
+
+/// @}
+
+/// \defgroup define_adapterspeed speed setting from the adapter
+/// @{
+#define ADL_CONTEXT_SPEED_UNFORCED        0        /* default asic running speed */
+#define ADL_CONTEXT_SPEED_FORCEHIGH        1        /* asic running speed is forced to high */
+#define ADL_CONTEXT_SPEED_FORCELOW        2        /* asic running speed is forced to low */
+
+#define ADL_ADAPTER_SPEEDCAPS_SUPPORTED        (1 << 0)    /* change asic running speed setting is supported */
+/// @}
+
+/// \defgroup define_glsync Genlock related values
+/// GL-Sync port types (unique values)
+/// @{
+/// Unknown port of GL-Sync module
+#define ADL_GLSYNC_PORT_UNKNOWN        0
+/// BNC port of of GL-Sync module
+#define ADL_GLSYNC_PORT_BNC            1
+/// RJ45(1) port of of GL-Sync module
+#define ADL_GLSYNC_PORT_RJ45PORT1    2
+/// RJ45(2) port of of GL-Sync module
+#define ADL_GLSYNC_PORT_RJ45PORT2    3
+
+// GL-Sync Genlock settings mask (bit-vector)
+
+/// None of the ADLGLSyncGenlockConfig members are valid
+#define ADL_GLSYNC_CONFIGMASK_NONE                0
+/// The ADLGLSyncGenlockConfig.lSignalSource member is valid
+#define ADL_GLSYNC_CONFIGMASK_SIGNALSOURCE        (1 << 0)
+/// The ADLGLSyncGenlockConfig.iSyncField member is valid
+#define ADL_GLSYNC_CONFIGMASK_SYNCFIELD            (1 << 1)
+/// The ADLGLSyncGenlockConfig.iSampleRate member is valid
+#define ADL_GLSYNC_CONFIGMASK_SAMPLERATE        (1 << 2)
+/// The ADLGLSyncGenlockConfig.lSyncDelay member is valid
+#define ADL_GLSYNC_CONFIGMASK_SYNCDELAY            (1 << 3)
+/// The ADLGLSyncGenlockConfig.iTriggerEdge member is valid
+#define ADL_GLSYNC_CONFIGMASK_TRIGGEREDGE        (1 << 4)
+/// The ADLGLSyncGenlockConfig.iScanRateCoeff member is valid
+#define ADL_GLSYNC_CONFIGMASK_SCANRATECOEFF        (1 << 5)
+/// The ADLGLSyncGenlockConfig.lFramelockCntlVector member is valid
+#define ADL_GLSYNC_CONFIGMASK_FRAMELOCKCNTL        (1 << 6)
+
+
+// GL-Sync Framelock control mask (bit-vector)
+
+/// Framelock is disabled
+#define ADL_GLSYNC_FRAMELOCKCNTL_NONE            0
+/// Framelock is enabled
+#define ADL_GLSYNC_FRAMELOCKCNTL_ENABLE            ( 1 << 0)
+
+#define ADL_GLSYNC_FRAMELOCKCNTL_DISABLE        ( 1 << 1)
+#define ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_RESET    ( 1 << 2)
+#define ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_ACK    ( 1 << 3)
+#define ADL_GLSYNC_FRAMELOCKCNTL_VERSION_KMD    (1 << 4)
+
+#define ADL_GLSYNC_FRAMELOCKCNTL_STATE_ENABLE        ( 1 << 0)
+#define ADL_GLSYNC_FRAMELOCKCNTL_STATE_KMD        (1 << 4)
+
+// GL-Sync Framelock counters mask (bit-vector)
+#define ADL_GLSYNC_COUNTER_SWAP                ( 1 << 0 )
+
+// GL-Sync Signal Sources (unique values)
+
+/// GL-Sync signal source is undefined
+#define ADL_GLSYNC_SIGNALSOURCE_UNDEFINED    0x00000100
+/// GL-Sync signal source is Free Run
+#define ADL_GLSYNC_SIGNALSOURCE_FREERUN      0x00000101
+/// GL-Sync signal source is the BNC GL-Sync port
+#define ADL_GLSYNC_SIGNALSOURCE_BNCPORT      0x00000102
+/// GL-Sync signal source is the RJ45(1) GL-Sync port
+#define ADL_GLSYNC_SIGNALSOURCE_RJ45PORT1    0x00000103
+/// GL-Sync signal source is the RJ45(2) GL-Sync port
+#define ADL_GLSYNC_SIGNALSOURCE_RJ45PORT2    0x00000104
+
+
+// GL-Sync Signal Types (unique values)
+
+/// GL-Sync signal type is unknown
+#define ADL_GLSYNC_SIGNALTYPE_UNDEFINED      0
+/// GL-Sync signal type is 480I
+#define ADL_GLSYNC_SIGNALTYPE_480I           1
+/// GL-Sync signal type is 576I
+#define ADL_GLSYNC_SIGNALTYPE_576I           2
+/// GL-Sync signal type is 480P
+#define ADL_GLSYNC_SIGNALTYPE_480P           3
+/// GL-Sync signal type is 576P
+#define ADL_GLSYNC_SIGNALTYPE_576P           4
+/// GL-Sync signal type is 720P
+#define ADL_GLSYNC_SIGNALTYPE_720P           5
+/// GL-Sync signal type is 1080P
+#define ADL_GLSYNC_SIGNALTYPE_1080P          6
+/// GL-Sync signal type is 1080I
+#define ADL_GLSYNC_SIGNALTYPE_1080I          7
+/// GL-Sync signal type is SDI
+#define ADL_GLSYNC_SIGNALTYPE_SDI            8
+/// GL-Sync signal type is TTL
+#define ADL_GLSYNC_SIGNALTYPE_TTL            9
+/// GL_Sync signal type is Analog
+#define ADL_GLSYNC_SIGNALTYPE_ANALOG        10
+
+// GL-Sync Sync Field options (unique values)
+
+///GL-Sync sync field option is undefined
+#define ADL_GLSYNC_SYNCFIELD_UNDEFINED        0
+///GL-Sync sync field option is Sync to Field 1 (used for Interlaced signal types)
+#define ADL_GLSYNC_SYNCFIELD_BOTH            1
+///GL-Sync sync field option is Sync to Both fields (used for Interlaced signal types)
+#define ADL_GLSYNC_SYNCFIELD_1                2
+
+
+// GL-Sync trigger edge options (unique values)
+
+/// GL-Sync trigger edge is undefined
+#define ADL_GLSYNC_TRIGGEREDGE_UNDEFINED     0
+/// GL-Sync trigger edge is the rising edge
+#define ADL_GLSYNC_TRIGGEREDGE_RISING        1
+/// GL-Sync trigger edge is the falling edge
+#define ADL_GLSYNC_TRIGGEREDGE_FALLING       2
+/// GL-Sync trigger edge is both the rising and the falling edge
+#define ADL_GLSYNC_TRIGGEREDGE_BOTH          3
+
+
+// GL-Sync scan rate coefficient/multiplier options (unique values)
+
+/// GL-Sync scan rate coefficient/multiplier is undefined
+#define ADL_GLSYNC_SCANRATECOEFF_UNDEFINED   0
+/// GL-Sync scan rate coefficient/multiplier is 5
+#define ADL_GLSYNC_SCANRATECOEFF_x5          1
+/// GL-Sync scan rate coefficient/multiplier is 4
+#define ADL_GLSYNC_SCANRATECOEFF_x4          2
+/// GL-Sync scan rate coefficient/multiplier is 3
+#define ADL_GLSYNC_SCANRATECOEFF_x3          3
+/// GL-Sync scan rate coefficient/multiplier is 5:2 (SMPTE)
+#define ADL_GLSYNC_SCANRATECOEFF_x5_DIV_2    4
+/// GL-Sync scan rate coefficient/multiplier is 2
+#define ADL_GLSYNC_SCANRATECOEFF_x2          5
+/// GL-Sync scan rate coefficient/multiplier is 3 : 2
+#define ADL_GLSYNC_SCANRATECOEFF_x3_DIV_2    6
+/// GL-Sync scan rate coefficient/multiplier is 5 : 4
+#define ADL_GLSYNC_SCANRATECOEFF_x5_DIV_4    7
+/// GL-Sync scan rate coefficient/multiplier is 1 (default)
+#define ADL_GLSYNC_SCANRATECOEFF_x1          8
+/// GL-Sync scan rate coefficient/multiplier is 4 : 5
+#define ADL_GLSYNC_SCANRATECOEFF_x4_DIV_5    9
+/// GL-Sync scan rate coefficient/multiplier is 2 : 3
+#define ADL_GLSYNC_SCANRATECOEFF_x2_DIV_3    10
+/// GL-Sync scan rate coefficient/multiplier is 1 : 2
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_2    11
+/// GL-Sync scan rate coefficient/multiplier is 2 : 5 (SMPTE)
+#define ADL_GLSYNC_SCANRATECOEFF_x2_DIV_5    12
+/// GL-Sync scan rate coefficient/multiplier is 1 : 3
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_3    13
+/// GL-Sync scan rate coefficient/multiplier is 1 : 4
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_4    14
+/// GL-Sync scan rate coefficient/multiplier is 1 : 5
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_5    15
+
+
+// GL-Sync port (signal presence) states (unique values)
+
+/// GL-Sync port state is undefined
+#define ADL_GLSYNC_PORTSTATE_UNDEFINED       0
+/// GL-Sync port is not connected
+#define ADL_GLSYNC_PORTSTATE_NOCABLE         1
+/// GL-Sync port is Idle
+#define ADL_GLSYNC_PORTSTATE_IDLE            2
+/// GL-Sync port has an Input signal
+#define ADL_GLSYNC_PORTSTATE_INPUT           3
+/// GL-Sync port is Output
+#define ADL_GLSYNC_PORTSTATE_OUTPUT          4
+
+
+// GL-Sync LED types (used index within ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array) (unique values)
+
+/// Index into the ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array for the one LED of the BNC port
+#define ADL_GLSYNC_LEDTYPE_BNC               0
+/// Index into the ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array for the Left LED of the RJ45(1) or RJ45(2) port
+#define ADL_GLSYNC_LEDTYPE_RJ45_LEFT         0
+/// Index into the ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array for the Right LED of the RJ45(1) or RJ45(2) port
+#define ADL_GLSYNC_LEDTYPE_RJ45_RIGHT        1
+
+
+// GL-Sync LED colors (unique values)
+
+/// GL-Sync LED undefined color
+#define ADL_GLSYNC_LEDCOLOR_UNDEFINED        0
+/// GL-Sync LED is unlit
+#define ADL_GLSYNC_LEDCOLOR_NOLIGHT          1
+/// GL-Sync LED is yellow
+#define ADL_GLSYNC_LEDCOLOR_YELLOW           2
+/// GL-Sync LED is red
+#define ADL_GLSYNC_LEDCOLOR_RED              3
+/// GL-Sync LED is green
+#define ADL_GLSYNC_LEDCOLOR_GREEN            4
+/// GL-Sync LED is flashing green
+#define ADL_GLSYNC_LEDCOLOR_FLASH_GREEN      5
+
+
+// GL-Sync Port Control (refers one GL-Sync Port) (unique values)
+
+/// Used to configure the RJ54(1) or RJ42(2) port of GL-Sync is as Idle
+#define ADL_GLSYNC_PORTCNTL_NONE             0x00000000
+/// Used to configure the RJ54(1) or RJ42(2) port of GL-Sync is as Output
+#define ADL_GLSYNC_PORTCNTL_OUTPUT           0x00000001
+
+
+// GL-Sync Mode Control (refers one Display/Controller) (bitfields)
+
+/// Used to configure the display to use internal timing (not genlocked)
+#define ADL_GLSYNC_MODECNTL_NONE             0x00000000
+/// Bitfield used to configure the display as genlocked (either as Timing Client or as Timing Server)
+#define ADL_GLSYNC_MODECNTL_GENLOCK          0x00000001
+/// Bitfield used to configure the display as Timing Server
+#define ADL_GLSYNC_MODECNTL_TIMINGSERVER     0x00000002
+
+// GL-Sync Mode Status
+/// Display is currently not genlocked
+#define ADL_GLSYNC_MODECNTL_STATUS_NONE         0x00000000
+/// Display is currently genlocked
+#define ADL_GLSYNC_MODECNTL_STATUS_GENLOCK   0x00000001
+/// Display requires a mode switch
+#define ADL_GLSYNC_MODECNTL_STATUS_SETMODE_REQUIRED 0x00000002
+/// Display is capable of being genlocked
+#define ADL_GLSYNC_MODECNTL_STATUS_GENLOCK_ALLOWED 0x00000004
+
+#define ADL_MAX_GLSYNC_PORTS                            8
+#define ADL_MAX_GLSYNC_PORT_LEDS                        8
+
+/// @}
+
+/// \defgroup define_crossfirestate CrossfireX state of a particular adapter CrossfireX combination
+/// @{
+#define ADL_XFIREX_STATE_NOINTERCONNECT            ( 1 << 0 )    /* Dongle / cable is missing */
+#define ADL_XFIREX_STATE_DOWNGRADEPIPES            ( 1 << 1 )    /* CrossfireX can be enabled if pipes are downgraded */
+#define ADL_XFIREX_STATE_DOWNGRADEMEM            ( 1 << 2 )    /* CrossfireX cannot be enabled unless mem downgraded */
+#define ADL_XFIREX_STATE_REVERSERECOMMENDED        ( 1 << 3 )    /* Card reversal recommended, CrossfireX cannot be enabled. */
+#define ADL_XFIREX_STATE_3DACTIVE            ( 1 << 4 )    /* 3D client is active - CrossfireX cannot be safely enabled */
+#define ADL_XFIREX_STATE_MASTERONSLAVE            ( 1 << 5 )    /* Dongle is OK but master is on slave */
+#define ADL_XFIREX_STATE_NODISPLAYCONNECT        ( 1 << 6 )    /* No (valid) display connected to master card. */
+#define ADL_XFIREX_STATE_NOPRIMARYVIEW            ( 1 << 7 )    /* CrossfireX is enabled but master is not current primary device */
+#define ADL_XFIREX_STATE_DOWNGRADEVISMEM        ( 1 << 8 )    /* CrossfireX cannot be enabled unless visible mem downgraded */
+#define ADL_XFIREX_STATE_LESSTHAN8LANE_MASTER        ( 1 << 9 )     /* CrossfireX can be enabled however performance not optimal due to <8 lanes */
+#define ADL_XFIREX_STATE_LESSTHAN8LANE_SLAVE        ( 1 << 10 )    /* CrossfireX can be enabled however performance not optimal due to <8 lanes */
+#define ADL_XFIREX_STATE_PEERTOPEERFAILED        ( 1 << 11 )    /* CrossfireX cannot be enabled due to failed peer to peer test */
+#define ADL_XFIREX_STATE_MEMISDOWNGRADED        ( 1 << 16 )    /* Notification that memory is currently downgraded */
+#define ADL_XFIREX_STATE_PIPESDOWNGRADED        ( 1 << 17 )    /* Notification that pipes are currently downgraded */
+#define ADL_XFIREX_STATE_XFIREXACTIVE            ( 1 << 18 )    /* CrossfireX is enabled on current device */
+#define ADL_XFIREX_STATE_VISMEMISDOWNGRADED        ( 1 << 19 )    /* Notification that visible FB memory is currently downgraded */
+#define ADL_XFIREX_STATE_INVALIDINTERCONNECTION        ( 1 << 20 )    /* Cannot support current inter-connection configuration */
+#define ADL_XFIREX_STATE_NONP2PMODE            ( 1 << 21 )    /* CrossfireX will only work with clients supporting non P2P mode */
+#define ADL_XFIREX_STATE_DOWNGRADEMEMBANKS        ( 1 << 22 )    /* CrossfireX cannot be enabled unless memory banks downgraded */
+#define ADL_XFIREX_STATE_MEMBANKSDOWNGRADED        ( 1 << 23 )    /* Notification that memory banks are currently downgraded */
+#define ADL_XFIREX_STATE_DUALDISPLAYSALLOWED        ( 1 << 24 )    /* Extended desktop or clone mode is allowed. */
+#define ADL_XFIREX_STATE_P2P_APERTURE_MAPPING        ( 1 << 25 )    /* P2P mapping was through peer aperture */
+#define ADL_XFIREX_STATE_P2PFLUSH_REQUIRED        ADL_XFIREX_STATE_P2P_APERTURE_MAPPING    /* For back compatible */
+#define ADL_XFIREX_STATE_XSP_CONNECTED            ( 1 << 26 )    /* There is CrossfireX side port connection between GPUs */
+#define ADL_XFIREX_STATE_ENABLE_CF_REBOOT_REQUIRED    ( 1 << 27 )    /* System needs a reboot bofore enable CrossfireX */
+#define ADL_XFIREX_STATE_DISABLE_CF_REBOOT_REQUIRED    ( 1 << 28 )    /* System needs a reboot after disable CrossfireX */
+#define ADL_XFIREX_STATE_DRV_HANDLE_DOWNGRADE_KEY    ( 1 << 29 )    /* Indicate base driver handles the downgrade key updating */
+#define ADL_XFIREX_STATE_CF_RECONFIG_REQUIRED        ( 1 << 30 )    /* CrossfireX need to be reconfigured by CCC because of a LDA chain broken */
+#define ADL_XFIREX_STATE_ERRORGETTINGSTATUS        ( 1 << 31 )    /* Could not obtain current status */
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_ADJUSTMENT_PIXELFORMAT adjustment values
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_pixel_formats Pixel Formats values
+/// This group defines the various Pixel Formats that a particular digital display can support. \n
+/// Since a display can support multiple formats, these values can be bit-or'ed to indicate the various formats \n
+/// @{
+#define ADL_DISPLAY_PIXELFORMAT_UNKNOWN             0
+#define ADL_DISPLAY_PIXELFORMAT_RGB                       (1 << 0)
+#define ADL_DISPLAY_PIXELFORMAT_YCRCB444                  (1 << 1)    //Limited range
+#define ADL_DISPLAY_PIXELFORMAT_YCRCB422                 (1 << 2)    //Limited range
+#define ADL_DISPLAY_PIXELFORMAT_RGB_LIMITED_RANGE      (1 << 3)
+#define ADL_DISPLAY_PIXELFORMAT_RGB_FULL_RANGE    ADL_DISPLAY_PIXELFORMAT_RGB  //Full range
+#define ADL_DISPLAY_PIXELFORMAT_YCRCB420              (1 << 4)
+/// @}
+
+/// \defgroup define_contype Connector Type Values
+/// ADLDisplayConfig.ulConnectorType defines
+/// @{
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_UNKNOWN      0
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_JP 1
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_JPN       2
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NA        3
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_NA 4
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_VGA          5
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_D        6
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_I        7
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_A  8
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_B  9
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_DISPLAYPORT  10
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYINFO_ Definitions
+// for ADLDisplayInfo.iDisplayInfoMask and ADLDisplayInfo.iDisplayInfoValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_displayinfomask Display Info Mask Values
+/// @{
+#define ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED            0x00000001
+#define ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED                0x00000002
+#define ADL_DISPLAY_DISPLAYINFO_NONLOCAL                    0x00000004
+#define ADL_DISPLAY_DISPLAYINFO_FORCIBLESUPPORTED            0x00000008
+#define ADL_DISPLAY_DISPLAYINFO_GENLOCKSUPPORTED            0x00000010
+#define ADL_DISPLAY_DISPLAYINFO_MULTIVPU_SUPPORTED            0x00000020
+#define ADL_DISPLAY_DISPLAYINFO_LDA_DISPLAY                    0x00000040
+#define ADL_DISPLAY_DISPLAYINFO_MODETIMING_OVERRIDESSUPPORTED            0x00000080
+
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_SINGLE            0x00000100
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_CLONE            0x00000200
+
+/// Legacy support for XP
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2VSTRETCH        0x00000400
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2HSTRETCH        0x00000800
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_EXTENDED        0x00001000
+
+/// More support manners
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCH1GPU    0x00010000
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCHNGPU    0x00020000
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED2        0x00040000
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED3        0x00080000
+
+/// Projector display type
+#define ADL_DISPLAY_DISPLAYINFO_SHOWTYPE_PROJECTOR                0x00100000
+
+/// @}
+
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_ADAPTER_DISPLAY_MANNER_SUPPORTED_ Definitions
+// for ADLAdapterDisplayCap of ADL_Adapter_Display_Cap()
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_adaptermanner Adapter Manner Support Values
+/// @{
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NOTACTIVE        0x00000001
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_SINGLE            0x00000002
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_CLONE            0x00000004
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCH1GPU    0x00000008
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCHNGPU    0x00000010
+
+/// Legacy support for XP
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2VSTRETCH        0x00000020
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2HSTRETCH        0x00000040
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_EXTENDED        0x00000080
+
+#define ADL_ADAPTER_DISPLAYCAP_PREFERDISPLAY_SUPPORTED            0x00000100
+#define ADL_ADAPTER_DISPLAYCAP_BEZEL_SUPPORTED                    0x00000200
+
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYMAP_MANNER_ Definitions
+// for ADLDisplayMap.iDisplayMapMask and ADLDisplayMap.iDisplayMapValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED            0x00000001
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_NOTACTIVE            0x00000002
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE            0x00000004
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_CLONE                0x00000008
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED1            0x00000010  // Removed NSTRETCH
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_HSTRETCH            0x00000020
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_VSTRETCH            0x00000040
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_VLD                0x00000080
+
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYMAP_OPTION_ Definitions
+// for iOption in function ADL_Display_DisplayMapConfig_Get
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_DISPLAYMAP_OPTION_GPUINFO            0x00000001
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYTARGET_ Definitions
+// for ADLDisplayTarget.iDisplayTargetMask and ADLDisplayTarget.iDisplayTargetValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_DISPLAYTARGET_PREFERRED            0x00000001
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_POSSIBLEMAPRESULT_VALID Definitions
+// for ADLPossibleMapResult.iPossibleMapResultMask and ADLPossibleMapResult.iPossibleMapResultValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_POSSIBLEMAPRESULT_VALID                0x00000001
+#define ADL_DISPLAY_POSSIBLEMAPRESULT_BEZELSUPPORTED    0x00000002
+#define ADL_DISPLAY_POSSIBLEMAPRESULT_OVERLAPSUPPORTED    0x00000004
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_MODE_ Definitions
+// for ADLMode.iModeMask, ADLMode.iModeValue, and ADLMode.iModeFlag
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_displaymode Display Mode Values
+/// @{
+#define ADL_DISPLAY_MODE_COLOURFORMAT_565                0x00000001
+#define ADL_DISPLAY_MODE_COLOURFORMAT_8888                0x00000002
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000        0x00000004
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_090        0x00000008
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_180        0x00000010
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_270        0x00000020
+#define ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED            0x00000040
+#define ADL_DISPLAY_MODE_REFRESHRATE_ONLY                0x00000080
+
+#define ADL_DISPLAY_MODE_PROGRESSIVE_FLAG    0
+#define ADL_DISPLAY_MODE_INTERLACED_FLAG    2
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_OSMODEINFO Definitions
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_osmode OS Mode Values
+/// @{
+#define ADL_OSMODEINFOXPOS_DEFAULT                -640
+#define ADL_OSMODEINFOYPOS_DEFAULT                0
+#define ADL_OSMODEINFOXRES_DEFAULT                640
+#define ADL_OSMODEINFOYRES_DEFAULT                480
+#define ADL_OSMODEINFOXRES_DEFAULT800            800
+#define ADL_OSMODEINFOYRES_DEFAULT600            600
+#define ADL_OSMODEINFOREFRESHRATE_DEFAULT        60
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT        8
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT16        16
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT24        24
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT32        32
+#define ADL_OSMODEINFOORIENTATION_DEFAULT        0
+#define ADL_OSMODEINFOORIENTATION_DEFAULT_WIN7    DISPLAYCONFIG_ROTATION_FORCE_UINT32
+#define ADL_OSMODEFLAG_DEFAULT                    0
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADLThreadingModel Enumeration
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup thread_model
+/// Used with \ref ADL_Main_ControlX2_Create and \ref ADL2_Main_ControlX2_Create to specify how ADL handles API calls when executed by multiple threads concurrently.
+/// \brief Declares ADL threading behavior.
+/// @{
+typedef enum ADLThreadingModel
+{
+    ADL_THREADING_UNLOCKED    = 0, /*!< Default behavior. ADL will not enforce serialization of ADL API executions by multiple threads.  Multiple threads will be allowed to enter to ADL at the same time. Note that ADL library is not guaranteed to be thread-safe. Client that calls ADL_Main_Control_Create have to provide its own mechanism for ADL calls serialization. */
+    ADL_THREADING_LOCKED     /*!< ADL will enforce serialization of ADL API when called by multiple threads.  Only single thread will be allowed to enter ADL API at the time. This option makes ADL calls thread-safe. You shouldn't use this option if ADL calls will be executed on Linux on x-server rendering thread. It can cause the application to hung.  */
+}ADLThreadingModel;
+
+/// @}
+///////////////////////////////////////////////////////////////////////////
+// ADLPurposeCode Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLPurposeCode
+{
+    ADL_PURPOSECODE_NORMAL    = 0,
+    ADL_PURPOSECODE_HIDE_MODE_SWITCH,
+    ADL_PURPOSECODE_MODE_SWITCH,
+    ADL_PURPOSECODE_ATTATCH_DEVICE,
+    ADL_PURPOSECODE_DETACH_DEVICE,
+    ADL_PURPOSECODE_SETPRIMARY_DEVICE,
+    ADL_PURPOSECODE_GDI_ROTATION,
+    ADL_PURPOSECODE_ATI_ROTATION
+};
+///////////////////////////////////////////////////////////////////////////
+// ADLAngle Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLAngle
+{
+    ADL_ANGLE_LANDSCAPE = 0,
+    ADL_ANGLE_ROTATERIGHT = 90,
+    ADL_ANGLE_ROTATE180 = 180,
+    ADL_ANGLE_ROTATELEFT = 270,
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLOrientationDataType Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLOrientationDataType
+{
+    ADL_ORIENTATIONTYPE_OSDATATYPE,
+    ADL_ORIENTATIONTYPE_NONOSDATATYPE
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLPanningMode Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLPanningMode
+{
+    ADL_PANNINGMODE_NO_PANNING = 0,
+    ADL_PANNINGMODE_AT_LEAST_ONE_NO_PANNING = 1,
+    ADL_PANNINGMODE_ALLOW_PANNING = 2,
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLLARGEDESKTOPTYPE Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLLARGEDESKTOPTYPE
+{
+    ADL_LARGEDESKTOPTYPE_NORMALDESKTOP = 0,
+    ADL_LARGEDESKTOPTYPE_PSEUDOLARGEDESKTOP = 1,
+    ADL_LARGEDESKTOPTYPE_VERYLARGEDESKTOP = 2
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLPlatform Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLPlatForm
+{
+    GRAPHICS_PLATFORM_DESKTOP  = 0,
+    GRAPHICS_PLATFORM_MOBILE   = 1
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLGraphicCoreGeneration Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLGraphicCoreGeneration
+{
+    ADL_GRAPHIC_CORE_GENERATION_UNDEFINED                   = 0,
+    ADL_GRAPHIC_CORE_GENERATION_PRE_GCN                     = 1,
+    ADL_GRAPHIC_CORE_GENERATION_GCN                         = 2,
+    ADL_GRAPHIC_CORE_GENERATION_RDNA                        = 3
+};
+
+// Other Definitions for internal use
+
+// Values for ADL_Display_WriteAndReadI2CRev_Get()
+
+#define ADL_I2C_MAJOR_API_REV           0x00000001
+#define ADL_I2C_MINOR_DEFAULT_API_REV   0x00000000
+#define ADL_I2C_MINOR_OEM_API_REV       0x00000001
+
+// Values for ADL_Display_WriteAndReadI2C()
+#define ADL_DL_I2C_LINE_OEM                0x00000001
+#define ADL_DL_I2C_LINE_OD_CONTROL         0x00000002
+#define ADL_DL_I2C_LINE_OEM2               0x00000003
+#define ADL_DL_I2C_LINE_OEM3               0x00000004
+#define ADL_DL_I2C_LINE_OEM4               0x00000005
+#define ADL_DL_I2C_LINE_OEM5               0x00000006
+#define ADL_DL_I2C_LINE_OEM6               0x00000007
+#define ADL_DL_I2C_LINE_GPIO               0x00000008
+
+// Max size of I2C data buffer
+#define ADL_DL_I2C_MAXDATASIZE             0x00000018
+#define ADL_DL_I2C_MAXWRITEDATASIZE        0x0000000C
+#define ADL_DL_I2C_MAXADDRESSLENGTH        0x00000006
+#define ADL_DL_I2C_MAXOFFSETLENGTH         0x00000004
+
+// I2C clock speed in KHz
+#define ADL_DL_I2C_SPEED_50K               50
+#define ADL_DL_I2C_SPEED_100K              100
+#define ALD_DL_I2C_SPEED_400K              400
+#define ADL_DL_I2C_SPEED_1M                1000
+#define ADL_DL_I2C_SPEED_2M                2300
+
+/// Values for ADLDisplayProperty.iPropertyType
+#define ADL_DL_DISPLAYPROPERTY_TYPE_UNKNOWN              0
+#define ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE        1
+#define ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING     2
+/// Enables ITC processing for HDMI panels that are capable of the feature
+#define ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE        9
+#define ADL_DL_DISPLAYPROPERTY_TYPE_DOWNSCALE            11
+#define ADL_DL_DISPLAYPROPERTY_TYPE_INTEGER_SCALING      12
+
+
+/// Values for ADLDisplayContent.iContentType
+/// Certain HDMI panels that support ITC have support for a feature such that, the display on the panel
+/// can be adjusted to optimize the view of the content being displayed, depending on the type of content.
+#define ADL_DL_DISPLAYCONTENT_TYPE_GRAPHICS        1
+#define ADL_DL_DISPLAYCONTENT_TYPE_PHOTO        2
+#define ADL_DL_DISPLAYCONTENT_TYPE_CINEMA        4
+#define ADL_DL_DISPLAYCONTENT_TYPE_GAME            8
+
+
+
+//values for ADLDisplayProperty.iExpansionMode
+#define ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER        0
+#define ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN    1
+#define ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO   2
+
+
+///\defgroup define_dither_states Dithering options
+/// @{
+/// Dithering disabled.
+#define ADL_DL_DISPLAY_DITHER_DISABLED              0
+/// Use default driver settings for dithering. Note that the default setting could be dithering disabled.
+#define ADL_DL_DISPLAY_DITHER_DRIVER_DEFAULT        1
+/// Temporal dithering to 6 bpc. Note that if the input is 12 bits, the two least significant bits will be truncated.
+#define ADL_DL_DISPLAY_DITHER_FM6                   2
+/// Temporal dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_FM8                   3
+/// Temporal dithering to 10 bpc.
+#define ADL_DL_DISPLAY_DITHER_FM10                  4
+/// Spatial dithering to 6 bpc. Note that if the input is 12 bits, the two least significant bits will be truncated.
+#define ADL_DL_DISPLAY_DITHER_DITH6                 5
+/// Spatial dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH8                 6
+/// Spatial dithering to 10 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH10                7
+/// Spatial dithering to 6 bpc. Random number generators are reset every frame, so the same input value of a certain pixel will always be dithered to the same output value. Note that if the input is 12 bits, the two least significant bits will be truncated.
+#define ADL_DL_DISPLAY_DITHER_DITH6_NO_FRAME_RAND   8
+/// Spatial dithering to 8 bpc. Random number generators are reset every frame, so the same input value of a certain pixel will always be dithered to the same output value.
+#define ADL_DL_DISPLAY_DITHER_DITH8_NO_FRAME_RAND   9
+/// Spatial dithering to 10 bpc. Random number generators are reset every frame, so the same input value of a certain pixel will always be dithered to the same output value.
+#define ADL_DL_DISPLAY_DITHER_DITH10_NO_FRAME_RAND  10
+/// Truncation to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN6                 11
+/// Truncation to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN8                 12
+/// Truncation to 10 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10                13
+/// Truncation to 10 bpc followed by spatial dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_DITH8          14
+/// Truncation to 10 bpc followed by spatial dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_DITH6          15
+/// Truncation to 10 bpc followed by temporal dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_FM8            16
+/// Truncation to 10 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_FM6            17
+/// Truncation to 10 bpc followed by spatial dithering to 8 bpc and temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_DITH8_FM6      18
+/// Spatial dithering to 10 bpc followed by temporal dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH10_FM8            19
+/// Spatial dithering to 10 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH10_FM6            20
+/// Truncation to 8 bpc followed by spatial dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN8_DITH6           21
+/// Truncation to 8 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN8_FM6             22
+/// Spatial dithering to 8 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH8_FM6             23
+#define ADL_DL_DISPLAY_DITHER_LAST                  ADL_DL_DISPLAY_DITHER_DITH8_FM6
+/// @}
+
+
+/// Display Get Cached EDID flag
+#define ADL_MAX_EDIDDATA_SIZE              256 // number of UCHAR
+#define ADL_MAX_OVERRIDEEDID_SIZE          512 // number of UCHAR
+#define ADL_MAX_EDID_EXTENSION_BLOCKS      3
+
+#define ADL_DL_CONTROLLER_OVERLAY_ALPHA         0
+#define ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX   1
+
+#define ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_RESET      0x00000000
+#define ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SET        0x00000001
+#define ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SCAN       0x00000002
+
+///\defgroup define_display_packet Display Data Packet Types
+/// @{
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__AVI              0x00000001
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__GAMMUT           0x00000002
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__VENDORINFO       0x00000004
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__HDR              0x00000008
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__SPD              0x00000010
+/// @}
+
+// matrix types
+#define ADL_GAMUT_MATRIX_SD         1   // SD matrix i.e. BT601
+#define ADL_GAMUT_MATRIX_HD         2   // HD matrix i.e. BT709
+
+///\defgroup define_clockinfo_flags Clock flags
+/// Used by ADLAdapterODClockInfo.iFlag
+/// @{
+#define ADL_DL_CLOCKINFO_FLAG_FULLSCREEN3DONLY         0x00000001
+#define ADL_DL_CLOCKINFO_FLAG_ALWAYSFULLSCREEN3D       0x00000002
+#define ADL_DL_CLOCKINFO_FLAG_VPURECOVERYREDUCED       0x00000004
+#define ADL_DL_CLOCKINFO_FLAG_THERMALPROTECTION        0x00000008
+/// @}
+
+// Supported GPUs
+// ADL_Display_PowerXpressActiveGPU_Get()
+#define ADL_DL_POWERXPRESS_GPU_INTEGRATED        1
+#define ADL_DL_POWERXPRESS_GPU_DISCRETE            2
+
+// Possible values for lpOperationResult
+// ADL_Display_PowerXpressActiveGPU_Get()
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_STARTED         1 // Switch procedure has been started - Windows platform only
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_DECLINED        2 // Switch procedure cannot be started - All platforms
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_ALREADY         3 // System already has required status  - All platforms
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_DEFERRED        5  // Switch was deferred and requires an X restart - Linux platform only
+
+// PowerXpress support version
+// ADL_Display_PowerXpressVersion_Get()
+#define ADL_DL_POWERXPRESS_VERSION_MAJOR            2    // Current PowerXpress support version 2.0
+#define ADL_DL_POWERXPRESS_VERSION_MINOR            0
+
+#define ADL_DL_POWERXPRESS_VERSION    (((ADL_DL_POWERXPRESS_VERSION_MAJOR) << 16) | ADL_DL_POWERXPRESS_VERSION_MINOR)
+
+//values for ADLThermalControllerInfo.iThermalControllerDomain
+#define ADL_DL_THERMAL_DOMAIN_OTHER      0
+#define ADL_DL_THERMAL_DOMAIN_GPU        1
+
+//values for ADLThermalControllerInfo.iFlags
+#define ADL_DL_THERMAL_FLAG_INTERRUPT    1
+#define ADL_DL_THERMAL_FLAG_FANCONTROL   2
+
+///\defgroup define_fanctrl Fan speed cotrol
+/// Values for ADLFanSpeedInfo.iFlags
+/// @{
+#define ADL_DL_FANCTRL_SUPPORTS_PERCENT_READ     1
+#define ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE    2
+#define ADL_DL_FANCTRL_SUPPORTS_RPM_READ         4
+#define ADL_DL_FANCTRL_SUPPORTS_RPM_WRITE        8
+/// @}
+
+//values for ADLFanSpeedValue.iSpeedType
+#define ADL_DL_FANCTRL_SPEED_TYPE_PERCENT    1
+#define ADL_DL_FANCTRL_SPEED_TYPE_RPM        2
+
+//values for ADLFanSpeedValue.iFlags
+#define ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED   1
+
+// MVPU interfaces
+#define ADL_DL_MAX_MVPU_ADAPTERS   4
+#define MVPU_ADAPTER_0          0x00000001
+#define MVPU_ADAPTER_1          0x00000002
+#define MVPU_ADAPTER_2          0x00000004
+#define MVPU_ADAPTER_3          0x00000008
+#define ADL_DL_MAX_REGISTRY_PATH   256
+
+//values for ADLMVPUStatus.iStatus
+#define ADL_DL_MVPU_STATUS_OFF   0
+#define ADL_DL_MVPU_STATUS_ON    1
+
+// values for ASIC family
+///\defgroup define_Asic_type Detailed asic types
+/// Defines for Adapter ASIC family type
+/// @{
+#define ADL_ASIC_UNDEFINED      0
+#define ADL_ASIC_DISCRETE       (1 << 0)
+#define ADL_ASIC_INTEGRATED     (1 << 1)
+#define ADL_ASIC_WORKSTATION    (1 << 2)
+#define ADL_ASIC_FIREMV         (1 << 3)
+#define ADL_ASIC_XGP            (1 << 4)
+#define ADL_ASIC_FUSION         (1 << 5)
+#define ADL_ASIC_FIRESTREAM     (1 << 6)
+#define ADL_ASIC_EMBEDDED       (1 << 7)
+// Backward compatibility
+#define ADL_ASIC_FIREGL  ADL_ASIC_WORKSTATION
+/// @}
+
+///\defgroup define_detailed_timing_flags Detailed Timimg Flags
+/// Defines for ADLDetailedTiming.sTimingFlags field
+/// @{
+#define ADL_DL_TIMINGFLAG_DOUBLE_SCAN              0x0001
+//sTimingFlags is set when the mode is INTERLACED, if not PROGRESSIVE
+#define ADL_DL_TIMINGFLAG_INTERLACED               0x0002
+//sTimingFlags is set when the Horizontal Sync is POSITIVE, if not NEGATIVE
+#define ADL_DL_TIMINGFLAG_H_SYNC_POLARITY          0x0004
+//sTimingFlags is set when the Vertical Sync is POSITIVE, if not NEGATIVE
+#define ADL_DL_TIMINGFLAG_V_SYNC_POLARITY          0x0008
+/// @}
+
+///\defgroup define_modetiming_standard Timing Standards
+/// Defines for ADLDisplayModeInfo.iTimingStandard field
+/// @{
+#define ADL_DL_MODETIMING_STANDARD_CVT             0x00000001 // CVT Standard
+#define ADL_DL_MODETIMING_STANDARD_GTF             0x00000002 // GFT Standard
+#define ADL_DL_MODETIMING_STANDARD_DMT             0x00000004 // DMT Standard
+#define ADL_DL_MODETIMING_STANDARD_CUSTOM          0x00000008 // User-defined standard
+#define ADL_DL_MODETIMING_STANDARD_DRIVER_DEFAULT  0x00000010 // Remove Mode from overriden list
+#define ADL_DL_MODETIMING_STANDARD_CVT_RB           0x00000020 // CVT-RB Standard
+/// @}
+
+// \defgroup define_xserverinfo driver x-server info
+/// These flags are used by ADL_XServerInfo_Get()
+// @
+
+/// Xinerama is active in the x-server, Xinerama extension may report it to be active but it
+/// may not be active in x-server
+#define ADL_XSERVERINFO_XINERAMAACTIVE            (1<<0)
+
+/// RandR 1.2 is supported by driver, RandR extension may report version 1.2
+/// but driver may not support it
+#define ADL_XSERVERINFO_RANDR12SUPPORTED          (1<<1)
+// @
+
+
+///\defgroup define_eyefinity_constants Eyefinity Definitions
+/// @{
+
+#define ADL_CONTROLLERVECTOR_0        1    // ADL_CONTROLLERINDEX_0 = 0, (1 << ADL_CONTROLLERINDEX_0)
+#define ADL_CONTROLLERVECTOR_1        2    // ADL_CONTROLLERINDEX_1 = 1, (1 << ADL_CONTROLLERINDEX_1)
+
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_000        0x00000001
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_090        0x00000002
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_180        0x00000004
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_270        0x00000008
+#define ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_LANDSCAPE     0x00000001
+#define ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+#define ADL_DISPLAY_SLSGRID_PORTAIT_MODE                         0x00000004
+#define ADL_DISPLAY_SLSGRID_KEEPTARGETROTATION                  0x00000080
+
+#define ADL_DISPLAY_SLSGRID_SAMEMODESLS_SUPPORT        0x00000010
+#define ADL_DISPLAY_SLSGRID_MIXMODESLS_SUPPORT        0x00000020
+#define ADL_DISPLAY_SLSGRID_DISPLAYROTATION_SUPPORT    0x00000040
+#define ADL_DISPLAY_SLSGRID_DESKTOPROTATION_SUPPORT    0x00000080
+
+
+#define ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FIT        0x0100
+#define ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FILL       0x0200
+#define ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_EXPAND     0x0400
+
+#define ADL_DISPLAY_SLSMAP_IS_SLS        0x1000
+#define ADL_DISPLAY_SLSMAP_IS_SLSBUILDER 0x2000
+#define ADL_DISPLAY_SLSMAP_IS_CLONEVT     0x4000
+
+#define ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_LANDSCAPE         0x00000001
+#define ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+
+#define ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_LANDSCAPE         0x00000001
+#define ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+
+#define ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_LANDSCAPE     0x00000001
+#define ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+
+#define ADL_SLS_SAMEMODESLS_SUPPORT         0x0001
+#define ADL_SLS_MIXMODESLS_SUPPORT          0x0002
+#define ADL_SLS_DISPLAYROTATIONSLS_SUPPORT  0x0004
+#define ADL_SLS_DESKTOPROTATIONSLS_SUPPORT  0x0008
+
+#define ADL_SLS_TARGETS_INVALID     0x0001
+#define ADL_SLS_MODES_INVALID       0x0002
+#define ADL_SLS_ROTATIONS_INVALID   0x0004
+#define ADL_SLS_POSITIONS_INVALID   0x0008
+#define ADL_SLS_LAYOUTMODE_INVALID  0x0010
+
+#define ADL_DISPLAY_SLSDISPLAYOFFSET_VALID        0x0002
+
+#define ADL_DISPLAY_SLSGRID_RELATIVETO_LANDSCAPE         0x00000010
+#define ADL_DISPLAY_SLSGRID_RELATIVETO_CURRENTANGLE     0x00000020
+
+
+/// The bit mask identifies displays is currently in bezel mode.
+#define ADL_DISPLAY_SLSMAP_BEZELMODE            0x00000010
+/// The bit mask identifies displays from this map is arranged.
+#define ADL_DISPLAY_SLSMAP_DISPLAYARRANGED        0x00000002
+/// The bit mask identifies this map is currently in used for the current adapter.
+#define ADL_DISPLAY_SLSMAP_CURRENTCONFIG        0x00000004
+
+///For onlay active SLS  map info
+#define ADL_DISPLAY_SLSMAPINDEXLIST_OPTION_ACTIVE        0x00000001
+
+///For Bezel
+#define ADL_DISPLAY_BEZELOFFSET_STEPBYSTEPSET            0x00000004
+#define ADL_DISPLAY_BEZELOFFSET_COMMIT                    0x00000008
+
+typedef enum SLS_ImageCropType {
+    Fit = 1,
+    Fill = 2,
+    Expand = 3
+}SLS_ImageCropType;
+
+
+typedef enum DceSettingsType {
+    DceSetting_HdmiLq,
+    DceSetting_DpSettings,
+    DceSetting_Protection
+
+} DceSettingsType;
+
+typedef enum DpLinkRate {
+    DPLinkRate_Unknown,
+    DPLinkRate_RBR,
+	DPLinkRate_2_16Gbps,
+	DPLinkRate_2_43Gbps,
+    DPLinkRate_HBR,
+	DPLinkRate_4_32Gbps,
+    DPLinkRate_HBR2,
+    DPLinkRate_HBR3,
+	DPLinkRate_UHBR10,
+	DPLinkRate_UHBR13D5,
+	DPLinkRate_UHBR20
+
+} DpLinkRate;
+
+/// @}
+
+///\defgroup define_powerxpress_constants PowerXpress Definitions
+/// @{
+
+/// The bit mask identifies PX caps for ADLPXConfigCaps.iPXConfigCapMask and ADLPXConfigCaps.iPXConfigCapValue
+#define    ADL_PX_CONFIGCAPS_SPLASHSCREEN_SUPPORT        0x0001
+#define    ADL_PX_CONFIGCAPS_CF_SUPPORT                0x0002
+#define    ADL_PX_CONFIGCAPS_MUXLESS                    0x0004
+#define    ADL_PX_CONFIGCAPS_PROFILE_COMPLIANT            0x0008
+#define    ADL_PX_CONFIGCAPS_NON_AMD_DRIVEN_DISPLAYS    0x0010
+#define ADL_PX_CONFIGCAPS_FIXED_SUPPORT             0x0020
+#define ADL_PX_CONFIGCAPS_DYNAMIC_SUPPORT           0x0040
+#define ADL_PX_CONFIGCAPS_HIDE_AUTO_SWITCH            0x0080
+
+/// The bit mask identifies PX schemes for ADLPXSchemeRange
+#define ADL_PX_SCHEMEMASK_FIXED                        0x0001
+#define ADL_PX_SCHEMEMASK_DYNAMIC                    0x0002
+
+/// PX Schemes
+typedef enum ADLPXScheme
+{
+    ADL_PX_SCHEME_INVALID   = 0,
+    ADL_PX_SCHEME_FIXED     = ADL_PX_SCHEMEMASK_FIXED,
+    ADL_PX_SCHEME_DYNAMIC   = ADL_PX_SCHEMEMASK_DYNAMIC
+}ADLPXScheme;
+
+/// Just keep the old definitions for compatibility, need to be removed later
+typedef enum PXScheme
+{
+    PX_SCHEME_INVALID   = 0,
+    PX_SCHEME_FIXED     = 1,
+    PX_SCHEME_DYNAMIC   = 2
+} PXScheme;
+
+
+/// @}
+
+///\defgroup define_appprofiles For Application Profiles
+/// @{
+
+#define ADL_APP_PROFILE_FILENAME_LENGTH        256
+#define ADL_APP_PROFILE_TIMESTAMP_LENGTH    32
+#define ADL_APP_PROFILE_VERSION_LENGTH        32
+#define ADL_APP_PROFILE_PROPERTY_LENGTH        64
+
+enum ApplicationListType
+{
+    ADL_PX40_MRU,
+    ADL_PX40_MISSED,
+    ADL_PX40_DISCRETE,
+    ADL_PX40_INTEGRATED,
+    ADL_MMD_PROFILED,
+    ADL_PX40_TOTAL
+};
+
+typedef enum ADLProfilePropertyType
+{
+    ADL_PROFILEPROPERTY_TYPE_BINARY        = 0,
+    ADL_PROFILEPROPERTY_TYPE_BOOLEAN,
+    ADL_PROFILEPROPERTY_TYPE_DWORD,
+    ADL_PROFILEPROPERTY_TYPE_QWORD,
+    ADL_PROFILEPROPERTY_TYPE_ENUMERATED,
+    ADL_PROFILEPROPERTY_TYPE_STRING
+}ADLProfilePropertyType;
+
+
+//Virtual display type returning virtual display type and for request for creating a dummy target ID (xInput or remote play)
+typedef enum ADL_VIRTUALDISPLAY_TYPE
+{
+	ADL_VIRTUALDISPLAY_NONE = 0,
+	ADL_VIRTUALDISPLAY_XINPUT = 1,			//Requested for xInput
+	ADL_VIRTUALDISPLAY_REMOTEPLAY = 2,		//Requested for emulated display during remote play
+	ADL_VIRTUALDISPLAY_GENERIC = 10			//Generic virtual display, af a type different than any of the above special ones
+}ADL_VIRTUALDISPLAY_TYPE;
+
+/// @}
+
+///\defgroup define_dp12 For Display Port 1.2
+/// @{
+
+/// Maximum Relative Address Link
+#define ADL_MAX_RAD_LINK_COUNT    15
+
+/// @}
+
+///\defgroup defines_gamutspace Driver Supported Gamut Space
+/// @{
+
+/// The flags desribes that gamut is related to source or to destination and to overlay or to graphics
+#define ADL_GAMUT_REFERENCE_SOURCE       (1 << 0)
+#define ADL_GAMUT_GAMUT_VIDEO_CONTENT    (1 << 1)
+
+/// The flags are used to describe the source of gamut and how read information from struct ADLGamutData
+#define ADL_CUSTOM_WHITE_POINT           (1 << 0)
+#define ADL_CUSTOM_GAMUT                 (1 << 1)
+#define ADL_GAMUT_REMAP_ONLY             (1 << 2)
+
+/// The define means the predefined gamut values  .
+///Driver uses to find entry in the table and apply appropriate gamut space.
+#define ADL_GAMUT_SPACE_CCIR_709     (1 << 0)
+#define ADL_GAMUT_SPACE_CCIR_601     (1 << 1)
+#define ADL_GAMUT_SPACE_ADOBE_RGB    (1 << 2)
+#define ADL_GAMUT_SPACE_CIE_RGB      (1 << 3)
+#define ADL_GAMUT_SPACE_CUSTOM       (1 << 4)
+#define ADL_GAMUT_SPACE_CCIR_2020    (1 << 5)
+#define ADL_GAMUT_SPACE_APPCTRL      (1 << 6)
+
+/// Predefine white point values are structed similar to gamut .
+#define ADL_WHITE_POINT_5000K       (1 << 0)
+#define ADL_WHITE_POINT_6500K       (1 << 1)
+#define ADL_WHITE_POINT_7500K       (1 << 2)
+#define ADL_WHITE_POINT_9300K       (1 << 3)
+#define ADL_WHITE_POINT_CUSTOM      (1 << 4)
+
+///gamut and white point coordinates are from 0.0 -1.0 and divider is used to find the real value .
+/// X float = X int /divider
+#define ADL_GAMUT_WHITEPOINT_DIVIDER           10000
+
+///gamma a0 coefficient uses the following divider:
+#define ADL_REGAMMA_COEFFICIENT_A0_DIVIDER       10000000
+///gamma a1 ,a2,a3 coefficients use the following divider:
+#define ADL_REGAMMA_COEFFICIENT_A1A2A3_DIVIDER   1000
+
+///describes whether the coefficients are from EDID or custom user values.
+#define ADL_EDID_REGAMMA_COEFFICIENTS          (1 << 0)
+///Used for struct ADLRegamma. Feature if set use gamma ramp, if missing use regamma coefficents
+#define ADL_USE_GAMMA_RAMP                     (1 << 4)
+///Used for struct ADLRegamma. If the gamma ramp flag is used then the driver could apply de gamma corretion to the supplied curve and this depends on this flag
+#define ADL_APPLY_DEGAMMA                      (1 << 5)
+///specifies that standard SRGB gamma should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_SRGB       (1 << 1)
+///specifies that PQ gamma curve should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_PQ         (1 << 2)
+///specifies that PQ gamma curve should be applied, lower max nits
+#define ADL_EDID_REGAMMA_PREDEFINED_PQ_2084_INTERIM (1 << 3)
+///specifies that 3.6 gamma should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_36         (1 << 6)
+///specifies that BT709 gama should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_BT709      (1 << 7)
+///specifies that regamma should be disabled, and application controls regamma content (of the whole screen)
+#define ADL_EDID_REGAMMA_PREDEFINED_APPCTRL    (1 << 8)
+
+/// @}
+
+/// \defgroup define_ddcinfo_pixelformats DDCInfo Pixel Formats
+/// @{
+/// defines for iPanelPixelFormat  in struct ADLDDCInfo2
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB656                       0x00000001L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB666                       0x00000002L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888                       0x00000004L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB101010                    0x00000008L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB161616                    0x00000010L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED1                0x00000020L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED2                0x00000040L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED3                0x00000080L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_XRGB_BIAS101010              0x00000100L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_8BPCC               0x00000200L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_10BPCC              0x00000400L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_12BPCC              0x00000800L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_8BPCC               0x00001000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_10BPCC              0x00002000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_12BPCC              0x00004000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_8BPCC               0x00008000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_10BPCC              0x00010000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_12BPCC              0x00020000L
+/// @}
+
+/// \defgroup define_source_content_TF ADLSourceContentAttributes transfer functions (gamma)
+/// @{
+/// defines for iTransferFunction in ADLSourceContentAttributes
+#define ADL_TF_sRGB                0x0001      ///< sRGB
+#define ADL_TF_BT709            0x0002      ///< BT.709
+#define ADL_TF_PQ2084            0x0004      ///< PQ2084
+#define ADL_TF_PQ2084_INTERIM    0x0008        ///< PQ2084-Interim
+#define ADL_TF_LINEAR_0_1        0x0010      ///< Linear 0 - 1
+#define ADL_TF_LINEAR_0_125        0x0020      ///< Linear 0 - 125
+#define ADL_TF_DOLBYVISION        0x0040      ///< DolbyVision
+#define ADL_TF_GAMMA_22         0x0080      ///< Plain 2.2 gamma curve
+/// @}
+
+/// \defgroup define_source_content_CS ADLSourceContentAttributes color spaces
+/// @{
+/// defines for iColorSpace in ADLSourceContentAttributes
+#define ADL_CS_sRGB                0x0001      ///< sRGB
+#define ADL_CS_BT601             0x0002      ///< BT.601
+#define ADL_CS_BT709            0x0004      ///< BT.709
+#define ADL_CS_BT2020            0x0008      ///< BT.2020
+#define ADL_CS_ADOBE            0x0010      ///< Adobe RGB
+#define ADL_CS_P3                0x0020      ///< DCI-P3
+#define ADL_CS_scRGB_MS_REF        0x0040      ///< scRGB (MS Reference)
+#define ADL_CS_DISPLAY_NATIVE    0x0080      ///< Display Native
+#define ADL_CS_APP_CONTROL         0x0100      ///< Application Controlled
+#define ADL_CS_DOLBYVISION      0x0200      ///< DolbyVision
+/// @}
+
+/// \defgroup define_HDR_support ADLDDCInfo2 HDR support options
+/// @{
+/// defines for iSupportedHDR in ADLDDCInfo2
+#define ADL_HDR_CEA861_3        0x0001      ///< HDR10/CEA861.3 HDR supported
+#define ADL_HDR_DOLBYVISION     0x0002      ///< \deprecated DolbyVision HDR supported
+#define ADL_HDR_FREESYNC_HDR    0x0004      ///< FreeSync HDR supported
+/// @}
+
+/// \defgroup define_FreesyncFlags ADLDDCInfo2 Freesync HDR flags
+/// @{
+/// defines for iFreesyncFlags in ADLDDCInfo2
+#define ADL_HDR_FREESYNC_BACKLIGHT_SUPPORT           0x0001      ///< Global backlight control supported
+#define ADL_HDR_FREESYNC_LOCAL_DIMMING               0x0002      ///< Local dimming supported
+/// @}
+
+/// \defgroup define_source_content_flags ADLSourceContentAttributes flags
+/// @{
+/// defines for iFlags in ADLSourceContentAttributes
+#define ADL_SCA_LOCAL_DIMMING_DISABLE    0x0001      ///< Disable local dimming
+/// @}
+
+/// \defgroup define_dbd_state Deep Bit Depth
+/// @{
+
+/// defines for ADL_Workstation_DeepBitDepth_Get and  ADL_Workstation_DeepBitDepth_Set functions
+// This value indicates that the deep bit depth state is forced off
+#define ADL_DEEPBITDEPTH_FORCEOFF     0
+/// This value indicates that the deep bit depth state  is set to auto, the driver will automatically enable the
+/// appropriate deep bit depth state depending on what connected display supports.
+#define ADL_DEEPBITDEPTH_10BPP_AUTO     1
+/// This value indicates that the deep bit depth state  is forced on to 10 bits per pixel, this is regardless if the display
+/// supports 10 bpp.
+#define ADL_DEEPBITDEPTH_10BPP_FORCEON     2
+
+/// defines for ADLAdapterConfigMemory of ADL_Adapter_ConfigMemory_Get
+/// If this bit is set, it indicates that the Deep Bit Depth pixel is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_DBD            (1 << 0)
+/// If this bit is set, it indicates that the display is rotated (90, 180 or 270)
+#define ADL_ADAPTER_CONFIGMEMORY_ROTATE            (1 << 1)
+/// If this bit is set, it indicates that passive stereo is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_STEREO_PASSIVE    (1 << 2)
+/// If this bit is set, it indicates that the active stereo is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_STEREO_ACTIVE    (1 << 3)
+/// If this bit is set, it indicates that the tear free vsync is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_ENHANCEDVSYNC    (1 << 4)
+#define ADL_ADAPTER_CONFIGMEMORY_TEARFREEVSYNC    (1 << 4)
+/// @}
+
+/// \defgroup define_adl_validmemoryrequiredfields Memory Type
+/// @{
+
+///  This group defines memory types in ADLMemoryRequired struct \n
+/// Indicates that this is the visible memory
+#define ADL_MEMORYREQTYPE_VISIBLE                (1 << 0)
+/// Indicates that this is the invisible memory.
+#define ADL_MEMORYREQTYPE_INVISIBLE                (1 << 1)
+/// Indicates that this is amount of visible memory per GPU that should be reserved for all other allocations.
+#define ADL_MEMORYREQTYPE_GPURESERVEDVISIBLE    (1 << 2)
+/// @}
+
+/// \defgroup define_adapter_tear_free_status
+/// Used in ADL_Adapter_TEAR_FREE_Set and ADL_Adapter_TFD_Get functions to indicate the tear free
+/// desktop status.
+/// @{
+/// Tear free desktop is enabled.
+#define ADL_ADAPTER_TEAR_FREE_ON                1
+/// Tear free desktop can't be enabled due to a lack of graphic adapter memory.
+#define ADL_ADAPTER_TEAR_FREE_NOTENOUGHMEM        -1
+/// Tear free desktop can't be enabled due to quad buffer stereo being enabled.
+#define ADL_ADAPTER_TEAR_FREE_OFF_ERR_QUADBUFFERSTEREO    -2
+/// Tear free desktop can't be enabled due to MGPU-SLS being enabled.
+#define ADL_ADAPTER_TEAR_FREE_OFF_ERR_MGPUSLD    -3
+/// Tear free desktop is disabled.
+#define ADL_ADAPTER_TEAR_FREE_OFF                0
+/// @}
+
+/// \defgroup define_adapter_crossdisplay_platforminfo
+/// Used in ADL_Adapter_CrossDisplayPlatformInfo_Get function to indicate the Crossdisplay platform info.
+/// @{
+/// CROSSDISPLAY platform.
+#define ADL_CROSSDISPLAY_PLATFORM                    (1 << 0)
+/// CROSSDISPLAY platform for Lasso station.
+#define ADL_CROSSDISPLAY_PLATFORM_LASSO                (1 << 1)
+/// CROSSDISPLAY platform for docking station.
+#define ADL_CROSSDISPLAY_PLATFORM_DOCKSTATION        (1 << 2)
+/// @}
+
+/// \defgroup define_adapter_crossdisplay_option
+/// Used in ADL_Adapter_CrossdisplayInfoX2_Set function to indicate cross display options.
+/// @{
+/// Checking if 3D application is runnning. If yes, not to do switch, return ADL_OK_WAIT; otherwise do switch.
+#define ADL_CROSSDISPLAY_OPTION_NONE            0
+/// Force switching without checking for running 3D applications
+#define ADL_CROSSDISPLAY_OPTION_FORCESWITCH        (1 << 0)
+/// @}
+
+/// \defgroup define_adapter_states Adapter Capabilities
+/// These defines the capabilities supported by an adapter. It is used by \ref ADL_Adapter_ConfigureState_Get
+/// @{
+/// Indicates that the adapter is headless (i.e. no displays can be connected to it)
+#define ADL_ADAPTERCONFIGSTATE_HEADLESS ( 1 << 2 )
+/// Indicates that the adapter is configured to define the main rendering capabilities. For example, adapters
+/// in Crossfire(TM) configuration, this bit would only be set on the adapter driving the display(s).
+#define ADL_ADAPTERCONFIGSTATE_REQUISITE_RENDER ( 1 << 0 )
+/// Indicates that the adapter is configured to be used to unload some of the rendering work for a particular
+/// requisite rendering adapter. For eample, for adapters in a Crossfire configuration, this bit would be set
+/// on all adapters that are currently not driving the display(s)
+#define ADL_ADAPTERCONFIGSTATE_ANCILLARY_RENDER ( 1 << 1 )
+/// Indicates that scatter gather feature enabled on the adapter
+#define ADL_ADAPTERCONFIGSTATE_SCATTERGATHER ( 1 << 4 )
+/// @}
+
+/// \defgroup define_controllermode_ulModifiers
+/// These defines the detailed actions supported by set viewport. It is used by \ref ADL_Display_ViewPort_Set
+/// @{
+/// Indicate that the viewport set will change the view position
+#define ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION       0x00000001
+/// Indicate that the viewport set will change the view PanLock
+#define ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK        0x00000002
+/// Indicate that the viewport set will change the view size
+#define ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE           0x00000008
+/// @}
+
+/// \defgroup defines for Mirabilis
+/// These defines are used for the Mirabilis feature
+/// @{
+///
+/// Indicates the maximum number of audio sample rates
+#define ADL_MAX_AUDIO_SAMPLE_RATE_COUNT                    16
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADLMultiChannelSplitStateFlag Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLMultiChannelSplitStateFlag
+{
+    ADLMultiChannelSplit_Unitialized = 0,
+    ADLMultiChannelSplit_Disabled    = 1,
+    ADLMultiChannelSplit_Enabled     = 2,
+    ADLMultiChannelSplit_SaveProfile = 3
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLSampleRate Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLSampleRate
+{
+    ADLSampleRate_32KHz =0,
+    ADLSampleRate_44P1KHz,
+    ADLSampleRate_48KHz,
+    ADLSampleRate_88P2KHz,
+    ADLSampleRate_96KHz,
+    ADLSampleRate_176P4KHz,
+    ADLSampleRate_192KHz,
+    ADLSampleRate_384KHz, //DP1.2
+    ADLSampleRate_768KHz, //DP1.2
+    ADLSampleRate_Undefined
+};
+
+/// \defgroup define_overdrive6_capabilities
+/// These defines the capabilities supported by Overdrive 6. It is used by \ref ADL_Overdrive6_Capabilities_Get
+/// @{
+/// Indicate that core (engine) clock can be changed.
+#define ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION               0x00000001
+/// Indicate that memory clock can be changed.
+#define ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION               0x00000002
+/// Indicate that graphics activity reporting is supported.
+#define ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR             0x00000004
+/// Indicate that power limit can be customized.
+#define ADL_OD6_CAPABILITY_POWER_CONTROL                    0x00000008
+/// Indicate that SVI2 Voltage Control is supported.
+#define ADL_OD6_CAPABILITY_VOLTAGE_CONTROL                  0x00000010
+/// Indicate that OD6+ percentage adjustment is supported.
+#define ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT               0x00000020
+/// Indicate that Thermal Limit Unlock is supported.
+#define ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK             0x00000040
+///Indicate that Fan speed needs to be displayed in RPM
+#define ADL_OD6_CAPABILITY_FANSPEED_IN_RPM                    0x00000080
+/// @}
+
+/// \defgroup define_overdrive6_supported_states
+/// These defines the power states supported by Overdrive 6. It is used by \ref ADL_Overdrive6_Capabilities_Get
+/// @{
+/// Indicate that overdrive is supported in the performance state.  This is currently the only state supported.
+#define ADL_OD6_SUPPORTEDSTATE_PERFORMANCE                  0x00000001
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_SUPPORTEDSTATE_POWER_SAVING                 0x00000002
+/// @}
+
+/// \defgroup define_overdrive6_getstateinfo
+/// These defines the power states to get information about. It is used by \ref ADL_Overdrive6_StateInfo_Get
+/// @{
+/// Get default clocks for the performance state.
+#define ADL_OD6_GETSTATEINFO_DEFAULT_PERFORMANCE            0x00000001
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_GETSTATEINFO_DEFAULT_POWER_SAVING           0x00000002
+/// Get clocks for current state.  Currently this is the same as \ref ADL_OD6_GETSTATEINFO_CUSTOM_PERFORMANCE
+/// since only performance state is supported.
+#define ADL_OD6_GETSTATEINFO_CURRENT                        0x00000003
+/// Get the modified clocks (if any) for the performance state.  If clocks were not modified
+/// through Overdrive 6, then this will return the same clocks as \ref ADL_OD6_GETSTATEINFO_DEFAULT_PERFORMANCE.
+#define ADL_OD6_GETSTATEINFO_CUSTOM_PERFORMANCE             0x00000004
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_GETSTATEINFO_CUSTOM_POWER_SAVING            0x00000005
+/// @}
+
+/// \defgroup define_overdrive6_getstate and define_overdrive6_getmaxclockadjust
+/// These defines the power states to get information about. It is used by \ref ADL_Overdrive6_StateEx_Get and \ref ADL_Overdrive6_MaxClockAdjust_Get
+/// @{
+/// Get default clocks for the performance state.  Only performance state is currently supported.
+#define ADL_OD6_STATE_PERFORMANCE            0x00000001
+/// @}
+
+/// \defgroup define_overdrive6_setstate
+/// These define which power state to set customized clocks on. It is used by \ref ADL_Overdrive6_State_Set
+/// @{
+/// Set customized clocks for the performance state.
+#define ADL_OD6_SETSTATE_PERFORMANCE                        0x00000001
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_SETSTATE_POWER_SAVING                       0x00000002
+/// @}
+
+/// \defgroup define_overdrive6_thermalcontroller_caps
+/// These defines the capabilities of the GPU thermal controller. It is used by \ref ADL_Overdrive6_ThermalController_Caps
+/// @{
+/// GPU thermal controller is supported.
+#define ADL_OD6_TCCAPS_THERMAL_CONTROLLER                   0x00000001
+/// GPU fan speed control is supported.
+#define ADL_OD6_TCCAPS_FANSPEED_CONTROL                     0x00000002
+/// Fan speed percentage can be read.
+#define ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ                0x00000100
+/// Fan speed can be set by specifying a percentage value.
+#define ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE               0x00000200
+/// Fan speed RPM (revolutions-per-minute) can be read.
+#define ADL_OD6_TCCAPS_FANSPEED_RPM_READ                    0x00000400
+/// Fan speed can be set by specifying an RPM value.
+#define ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE                   0x00000800
+/// @}
+
+/// \defgroup define_overdrive6_fanspeed_type
+/// These defines the fan speed type being reported. It is used by \ref ADL_Overdrive6_FanSpeed_Get
+/// @{
+/// Fan speed reported in percentage.
+#define ADL_OD6_FANSPEED_TYPE_PERCENT                       0x00000001
+/// Fan speed reported in RPM.
+#define ADL_OD6_FANSPEED_TYPE_RPM                           0x00000002
+/// Fan speed has been customized by the user, and fan is not running in automatic mode.
+#define ADL_OD6_FANSPEED_USER_DEFINED                       0x00000100
+/// @}
+
+/// \defgroup define_overdrive_EventCounter_type
+/// These defines the EventCounter type being reported. It is used by \ref ADL2_OverdriveN_CountOfEvents_Get ,can be used on older OD version supported ASICs also.
+/// @{
+#define ADL_ODN_EVENTCOUNTER_THERMAL        0
+#define ADL_ODN_EVENTCOUNTER_VPURECOVERY    1
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADLODNControlType Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLODNControlType
+{
+    ODNControlType_Current = 0,
+    ODNControlType_Default,
+    ODNControlType_Auto,
+    ODNControlType_Manual
+};
+
+enum ADLODNDPMMaskType
+{
+     ADL_ODN_DPM_CLOCK               = 1 << 0,
+     ADL_ODN_DPM_VDDC                = 1 << 1,
+     ADL_ODN_DPM_MASK                = 1 << 2,
+};
+
+//ODN features Bits for ADLODNCapabilitiesX2
+enum ADLODNFeatureControl
+{
+     ADL_ODN_SCLK_DPM                = 1 << 0,
+     ADL_ODN_MCLK_DPM                = 1 << 1,
+     ADL_ODN_SCLK_VDD                = 1 << 2,
+     ADL_ODN_MCLK_VDD                = 1 << 3,
+     ADL_ODN_FAN_SPEED_MIN           = 1 << 4,
+     ADL_ODN_FAN_SPEED_TARGET        = 1 << 5,
+     ADL_ODN_ACOUSTIC_LIMIT_SCLK     = 1 << 6,
+     ADL_ODN_TEMPERATURE_FAN_MAX     = 1 << 7,
+     ADL_ODN_TEMPERATURE_SYSTEM      = 1 << 8,
+     ADL_ODN_POWER_LIMIT             = 1 << 9,
+     ADL_ODN_SCLK_AUTO_LIMIT             = 1 << 10,
+     ADL_ODN_MCLK_AUTO_LIMIT             = 1 << 11,
+     ADL_ODN_SCLK_DPM_MASK_ENABLE        = 1 << 12,
+     ADL_ODN_MCLK_DPM_MASK_ENABLE        = 1 << 13,
+     ADL_ODN_MCLK_UNDERCLOCK_ENABLE      = 1 << 14,
+     ADL_ODN_SCLK_DPM_THROTTLE_NOTIFY    = 1 << 15,
+     ADL_ODN_POWER_UTILIZATION           = 1 << 16,
+     ADL_ODN_PERF_TUNING_SLIDER          = 1 << 17,
+     ADL_ODN_REMOVE_WATTMAN_PAGE         = 1u << 31 // Internal Only
+};
+
+//If any new feature is added, PPLIB only needs to add ext feature ID and Item ID(Seeting ID). These IDs should match the drive defined in CWDDEPM.h
+enum ADLODNExtFeatureControl
+{
+	ADL_ODN_EXT_FEATURE_MEMORY_TIMING_TUNE = 1 << 0,
+	ADL_ODN_EXT_FEATURE_FAN_ZERO_RPM_CONTROL = 1 << 1,
+	ADL_ODN_EXT_FEATURE_AUTO_UV_ENGINE = 1 << 2,   //Auto under voltage
+	ADL_ODN_EXT_FEATURE_AUTO_OC_ENGINE = 1 << 3,   //Auto OC Enine
+	ADL_ODN_EXT_FEATURE_AUTO_OC_MEMORY = 1 << 4,   //Auto OC memory
+	ADL_ODN_EXT_FEATURE_FAN_CURVE = 1 << 5    //Fan curve
+
+};
+
+//If any new feature is added, PPLIB only needs to add ext feature ID and Item ID(Seeting ID).These IDs should match the drive defined in CWDDEPM.h
+enum ADLODNExtSettingId
+{
+	ADL_ODN_PARAMETER_AC_TIMING = 0,
+	ADL_ODN_PARAMETER_FAN_ZERO_RPM_CONTROL,
+	ADL_ODN_PARAMETER_AUTO_UV_ENGINE,
+	ADL_ODN_PARAMETER_AUTO_OC_ENGINE,
+	ADL_ODN_PARAMETER_AUTO_OC_MEMORY,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_1,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_1,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_2,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_2,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_3,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_3,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_4,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_4,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_5,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_5,
+    ADL_ODN_POWERGAUGE,
+	ODN_COUNT
+
+} ;
+
+//OD8 Capability features bits
+enum ADLOD8FeatureControl
+{
+    ADL_OD8_GFXCLK_LIMITS = 1 << 0,
+    ADL_OD8_GFXCLK_CURVE = 1 << 1,
+    ADL_OD8_UCLK_MAX = 1 << 2,
+    ADL_OD8_POWER_LIMIT = 1 << 3,
+    ADL_OD8_ACOUSTIC_LIMIT_SCLK = 1 << 4,   //FanMaximumRpm
+    ADL_OD8_FAN_SPEED_MIN = 1 << 5,   //FanMinimumPwm
+    ADL_OD8_TEMPERATURE_FAN = 1 << 6,   //FanTargetTemperature
+    ADL_OD8_TEMPERATURE_SYSTEM = 1 << 7,    //MaxOpTemp
+    ADL_OD8_MEMORY_TIMING_TUNE = 1 << 8,
+    ADL_OD8_FAN_ZERO_RPM_CONTROL = 1 << 9 ,
+	ADL_OD8_AUTO_UV_ENGINE = 1 << 10,  //Auto under voltage
+	ADL_OD8_AUTO_OC_ENGINE = 1 << 11,  //Auto overclock engine
+	ADL_OD8_AUTO_OC_MEMORY = 1 << 12,  //Auto overclock memory
+	ADL_OD8_FAN_CURVE = 1 << 13,   //Fan curve
+	ADL_OD8_WS_AUTO_FAN_ACOUSTIC_LIMIT = 1 << 14, //Workstation Manual Fan controller
+    ADL_OD8_GFXCLK_QUADRATIC_CURVE = 1 << 15,
+    ADL_OD8_OPTIMIZED_GPU_POWER_MODE = 1 << 16,
+    ADL_OD8_ODVOLTAGE_LIMIT = 1 << 17,
+    ADL_OD8_ADV_OC_LIMITS = 1 << 18,  //Advanced OC limits.
+    ADL_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET = 1 << 19,  //Per Zone gfx voltage offset feature
+    ADL_OD8_AUTO_CURVE_OPTIMIZER = 1 << 20,  //Auto per zone tuning.
+    ADL_OD8_GFX_VOLTAGE_LIMIT = 1 << 21,  //Voltage limit slider
+    ADL_OD8_TDC_LIMIT = 1 << 22,  //TDC slider
+    ADL_OD8_FULL_CONTROL_MODE = 1 << 23,  //Full control
+    ADL_OD8_POWER_SAVING_FEATURE_CONTROL = 1 << 24,  //Power saving feature control
+    ADL_OD8_POWER_GAUGE = 1 << 25 //Power Gauge
+};
+
+
+typedef enum ADLOD8SettingId
+{
+	OD8_GFXCLK_FMAX = 0,
+	OD8_GFXCLK_FMIN,
+	OD8_GFXCLK_FREQ1,
+	OD8_GFXCLK_VOLTAGE1,
+	OD8_GFXCLK_FREQ2,
+	OD8_GFXCLK_VOLTAGE2,
+	OD8_GFXCLK_FREQ3,
+	OD8_GFXCLK_VOLTAGE3,
+	OD8_UCLK_FMAX,
+	OD8_POWER_PERCENTAGE,
+	OD8_FAN_MIN_SPEED,
+	OD8_FAN_ACOUSTIC_LIMIT,
+	OD8_FAN_TARGET_TEMP,
+	OD8_OPERATING_TEMP_MAX,
+	OD8_AC_TIMING,
+	OD8_FAN_ZERORPM_CONTROL,
+	OD8_AUTO_UV_ENGINE_CONTROL,
+	OD8_AUTO_OC_ENGINE_CONTROL,
+	OD8_AUTO_OC_MEMORY_CONTROL,
+	OD8_FAN_CURVE_TEMPERATURE_1,
+	OD8_FAN_CURVE_SPEED_1,
+	OD8_FAN_CURVE_TEMPERATURE_2,
+	OD8_FAN_CURVE_SPEED_2,
+	OD8_FAN_CURVE_TEMPERATURE_3,
+	OD8_FAN_CURVE_SPEED_3,
+	OD8_FAN_CURVE_TEMPERATURE_4,
+	OD8_FAN_CURVE_SPEED_4,
+	OD8_FAN_CURVE_TEMPERATURE_5,
+	OD8_FAN_CURVE_SPEED_5,
+	OD8_WS_FAN_AUTO_FAN_ACOUSTIC_LIMIT,
+    OD8_GFXCLK_CURVE_COEFFICIENT_A, // As part of the agreement with UI team, the min/max voltage limits for the
+    OD8_GFXCLK_CURVE_COEFFICIENT_B, // quadratic curve graph will be stored in the min and max limits of
+    OD8_GFXCLK_CURVE_COEFFICIENT_C, // coefficient a, b and c. A, b and c themselves do not have limits.
+    OD8_GFXCLK_CURVE_VFT_FMIN,
+    OD8_UCLK_FMIN,
+    OD8_FAN_ZERO_RPM_STOP_TEMPERATURE,
+    OD8_OPTIMZED_POWER_MODE,
+    OD8_OD_VOLTAGE,// RSX - voltage offset feature
+    OD8_ADV_OC_LIMITS_SETTING,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_1,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_2,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_3,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_4,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_5,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_6,
+    OD8_AUTO_CURVE_OPTIMIZER_SETTING,
+    OD8_GFX_VOLTAGE_LIMIT_SETTING,
+    OD8_TDC_PERCENTAGE,
+    OD8_FULL_CONTROL_MODE_SETTING,
+    OD8_IDLE_POWER_SAVING_FEATURE_CONTROL,
+    OD8_RUNTIME_POWER_SAVING_FEATURE_CONTROL,
+    OD8_POWER_GAUGE,
+    OD8_COUNT
+} ADLOD8SettingId;
+
+
+//Define Performance Metrics Log max sensors number
+#define ADL_PMLOG_MAX_SENSORS  256
+
+/// \deprecated Replaced with ADL_PMLOG_SENSORS
+typedef enum ADLSensorType
+{
+    SENSOR_MAXTYPES             = 0,
+    PMLOG_CLK_GFXCLK            = 1,    // Current graphic clock value in MHz
+    PMLOG_CLK_MEMCLK            = 2,    // Current memory clock value in MHz
+    PMLOG_CLK_SOCCLK            = 3,
+    PMLOG_CLK_UVDCLK1           = 4,
+    PMLOG_CLK_UVDCLK2           = 5,
+    PMLOG_CLK_VCECLK            = 6,
+    PMLOG_CLK_VCNCLK            = 7,
+    PMLOG_TEMPERATURE_EDGE      = 8,    // Current edge of the die temperature value in C
+    PMLOG_TEMPERATURE_MEM       = 9,
+    PMLOG_TEMPERATURE_VRVDDC    = 10,
+    PMLOG_TEMPERATURE_VRMVDD    = 11,
+    PMLOG_TEMPERATURE_LIQUID    = 12,
+    PMLOG_TEMPERATURE_PLX       = 13,
+    PMLOG_FAN_RPM               = 14,   // Current fan RPM value
+    PMLOG_FAN_PERCENTAGE        = 15,   // Current ratio of fan RPM and max RPM
+    PMLOG_SOC_VOLTAGE           = 16,
+    PMLOG_SOC_POWER             = 17,
+    PMLOG_SOC_CURRENT           = 18,
+    PMLOG_INFO_ACTIVITY_GFX     = 19,   // Current graphic activity level in percentage
+    PMLOG_INFO_ACTIVITY_MEM     = 20,   // Current memory activity level in percentage
+    PMLOG_GFX_VOLTAGE           = 21,   // Current graphic voltage in mV
+    PMLOG_MEM_VOLTAGE           = 22,
+    PMLOG_ASIC_POWER            = 23,   // Current ASIC power draw in Watt
+    PMLOG_TEMPERATURE_VRSOC     = 24,
+    PMLOG_TEMPERATURE_VRMVDD0   = 25,
+    PMLOG_TEMPERATURE_VRMVDD1   = 26,
+    PMLOG_TEMPERATURE_HOTSPOT   = 27,   // Current center of the die temperature value in C
+    PMLOG_TEMPERATURE_GFX       = 28,
+    PMLOG_TEMPERATURE_SOC       = 29,
+    PMLOG_GFX_POWER             = 30,
+    PMLOG_GFX_CURRENT           = 31,
+    PMLOG_TEMPERATURE_CPU       = 32,
+    PMLOG_CPU_POWER             = 33,
+    PMLOG_CLK_CPUCLK            = 34,
+    PMLOG_THROTTLER_STATUS      = 35,   // A bit map of GPU throttle information. If a bit is set, the bit represented type of thorttling occurred in the last metrics sampling period
+    PMLOG_CLK_VCN1CLK1          = 36,
+    PMLOG_CLK_VCN1CLK2          = 37,
+    PMLOG_SMART_POWERSHIFT_CPU  = 38,
+    PMLOG_SMART_POWERSHIFT_DGPU = 39,
+    PMLOG_BUS_SPEED             = 40,   // Current PCIE bus speed running
+    PMLOG_BUS_LANES             = 41,   // Current PCIE bus lanes using
+    PMLOG_TEMPERATURE_LIQUID0   = 42,
+    PMLOG_TEMPERATURE_LIQUID1   = 43,
+    PMLOG_CLK_FCLK              = 44,
+    PMLOG_THROTTLER_STATUS_CPU  = 45,
+    PMLOG_SSPAIRED_ASICPOWER    = 46, // apuPower
+    PMLOG_SSTOTAL_POWERLIMIT    = 47, // Total Power limit    
+    PMLOG_SSAPU_POWERLIMIT      = 48, // APU Power limit
+    PMLOG_SSDGPU_POWERLIMIT     = 49, // DGPU Power limit
+    PMLOG_TEMPERATURE_HOTSPOT_GCD      = 50,
+    PMLOG_TEMPERATURE_HOTSPOT_MCD      = 51,
+    PMLOG_THROTTLER_TEMP_EDGE_PERCENTAGE        = 52,
+    PMLOG_THROTTLER_TEMP_HOTSPOT_PERCENTAGE     = 53,
+    PMLOG_THROTTLER_TEMP_HOTSPOT_GCD_PERCENTAGE = 54,
+    PMLOG_THROTTLER_TEMP_HOTSPOT_MCD_PERCENTAGE = 55,
+    PMLOG_THROTTLER_TEMP_MEM_PERCENTAGE     = 56,
+    PMLOG_THROTTLER_TEMP_VR_GFX_PERCENTAGE  = 57,
+    PMLOG_THROTTLER_TEMP_VR_MEM0_PERCENTAGE = 58,
+    PMLOG_THROTTLER_TEMP_VR_MEM1_PERCENTAGE = 59,
+    PMLOG_THROTTLER_TEMP_VR_SOC_PERCENTAGE  = 60,
+    PMLOG_THROTTLER_TEMP_LIQUID0_PERCENTAGE = 61,
+    PMLOG_THROTTLER_TEMP_LIQUID1_PERCENTAGE = 62,
+    PMLOG_THROTTLER_TEMP_PLX_PERCENTAGE = 63,
+    PMLOG_THROTTLER_TDC_GFX_PERCENTAGE  = 64,
+    PMLOG_THROTTLER_TDC_SOC_PERCENTAGE  = 65,
+    PMLOG_THROTTLER_TDC_USR_PERCENTAGE  = 66,
+    PMLOG_THROTTLER_PPT0_PERCENTAGE     = 67,
+    PMLOG_THROTTLER_PPT1_PERCENTAGE     = 68,
+    PMLOG_THROTTLER_PPT2_PERCENTAGE     = 69,
+    PMLOG_THROTTLER_PPT3_PERCENTAGE     = 70,
+    PMLOG_THROTTLER_FIT_PERCENTAGE           = 71,
+    PMLOG_THROTTLER_GFX_APCC_PLUS_PERCENTAGE = 72,
+    PMLOG_BOARD_POWER                        = 73,
+    PMLOG_MAX_SENSORS_REAL
+} ADLSensorType;
+
+
+//Throttle Status
+typedef enum ADL_THROTTLE_NOTIFICATION
+{
+	ADL_PMLOG_THROTTLE_POWER = 1 << 0,
+	ADL_PMLOG_THROTTLE_THERMAL = 1 << 1,
+	ADL_PMLOG_THROTTLE_CURRENT = 1 << 2,
+} ADL_THROTTLE_NOTIFICATION;
+
+typedef enum ADL_PMLOG_SENSORS
+{
+    ADL_SENSOR_MAXTYPES             = 0,
+    ADL_PMLOG_CLK_GFXCLK            = 1,
+    ADL_PMLOG_CLK_MEMCLK            = 2,
+    ADL_PMLOG_CLK_SOCCLK            = 3,
+    ADL_PMLOG_CLK_UVDCLK1           = 4,
+    ADL_PMLOG_CLK_UVDCLK2           = 5,
+    ADL_PMLOG_CLK_VCECLK            = 6,
+    ADL_PMLOG_CLK_VCNCLK            = 7,
+    ADL_PMLOG_TEMPERATURE_EDGE      = 8,
+    ADL_PMLOG_TEMPERATURE_MEM       = 9,
+    ADL_PMLOG_TEMPERATURE_VRVDDC    = 10,
+    ADL_PMLOG_TEMPERATURE_VRMVDD    = 11,
+    ADL_PMLOG_TEMPERATURE_LIQUID    = 12,
+    ADL_PMLOG_TEMPERATURE_PLX       = 13,
+    ADL_PMLOG_FAN_RPM               = 14,
+    ADL_PMLOG_FAN_PERCENTAGE        = 15,
+    ADL_PMLOG_SOC_VOLTAGE           = 16,
+    ADL_PMLOG_SOC_POWER             = 17,
+    ADL_PMLOG_SOC_CURRENT           = 18,
+    ADL_PMLOG_INFO_ACTIVITY_GFX     = 19,
+    ADL_PMLOG_INFO_ACTIVITY_MEM     = 20,
+    ADL_PMLOG_GFX_VOLTAGE           = 21,
+    ADL_PMLOG_MEM_VOLTAGE           = 22,
+    ADL_PMLOG_ASIC_POWER            = 23,
+    ADL_PMLOG_TEMPERATURE_VRSOC     = 24,
+    ADL_PMLOG_TEMPERATURE_VRMVDD0   = 25,
+    ADL_PMLOG_TEMPERATURE_VRMVDD1   = 26,
+    ADL_PMLOG_TEMPERATURE_HOTSPOT   = 27,
+    ADL_PMLOG_TEMPERATURE_GFX       = 28,
+    ADL_PMLOG_TEMPERATURE_SOC       = 29,
+    ADL_PMLOG_GFX_POWER             = 30,
+    ADL_PMLOG_GFX_CURRENT           = 31,
+    ADL_PMLOG_TEMPERATURE_CPU       = 32,
+    ADL_PMLOG_CPU_POWER             = 33,
+    ADL_PMLOG_CLK_CPUCLK            = 34,
+    ADL_PMLOG_THROTTLER_STATUS      = 35,   // GFX
+    ADL_PMLOG_CLK_VCN1CLK1          = 36,
+    ADL_PMLOG_CLK_VCN1CLK2          = 37,
+    ADL_PMLOG_SMART_POWERSHIFT_CPU  = 38,
+    ADL_PMLOG_SMART_POWERSHIFT_DGPU = 39,
+    ADL_PMLOG_BUS_SPEED             = 40,
+    ADL_PMLOG_BUS_LANES             = 41,
+    ADL_PMLOG_TEMPERATURE_LIQUID0   = 42,
+    ADL_PMLOG_TEMPERATURE_LIQUID1   = 43,
+    ADL_PMLOG_CLK_FCLK              = 44,
+    ADL_PMLOG_THROTTLER_STATUS_CPU  = 45,
+    ADL_PMLOG_SSPAIRED_ASICPOWER    = 46, // apuPower
+    ADL_PMLOG_SSTOTAL_POWERLIMIT    = 47, // Total Power limit
+    ADL_PMLOG_SSAPU_POWERLIMIT      = 48, // APU Power limit
+    ADL_PMLOG_SSDGPU_POWERLIMIT     = 49, // DGPU Power limit
+    ADL_PMLOG_TEMPERATURE_HOTSPOT_GCD      = 50,
+    ADL_PMLOG_TEMPERATURE_HOTSPOT_MCD      = 51,
+    ADL_PMLOG_THROTTLER_TEMP_EDGE_PERCENTAGE        = 52,
+    ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_PERCENTAGE     = 53,
+    ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_GCD_PERCENTAGE = 54,
+    ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_MCD_PERCENTAGE = 55,
+    ADL_PMLOG_THROTTLER_TEMP_MEM_PERCENTAGE     = 56,
+    ADL_PMLOG_THROTTLER_TEMP_VR_GFX_PERCENTAGE  = 57,
+    ADL_PMLOG_THROTTLER_TEMP_VR_MEM0_PERCENTAGE = 58,
+    ADL_PMLOG_THROTTLER_TEMP_VR_MEM1_PERCENTAGE = 59,
+    ADL_PMLOG_THROTTLER_TEMP_VR_SOC_PERCENTAGE  = 60,
+    ADL_PMLOG_THROTTLER_TEMP_LIQUID0_PERCENTAGE = 61,
+    ADL_PMLOG_THROTTLER_TEMP_LIQUID1_PERCENTAGE = 62,
+    ADL_PMLOG_THROTTLER_TEMP_PLX_PERCENTAGE = 63,
+    ADL_PMLOG_THROTTLER_TDC_GFX_PERCENTAGE  = 64,
+    ADL_PMLOG_THROTTLER_TDC_SOC_PERCENTAGE  = 65,
+    ADL_PMLOG_THROTTLER_TDC_USR_PERCENTAGE  = 66,
+    ADL_PMLOG_THROTTLER_PPT0_PERCENTAGE     = 67,
+    ADL_PMLOG_THROTTLER_PPT1_PERCENTAGE     = 68,
+    ADL_PMLOG_THROTTLER_PPT2_PERCENTAGE     = 69,
+    ADL_PMLOG_THROTTLER_PPT3_PERCENTAGE     = 70,
+    ADL_PMLOG_THROTTLER_FIT_PERCENTAGE           = 71,
+    ADL_PMLOG_THROTTLER_GFX_APCC_PLUS_PERCENTAGE = 72,
+    ADL_PMLOG_BOARD_POWER                        = 73,
+    ADL_PMLOG_MAX_SENSORS_REAL
+} ADL_PMLOG_SENSORS;
+
+/// \defgroup define_ecc_mode_states
+/// These defines the ECC(Error Correction Code) state. It is used by \ref ADL_Workstation_ECC_Get,ADL_Workstation_ECC_Set
+/// @{
+/// Error Correction is OFF.
+#define ECC_MODE_OFF 0
+/// Error Correction is ECCV2.
+#define ECC_MODE_ON 2
+/// Error Correction is HBM.
+#define ECC_MODE_HBM 3
+/// @}
+
+/// \defgroup define_board_layout_flags
+/// These defines are the board layout flags state which indicates what are the valid properties of \ref ADLBoardLayoutInfo . It is used by \ref ADL_Adapter_BoardLayout_Get
+/// @{
+/// Indicates the number of slots is valid.
+#define ADL_BLAYOUT_VALID_NUMBER_OF_SLOTS 0x1
+/// Indicates the slot sizes are valid. Size of the slot consists of the length and width.
+#define ADL_BLAYOUT_VALID_SLOT_SIZES 0x2
+/// Indicates the connector offsets are valid.
+#define ADL_BLAYOUT_VALID_CONNECTOR_OFFSETS 0x4
+/// Indicates the connector lengths is valid.
+#define ADL_BLAYOUT_VALID_CONNECTOR_LENGTHS 0x8
+/// @}
+
+/// \defgroup define_max_constants
+/// These defines are the maximum value constants.
+/// @{
+/// Indicates the Maximum supported slots on board.
+#define ADL_ADAPTER_MAX_SLOTS 4
+/// Indicates the Maximum supported connectors on slot.
+#define ADL_ADAPTER_MAX_CONNECTORS 10
+/// Indicates the Maximum supported properties of connection
+#define ADL_MAX_CONNECTION_TYPES 32
+/// Indicates the Maximum relative address link count.
+#define ADL_MAX_RELATIVE_ADDRESS_LINK_COUNT 15
+/// Indicates the Maximum size of EDID data block size
+#define ADL_MAX_DISPLAY_EDID_DATA_SIZE 1024
+/// Indicates the Maximum count of Error Records.
+#define ADL_MAX_ERROR_RECORDS_COUNT  256
+/// Indicates the maximum number of power states supported
+#define ADL_MAX_POWER_POLICY    6
+/// @}
+
+/// \defgroup define_connection_types
+/// These defines are the connection types constants which indicates  what are the valid connection type of given connector. It is used by \ref ADL_Adapter_SupportedConnections_Get
+/// @{
+/// Indicates the VGA connection type is valid.
+#define ADL_CONNECTION_TYPE_VGA 0
+/// Indicates the DVI_I connection type is valid.
+#define ADL_CONNECTION_TYPE_DVI 1
+/// Indicates the DVI_SL connection type is valid.
+#define ADL_CONNECTION_TYPE_DVI_SL 2
+/// Indicates the HDMI connection type is valid.
+#define ADL_CONNECTION_TYPE_HDMI 3
+/// Indicates the DISPLAY PORT connection type is valid.
+#define ADL_CONNECTION_TYPE_DISPLAY_PORT 4
+/// Indicates the Active dongle DP->DVI(single link) connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_SL 5
+/// Indicates the Active dongle DP->DVI(double link) connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_DL 6
+/// Indicates the Active dongle DP->HDMI connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_HDMI 7
+/// Indicates the Active dongle DP->VGA connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_VGA 8
+/// Indicates the Passive dongle DP->HDMI connection type is valid.
+#define ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_HDMI 9
+/// Indicates the Active dongle DP->VGA connection type is valid.
+#define ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_DVI 10
+/// Indicates the MST type is valid.
+#define ADL_CONNECTION_TYPE_MST 11
+/// Indicates the active dongle, all types.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE          12
+/// Indicates the Virtual Connection Type.
+#define ADL_CONNECTION_TYPE_VIRTUAL    13
+/// Macros for generating bitmask from index.
+#define ADL_CONNECTION_BITMAST_FROM_INDEX(index) (1 << index)
+/// @}
+
+/// \defgroup define_connection_properties
+/// These defines are the connection properties which indicates what are the valid properties of given connection type. It is used by \ref ADL_Adapter_SupportedConnections_Get
+/// @{
+/// Indicates the property Bitrate is valid.
+#define ADL_CONNECTION_PROPERTY_BITRATE 0x1
+/// Indicates the property number of lanes is valid.
+#define ADL_CONNECTION_PROPERTY_NUMBER_OF_LANES 0x2
+/// Indicates the property 3D caps is valid.
+#define ADL_CONNECTION_PROPERTY_3DCAPS  0x4
+/// Indicates the property output bandwidth is valid.
+#define ADL_CONNECTION_PROPERTY_OUTPUT_BANDWIDTH 0x8
+/// Indicates the property colordepth is valid.
+#define ADL_CONNECTION_PROPERTY_COLORDEPTH  0x10
+/// @}
+
+/// \defgroup define_lanecount_constants
+/// These defines are the Lane count constants which will be used in DP & etc.
+/// @{
+/// Indicates if lane count is unknown
+#define ADL_LANECOUNT_UNKNOWN 0
+/// Indicates if lane count is 1
+#define ADL_LANECOUNT_ONE 1
+/// Indicates if lane count is 2
+#define ADL_LANECOUNT_TWO 2
+/// Indicates if lane count is 4
+#define ADL_LANECOUNT_FOUR 4
+/// Indicates if lane count is 8
+#define ADL_LANECOUNT_EIGHT 8
+/// Indicates default value of lane count
+#define ADL_LANECOUNT_DEF ADL_LANECOUNT_FOUR
+/// @}
+
+/// \defgroup define_linkrate_constants
+/// These defines are the link rate constants which will be used in DP & etc.
+/// @{
+/// Indicates if link rate is unknown
+#define ADL_LINK_BITRATE_UNKNOWN 0
+/// Indicates if link rate is 1.62Ghz
+#define ADL_LINK_BITRATE_1_62_GHZ 0x06
+/// Indicates if link rate is 2.7Ghz
+#define ADL_LINK_BITRATE_2_7_GHZ 0x0A
+/// Indicates if link rate is 5.4Ghz
+#define ADL_LINK_BITRATE_5_4_GHZ 0x14
+
+/// Indicates if link rate is 8.1Ghz
+#define ADL_LINK_BITRATE_8_1_GHZ 0x1E
+/// Indicates default value of link rate
+#define ADL_LINK_BITRATE_DEF ADL_LINK_BITRATE_2_7_GHZ
+/// @}
+
+/// \defgroup define_colordepth_constants
+/// These defines are the color depth constants which will be used in DP & etc.
+/// @{
+#define ADL_CONNPROP_S3D_ALTERNATE_TO_FRAME_PACK            0x00000001
+/// @}
+
+
+/// \defgroup define_colordepth_constants
+/// These defines are the color depth constants which will be used in DP & etc.
+/// @{
+/// Indicates if color depth is unknown
+#define ADL_COLORDEPTH_UNKNOWN 0
+/// Indicates if color depth is 666
+#define ADL_COLORDEPTH_666 1
+/// Indicates if color depth is 888
+#define ADL_COLORDEPTH_888 2
+/// Indicates if color depth is 101010
+#define ADL_COLORDEPTH_101010 3
+/// Indicates if color depth is 121212
+#define ADL_COLORDEPTH_121212 4
+/// Indicates if color depth is 141414
+#define ADL_COLORDEPTH_141414 5
+/// Indicates if color depth is 161616
+#define ADL_COLORDEPTH_161616 6
+/// Indicates default value of color depth
+#define ADL_COLOR_DEPTH_DEF ADL_COLORDEPTH_888
+/// @}
+
+
+/// \defgroup define_emulation_status
+/// These defines are the status of emulation
+/// @{
+/// Indicates if real device is connected.
+#define ADL_EMUL_STATUS_REAL_DEVICE_CONNECTED 0x1
+/// Indicates if emulated device is presented.
+#define ADL_EMUL_STATUS_EMULATED_DEVICE_PRESENT 0x2
+/// Indicates if emulated device is used.
+#define ADL_EMUL_STATUS_EMULATED_DEVICE_USED  0x4
+/// In case when last active real/emulated device used (when persistence is enabled but no emulation enforced then persistence will use last connected/emulated device).
+#define ADL_EMUL_STATUS_LAST_ACTIVE_DEVICE_USED 0x8
+/// @}
+
+/// \defgroup define_emulation_mode
+/// These defines are the modes of emulation
+/// @{
+/// Indicates if no emulation is used
+#define ADL_EMUL_MODE_OFF 0
+/// Indicates if emulation is used when display connected
+#define ADL_EMUL_MODE_ON_CONNECTED 1
+/// Indicates if emulation is used when display dis connected
+#define ADL_EMUL_MODE_ON_DISCONNECTED 2
+/// Indicates if emulation is used always
+#define ADL_EMUL_MODE_ALWAYS 3
+/// @}
+
+/// \defgroup define_emulation_query
+/// These defines are the modes of emulation
+/// @{
+/// Indicates Data from real device
+#define ADL_QUERY_REAL_DATA 0
+/// Indicates Emulated data
+#define ADL_QUERY_EMULATED_DATA 1
+/// Indicates Data currently in use
+#define ADL_QUERY_CURRENT_DATA 2
+/// @}
+
+/// \defgroup define_persistence_state
+/// These defines are the states of persistence
+/// @{
+/// Indicates persistence is disabled
+#define ADL_EDID_PERSISTANCE_DISABLED 0
+/// Indicates persistence is enabled
+#define ADL_EDID_PERSISTANCE_ENABLED 1
+/// @}
+
+/// \defgroup define_connector_types Connector Type
+/// defines for ADLConnectorInfo.iType
+/// @{
+/// Indicates unknown Connector type
+#define ADL_CONNECTOR_TYPE_UNKNOWN                 0
+/// Indicates VGA Connector type
+#define ADL_CONNECTOR_TYPE_VGA                     1
+/// Indicates DVI-D Connector type
+#define ADL_CONNECTOR_TYPE_DVI_D                   2
+/// Indicates DVI-I Connector type
+#define ADL_CONNECTOR_TYPE_DVI_I                   3
+/// Indicates Active Dongle-NA Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_NA          4
+/// Indicates Active Dongle-JP Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_JP          5
+/// Indicates Active Dongle-NONI2C Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C      6
+/// Indicates Active Dongle-NONI2C-D Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C_D    7
+/// Indicates HDMI-Type A Connector type
+#define ADL_CONNECTOR_TYPE_HDMI_TYPE_A             8
+/// Indicates HDMI-Type B Connector type
+#define ADL_CONNECTOR_TYPE_HDMI_TYPE_B             9
+/// Indicates Display port Connector type
+#define ADL_CONNECTOR_TYPE_DISPLAYPORT             10
+/// Indicates EDP Connector type
+#define ADL_CONNECTOR_TYPE_EDP                     11
+/// Indicates MiniDP Connector type
+#define ADL_CONNECTOR_TYPE_MINI_DISPLAYPORT        12
+/// Indicates Virtual Connector type
+#define ADL_CONNECTOR_TYPE_VIRTUAL                   13
+/// Indicates USB type C Connector type
+#define ADL_CONNECTOR_TYPE_USB_TYPE_C              14
+/// @}
+
+/// \defgroup define_freesync_usecase
+/// These defines are to specify use cases in which FreeSync should be enabled
+/// They are a bit mask. To specify FreeSync for more than one use case, the input value
+/// should be set to include multiple bits set
+/// @{
+/// Indicates FreeSync is enabled for Static Screen case
+#define ADL_FREESYNC_USECASE_STATIC                 0x1
+/// Indicates FreeSync is enabled for Video use case
+#define ADL_FREESYNC_USECASE_VIDEO                  0x2
+/// Indicates FreeSync is enabled for Gaming use case
+#define ADL_FREESYNC_USECASE_GAMING                 0x4
+/// @}
+
+/// \defgroup define_freesync_caps
+/// These defines are used to retrieve FreeSync display capabilities.
+/// GPU support flag also indicates whether the display is
+/// connected to a GPU that actually supports FreeSync
+/// @{
+#define ADL_FREESYNC_CAP_SUPPORTED                      (1 << 0)
+#define ADL_FREESYNC_CAP_GPUSUPPORTED                   (1 << 1)
+#define ADL_FREESYNC_CAP_DISPLAYSUPPORTED               (1 << 2)
+#define ADL_FREESYNC_CAP_CURRENTMODESUPPORTED           (1 << 3)
+#define ADL_FREESYNC_CAP_NOCFXORCFXSUPPORTED            (1 << 4)
+#define ADL_FREESYNC_CAP_NOGENLOCKORGENLOCKSUPPORTED    (1 << 5)
+#define ADL_FREESYNC_CAP_BORDERLESSWINDOWSUPPORTED      (1 << 6)
+/// @}
+
+/// \defgroup define_freesync_labelIndex
+/// These defines are used to retrieve which FreeSync label to use
+/// @{
+#define ADL_FREESYNC_LABEL_UNSUPPORTED            0
+#define ADL_FREESYNC_LABEL_FREESYNC               1
+#define ADL_FREESYNC_LABEL_ADAPTIVE_SYNC          2
+#define ADL_FREESYNC_LABEL_VRR                    3
+#define ADL_FREESYNC_LABEL_FREESYNC_PREMIUM       4
+#define ADL_FREESYNC_LABEL_FREESYNC_PREMIUM_PRO   5
+/// @}
+
+/// Freesync Power optimization masks
+/// @{
+#define ADL_FREESYNC_POWEROPTIMIZATION_SUPPORTED_MASK		(1 << 0)
+#define ADL_FREESYNC_POWEROPTIMIZATION_ENABLED_MASK			(1 << 1)
+#define ADL_FREESYNC_POWEROPTIMIZATION_DEFAULT_VALUE_MASK	(1 << 2)
+/// @}
+
+/// \defgroup define_MST_CommandLine_execute
+/// @{
+/// Indicates the MST command line for branch message if the bit is set. Otherwise, it is display message
+#define ADL_MST_COMMANDLINE_PATH_MSG                 0x1
+/// Indicates the MST command line to send message in broadcast way it the bit is set
+#define ADL_MST_COMMANDLINE_BROADCAST                  0x2
+
+/// @}
+
+
+/// \defgroup define_Adapter_CloneTypes_Get
+/// @{
+/// Indicates there is crossGPU clone with non-AMD dispalys
+#define ADL_CROSSGPUDISPLAYCLONE_AMD_WITH_NONAMD                 0x1
+/// Indicates there is crossGPU clone
+#define ADL_CROSSGPUDISPLAYCLONE                  0x2
+
+/// @}
+
+/// \defgroup define_D3DKMT_HANDLE
+/// @{
+/// Handle can be used to create Device Handle when using CreateDevice()
+typedef unsigned int ADL_D3DKMT_HANDLE;
+/// @}
+
+
+// End Bracket for Constants and Definitions. Add new groups ABOVE this line!
+
+/// @}
+
+
+typedef enum ADL_RAS_ERROR_INJECTION_MODE
+{
+	ADL_RAS_ERROR_INJECTION_MODE_SINGLE = 1,
+	ADL_RAS_ERROR_INJECTION_MODE_MULTIPLE = 2
+}ADL_RAS_ERROR_INJECTION_MODE;
+
+
+typedef enum ADL_RAS_BLOCK_ID
+{
+	ADL_RAS_BLOCK_ID_UMC = 0,
+	ADL_RAS_BLOCK_ID_SDMA,
+	ADL_RAS_BLOCK_ID_GFX_HUB,
+	ADL_RAS_BLOCK_ID_MMHUB,
+	ADL_RAS_BLOCK_ID_ATHUB,
+	ADL_RAS_BLOCK_ID_PCIE_BIF,
+	ADL_RAS_BLOCK_ID_HDP,
+	ADL_RAS_BLOCK_ID_XGMI_WAFL,
+	ADL_RAS_BLOCK_ID_DF,
+	ADL_RAS_BLOCK_ID_SMN,
+	ADL_RAS_BLOCK_ID_SEM,
+	ADL_RAS_BLOCK_ID_MP0,
+	ADL_RAS_BLOCK_ID_MP1,
+	ADL_RAS_BLOCK_ID_FUSE
+}ADL_RAS_BLOCK_ID;
+
+typedef enum ADL_MEM_SUB_BLOCK_ID
+{
+	ADL_RAS__UMC_HBM = 0,
+	ADL_RAS__UMC_SRAM = 1
+}ADL_MEM_SUB_BLOCK_ID;
+
+typedef enum  _ADL_RAS_ERROR_TYPE
+{
+	ADL_RAS_ERROR__NONE = 0,
+	ADL_RAS_ERROR__PARITY = 1,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE = 2,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE = 3,
+	ADL_RAS_ERROR__MULTI_UNCORRECTABLE = 4,
+	ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE = 5,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE = 6,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE = 7,
+	ADL_RAS_ERROR__POISON = 8,
+	ADL_RAS_ERROR__PARITY_POISON = 9,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE_POISON = 10,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_POISON = 11,
+	ADL_RAS_ERROR__MULTI_UNCORRECTABLE_POISON = 12,
+	ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE_POISON = 13,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON = 14,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON = 15
+}ADL_RAS_ERROR_TYPE;
+
+typedef enum ADL_RAS_INJECTION_METHOD
+{
+	ADL_RAS_ERROR__UMC_METH_COHERENT = 0,
+	ADL_RAS_ERROR__UMC_METH_SINGLE_SHOT = 1,
+	ADL_RAS_ERROR__UMC_METH_PERSISTENT = 2,
+	ADL_RAS_ERROR__UMC_METH_PERSISTENT_DISABLE = 3
+}ADL_RAS_INJECTION_METHOD;
+
+// Driver event types
+typedef enum ADL_DRIVER_EVENT_TYPE
+{
+	ADL_EVENT_ID_AUTO_FEATURE_COMPLETED = 30,
+	ADL_EVENT_ID_FEATURE_AVAILABILITY = 31,
+
+} ADL_DRIVER_EVENT_TYPE;
+
+
+//UIFeature Ids
+typedef enum ADL_UIFEATURES_GROUP
+{
+	ADL_UIFEATURES_GROUP_DVR = 0,
+	ADL_UIFEATURES_GROUP_TURBOSYNC = 1,
+	ADL_UIFEATURES_GROUP_FRAMEMETRICSMONITOR = 2,
+	ADL_UIFEATURES_GROUP_FRTC = 3,
+	ADL_UIFEATURES_GROUP_XVISION = 4,
+	ADL_UIFEATURES_GROUP_BLOCKCHAIN = 5,
+	ADL_UIFEATURES_GROUP_GAMEINTELLIGENCE = 6,
+	ADL_UIFEATURES_GROUP_CHILL = 7,
+	ADL_UIFEATURES_GROUP_DELAG = 8,
+	ADL_UIFEATURES_GROUP_BOOST = 9,
+	ADL_UIFEATURES_GROUP_USU = 10,
+	ADL_UIFEATURES_GROUP_XGMI = 11,
+	ADL_UIFEATURES_GROUP_PROVSR = 12,
+    ADL_UIFEATURES_GROUP_SMA = 13,
+    ADL_UIFEATURES_GROUP_CAMERA = 14,
+    ADL_UIFEATURES_GROUP_FRTCPRO = 15
+} ADL_UIFEATURES_GROUP;
+
+
+
+/// Maximum brightness supported by Radeon LED interface
+#define ADL_RADEON_LED_MAX_BRIGHTNESS		2
+
+/// Maximum speed supported by Radeon LED interface
+#define ADL_RADEON_LED_MAX_SPEED	        4
+
+/// Maximum RGB supported by Radeon LED interface
+#define ADL_RADEON_LED_MAX_RGB	            255
+
+/// Maximum MORSE code supported string
+#define ADL_RADEON_LED_MAX_MORSE_CODE       260
+
+/// Maximum LED ROW ON GRID
+#define ADL_RADEON_LED_MAX_LED_ROW_ON_GRID      7
+
+/// Maximum LED COLUMN ON GRID
+#define ADL_RADEON_LED_MAX_LED_COLUMN_ON_GRID   24
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef enum ADL_RADEON_USB_LED_BAR_CONTROLS
+{
+   RadeonLEDBarControl_OFF = 0,
+   RadeonLEDBarControl_Static,
+   RadeonLEDBarControl_Rainbow,
+   RadeonLEDBarControl_Swirl,
+   RadeonLEDBarControl_Chase,
+   RadeonLEDBarControl_Bounce,
+   RadeonLEDBarControl_MorseCode,
+   RadeonLEDBarControl_ColorCycle,
+   RadeonLEDBarControl_Breathing,
+   RadeonLEDBarControl_CustomPattern,
+   RadeonLEDBarControl_MAX
+}ADL_RADEON_USB_LED_BAR_CONTROLS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef unsigned int RadeonLEDBARSupportedControl;
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef enum ADL_RADEON_USB_LED_CONTROL_CONFIGS
+{
+   RadeonLEDPattern_Speed = 0,
+   RadeonLEDPattern_Brightness,
+   RadeonLEDPattern_Direction,
+   RadeonLEDPattern_Color,
+   RadeonLEDPattern_MAX
+}ADL_RADEON_USB_LED_CONTROL_CONFIGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef unsigned int RadeonLEDBARSupportedConfig;
+
+//User blob feature settings
+typedef enum ADL_USER_SETTINGS
+{
+    ADL_USER_SETTINGS_ENHANCEDSYNC = 1 << 0,          //notify Enhanced Sync settings change
+    ADL_USER_SETTINGS_CHILL_PROFILE = 1 << 1,          //notify Chill settings change
+    ADL_USER_SETTINGS_DELAG_PROFILE = 1 << 2,          //notify Delag settings change
+    ADL_USER_SETTINGS_BOOST_PROFILE = 1 << 3,			//notify Boost settings change
+    ADL_USER_SETTINGS_USU_PROFILE = 1 << 4,  		//notify USU settings change
+    ADL_USER_SETTINGS_CVDC_PROFILE = 1 << 5,			//notify Color Vision Deficiency Corretion settings change
+    ADL_USER_SETTINGS_SCE_PROFILE = 1 << 6,
+    ADL_USER_SETTINGS_PROVSR = 1 << 7
+   } ADL_USER_SETTINGS;
+
+#define ADL_REG_DEVICE_FUNCTION_1            0x00000001
+#endif /* ADL_DEFINES_H_ */
+
+
diff --git a/dlls/atiadlxx/amdheaders/adl_sdk.h b/dlls/atiadlxx/amdheaders/adl_sdk.h
new file mode 100644
index 00000000000..4cdb44b5c22
--- /dev/null
+++ b/dlls/atiadlxx/amdheaders/adl_sdk.h
@@ -0,0 +1,46 @@
+//
+// Copyright (c) 2016 - 2022 Advanced Micro Devices, Inc. All rights reserved.
+//
+// MIT LICENSE:
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+/// \file adl_sdk.h
+/// \brief Contains the definition of the Memory Allocation Callback.\n <b>Included in ADL SDK</b>
+///
+/// \n\n
+/// This file contains the definition of the Memory Allocation Callback.\n
+/// It also includes definitions of the respective structures and constants.\n
+/// <b> This is the only header file to be included in a C/C++ project using ADL </b>
+
+#ifndef ADL_SDK_H_
+#define ADL_SDK_H_
+
+#include "adl_structures.h"
+
+#if defined (LINUX)
+#define __stdcall
+#endif /* (LINUX) */
+
+/// Memory Allocation Call back
+typedef void* ( __stdcall *ADL_MAIN_MALLOC_CALLBACK )( int );
+
+#define ADL_SDK_MAJOR_VERSION 17
+#define ADL_SDK_MINOR_VERSION 1
+
+#endif /* ADL_SDK_H_ */
diff --git a/dlls/atiadlxx/amdheaders/adl_structures.h b/dlls/atiadlxx/amdheaders/adl_structures.h
new file mode 100644
index 00000000000..601ad74bd83
--- /dev/null
+++ b/dlls/atiadlxx/amdheaders/adl_structures.h
@@ -0,0 +1,4289 @@
+//
+// Copyright (c) 2016 - 2022 Advanced Micro Devices, Inc. All rights reserved.
+//
+// MIT LICENSE:
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+/// \file adl_structures.h
+///\brief This file contains the structure declarations that are used by the public ADL interfaces for \ALL platforms.\n <b>Included in ADL SDK</b>
+///
+/// All data structures used in AMD Display Library (ADL) public interfaces should be defined in this header file.
+///
+
+#ifndef ADL_STRUCTURES_H_
+#define ADL_STRUCTURES_H_
+
+#include "adl_defines.h"
+#include <stdbool.h>
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the graphics adapter.
+///
+/// This structure is used to store various information about the graphics adapter.  This
+/// information can be returned to the user. Alternatively, it can be used to access various driver calls to set
+/// or fetch various settings upon the user's request.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct AdapterInfo
+{
+/// \ALL_STRUCT_MEM
+
+/// Size of the structure.
+    int iSize;
+/// The ADL index handle. One GPU may be associated with one or two index handles
+    int iAdapterIndex;
+/// The unique device ID associated with this adapter.
+    char strUDID[ADL_MAX_PATH];
+/// The BUS number associated with this adapter.
+    int iBusNumber;
+/// The driver number associated with this adapter.
+    int iDeviceNumber;
+/// The function number.
+    int iFunctionNumber;
+/// The vendor ID associated with this adapter.
+    int iVendorID;
+/// Adapter name.
+    char strAdapterName[ADL_MAX_PATH];
+/// Display name. For example, "\\\\Display0" for Windows or ":0:0" for Linux.
+    char strDisplayName[ADL_MAX_PATH];
+/// Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\.\\Display1 can be found from OS
+    int iPresent;
+
+#if defined (_WIN32) || defined (_WIN64)
+/// \WIN_STRUCT_MEM
+
+/// Exist or not; 1 is exist and 0 is not present.
+    int iExist;
+/// Driver registry path.
+    char strDriverPath[ADL_MAX_PATH];
+/// Driver registry path Ext for.
+    char strDriverPathExt[ADL_MAX_PATH];
+/// PNP string from Windows.
+    char strPNPString[ADL_MAX_PATH];
+/// It is generated from EnumDisplayDevices.
+    int iOSDisplayIndex;
+
+#endif /* (_WIN32) || (_WIN64) */
+
+#if defined (LINUX)
+/// \LNX_STRUCT_MEM
+
+/// Internal X screen number from GPUMapInfo (DEPRICATED use XScreenInfo)
+    int iXScreenNum;
+/// Internal driver index from GPUMapInfo
+    int iDrvIndex;
+/// \deprecated Internal x config file screen identifier name. Use XScreenInfo instead.
+    char strXScreenConfigName[ADL_MAX_PATH];
+
+#endif /* (LINUX) */
+} AdapterInfo, *LPAdapterInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the Linux X screen information.
+///
+/// This structure is used to store the current screen number and xorg.conf ID name assoicated with an adapter index.
+/// This structure is updated during ADL_Main_Control_Refresh or ADL_ScreenInfo_Update.
+/// Note:  This structure should be used in place of iXScreenNum and strXScreenConfigName in AdapterInfo as they will be
+/// deprecated.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+#if defined (LINUX)
+typedef struct XScreenInfo
+{
+/// Internal X screen number from GPUMapInfo.
+    int iXScreenNum;
+/// Internal x config file screen identifier name.
+    char strXScreenConfigName[ADL_MAX_PATH];
+} XScreenInfo, *LPXScreenInfo;
+#endif /* (LINUX) */
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an controller mode
+///
+/// This structure is used to store information of an controller mode
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterCaps
+{
+	/// AdapterID for this adapter
+	int iAdapterID;
+	/// Number of controllers for this adapter
+	int iNumControllers;
+	/// Number of displays for this adapter
+	int iNumDisplays;
+	/// Number of overlays for this adapter
+	int iNumOverlays;
+	/// Number of GLSyncConnectors
+	int iNumOfGLSyncConnectors;
+	/// The bit mask identifies the adapter caps
+	int iCapsMask;
+	/// The bit identifies the adapter caps \ref define_adapter_caps
+	int iCapsValue;
+}ADLAdapterCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing additional information about the ASIC memory
+///
+/// This structure is used to store additional information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfo2
+{
+	/// Memory size in bytes.
+	long long iMemorySize;
+	/// Memory type in string.
+	char strMemoryType[ADL_MAX_PATH];
+	/// Highest default performance level Memory bandwidth in Mbytes/s
+	long long iMemoryBandwidth;
+	/// HyperMemory size in bytes.
+	long long iHyperMemorySize;
+
+	/// Invisible Memory size in bytes.
+	long long iInvisibleMemorySize;
+	/// Visible Memory size in bytes.
+	long long iVisibleMemorySize;
+} ADLMemoryInfo2, *LPADLMemoryInfo2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing additional information about the ASIC memory
+///
+/// This structure is used to store additional information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfo3
+{
+    /// Memory size in bytes.
+    long long iMemorySize;
+    /// Memory type in string.
+    char strMemoryType[ADL_MAX_PATH];
+    /// Highest default performance level Memory bandwidth in Mbytes/s
+    long long iMemoryBandwidth;
+    /// HyperMemory size in bytes.
+    long long iHyperMemorySize;
+
+    /// Invisible Memory size in bytes.
+    long long iInvisibleMemorySize;
+    /// Visible Memory size in bytes.
+    long long iVisibleMemorySize;
+    /// Vram vendor ID
+    long long iVramVendorRevId;
+} ADLMemoryInfo3, *LPADLMemoryInfo3;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing additional information about the ASIC memory
+///
+/// This structure is used to store additional information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfoX4
+{
+    /// Memory size in bytes.
+    long long iMemorySize;
+    /// Memory type in string.
+    char strMemoryType[ADL_MAX_PATH];
+    /// Highest default performance level Memory bandwidth in Mbytes/s
+    long long iMemoryBandwidth;
+    /// HyperMemory size in bytes.
+    long long iHyperMemorySize;
+
+    /// Invisible Memory size in bytes.
+    long long iInvisibleMemorySize;
+    /// Visible Memory size in bytes.
+    long long iVisibleMemorySize;
+    /// Vram vendor ID
+    long long iVramVendorRevId;
+    /// Memory Bandiwidth that is calculated and finalized on the driver side, grab and go.
+    long long iMemoryBandwidthX2;
+    /// Memory Bit Rate that is calculated and finalized on the driver side, grab and go.
+    long long iMemoryBitRateX2;
+
+} ADLMemoryInfoX4, *LPADLMemoryInfoX4;
+
+///////////////////////////////////////////////////////////////////////////
+// ADLvRamVendor Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLvRamVendors
+{
+    ADLvRamVendor_Unsupported = 0x0,
+    ADLvRamVendor_SAMSUNG,
+    ADLvRamVendor_INFINEON,
+    ADLvRamVendor_ELPIDA,
+    ADLvRamVendor_ETRON,
+    ADLvRamVendor_NANYA,
+    ADLvRamVendor_HYNIX,
+    ADLvRamVendor_MOSEL,
+    ADLvRamVendor_WINBOND,
+    ADLvRamVendor_ESMT,
+    ADLvRamVendor_MICRON = 0xF,
+    ADLvRamVendor_Undefined
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about components of ASIC GCN architecture
+///
+///  Elements of GCN info are compute units, number of Tex (Texture filtering units)  , number of ROPs (render back-ends).
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLGcnInfo
+{
+	int CuCount; //Number of compute units on the ASIC.
+	int TexCount; //Number of texture mapping units.
+	int RopCount; //Number of Render backend Units.
+	int ASICFamilyId; //Such SI, VI. See /inc/asic_reg/atiid.h for family ids
+	int ASICRevisionId; //Such as Ellesmere, Fiji.   For example - VI family revision ids are stored in /inc/asic_reg/vi_id.h
+}ADLGcnInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related virtual segment config information.
+///
+/// This structure is used to store information related virtual segment config
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLVirtualSegmentSettingsOutput
+{
+	int                      virtualSegmentSupported;   // 1 - subsequent values are valid
+	int                      virtualSegmentDefault;     //virtual segment default, 1: enable, 0: disable
+	int                      virtualSegmentCurrent;     //virtual segment current, 1: enable, 0: disable
+	int                      iMinSizeInMB;              //minimum value
+	int                      iMaxSizeInMB;              //maximum value
+	int                      icurrentSizeInMB;          //last configured otherwise same as factory default
+	int                      idefaultSizeInMB;          //factory default
+	int                      iMask;                     //fileds for extension in the future
+	int                      iValue;                    //fileds for extension in the future
+} ADLVirtualSegmentSettingsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the Chipset.
+///
+/// This structure is used to store various information about the Chipset.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLChipSetInfo
+{
+	int iBusType; 		///< Bus type.
+	int iBusSpeedType;	///Maximum Bus Speed of the current platform
+	int iMaxPCIELaneWidth; 	///< Number of PCIE lanes.
+	int iCurrentPCIELaneWidth;  ///< Current PCIE Lane Width
+	int iSupportedAGPSpeeds;    ///< Bit mask or AGP transfer speed.
+	int iCurrentAGPSpeed;       ///< Current AGP speed
+} ADLChipSetInfo, *LPADLChipSetInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the ASIC memory.
+///
+/// This structure is used to store various information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfo
+{
+/// Memory size in bytes.
+    long long iMemorySize;
+/// Memory type in string.
+    char strMemoryType[ADL_MAX_PATH];
+/// Memory bandwidth in Mbytes/s.
+    long long iMemoryBandwidth;
+} ADLMemoryInfo, *LPADLMemoryInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about memory required by type
+///
+/// This structure is returned by ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration
+/// will return the Memory used.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryRequired
+{
+    long long iMemoryReq;        /// Memory in bytes required
+    int iType;                    /// Type of Memory \ref define_adl_validmemoryrequiredfields
+    int iDisplayFeatureValue;   /// Display features \ref define_adl_visiblememoryfeatures that are using this type of memory
+} ADLMemoryRequired, *LPADLMemoryRequired;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the features associated with a display
+///
+/// This structure is a parameter to ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration
+/// will return the Memory used.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryDisplayFeatures
+{
+    int iDisplayIndex;            /// ADL Display index
+    int iDisplayFeatureValue;    /// features that the display is using \ref define_adl_visiblememoryfeatures
+} ADLMemoryDisplayFeatures, *LPADLMemoryDisplayFeatures;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing DDC information.
+///
+/// This structure is used to store various DDC information that can be returned to the user.
+/// Note that all fields of type int are actually defined as unsigned int types within the driver.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDDCInfo
+{
+/// Size of the structure
+    int  ulSize;
+/// Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC information fields will be used.
+    int  ulSupportsDDC;
+/// Returns the manufacturer ID of the display device. Should be zeroed if this information is not available.
+    int  ulManufacturerID;
+/// Returns the product ID of the display device. Should be zeroed if this information is not available.
+    int  ulProductID;
+/// Returns the name of the display device. Should be zeroed if this information is not available.
+    char cDisplayName[ADL_MAX_DISPLAY_NAME];
+/// Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxHResolution;
+/// Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxVResolution;
+/// Returns the maximum supported refresh rate. Should be zeroed if this information is not available.
+    int  ulMaxRefresh;
+/// Returns the display device preferred timing mode's horizontal resolution.
+    int  ulPTMCx;
+/// Returns the display device preferred timing mode's vertical resolution.
+    int  ulPTMCy;
+/// Returns the display device preferred timing mode's refresh rate.
+    int  ulPTMRefreshRate;
+/// Return EDID flags.
+    int  ulDDCInfoFlag;
+} ADLDDCInfo, *LPADLDDCInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing DDC information.
+///
+/// This structure is used to store various DDC information that can be returned to the user.
+/// Note that all fields of type int are actually defined as unsigned int types within the driver.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDDCInfo2
+{
+/// Size of the structure
+    int  ulSize;
+/// Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC
+/// information fields will be used.
+    int  ulSupportsDDC;
+/// Returns the manufacturer ID of the display device. Should be zeroed if this information is not available.
+    int  ulManufacturerID;
+/// Returns the product ID of the display device. Should be zeroed if this information is not available.
+    int  ulProductID;
+/// Returns the name of the display device. Should be zeroed if this information is not available.
+    char cDisplayName[ADL_MAX_DISPLAY_NAME];
+/// Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxHResolution;
+/// Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxVResolution;
+/// Returns the maximum supported refresh rate. Should be zeroed if this information is not available.
+    int  ulMaxRefresh;
+/// Returns the display device preferred timing mode's horizontal resolution.
+    int  ulPTMCx;
+/// Returns the display device preferred timing mode's vertical resolution.
+    int  ulPTMCy;
+/// Returns the display device preferred timing mode's refresh rate.
+    int  ulPTMRefreshRate;
+/// Return EDID flags.
+    int  ulDDCInfoFlag;
+/// Returns 1 if the display supported packed pixel, 0 otherwise
+    int bPackedPixelSupported;
+/// Returns the Pixel formats the display supports \ref define_ddcinfo_pixelformats
+    int iPanelPixelFormat;
+/// Return EDID serial ID.
+    int  ulSerialID;
+/// Return minimum monitor luminance data
+    int ulMinLuminanceData;
+/// Return average monitor luminance data
+    int ulAvgLuminanceData;
+/// Return maximum monitor luminance data
+    int ulMaxLuminanceData;
+
+/// Bit vector of supported transfer functions \ref define_source_content_TF
+    int iSupportedTransferFunction;
+
+/// Bit vector of supported color spaces \ref define_source_content_CS
+    int iSupportedColorSpace;
+
+/// Display Red Chromaticity X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityRedX;
+/// Display Red Chromaticity Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityRedY;
+/// Display Green Chromaticity X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityGreenX;
+/// Display Green Chromaticity Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityGreenY;
+/// Display Blue Chromaticity X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityBlueX;
+/// Display Blue Chromaticity Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityBlueY;
+/// Display White Point X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityWhitePointX;
+/// Display White Point Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityWhitePointY;
+/// Display diffuse screen reflectance 0-1 (100%) in units of 0.01
+    int iDiffuseScreenReflectance;
+/// Display specular screen reflectance 0-1 (100%) in units of 0.01
+    int iSpecularScreenReflectance;
+/// Bit vector of supported color spaces \ref define_HDR_support
+    int iSupportedHDR;
+/// Bit vector for freesync flags
+    int iFreesyncFlags;
+
+/// Return minimum monitor luminance without dimming data
+    int ulMinLuminanceNoDimmingData;
+
+    int ulMaxBacklightMaxLuminanceData;
+    int ulMinBacklightMaxLuminanceData;
+    int ulMaxBacklightMinLuminanceData;
+    int ulMinBacklightMinLuminanceData;
+
+    // Reserved for future use
+    int iReserved[4];
+} ADLDDCInfo2, *LPADLDDCInfo2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information controller Gamma settings.
+///
+/// This structure is used to store the red, green and blue color channel information for the.
+/// controller gamma setting. This information is returned by ADL, and it can also be used to
+/// set the controller gamma setting.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGamma
+{
+/// Red color channel gamma value.
+    float fRed;
+/// Green color channel gamma value.
+    float fGreen;
+/// Blue color channel gamma value.
+    float fBlue;
+} ADLGamma, *LPADLGamma;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about component video custom modes.
+///
+/// This structure is used to store the component video custom mode.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLCustomMode
+{
+/// Custom mode flags.  They are returned by the ADL driver.
+    int iFlags;
+/// Custom mode width.
+    int iModeWidth;
+/// Custom mode height.
+    int iModeHeight;
+/// Custom mode base width.
+    int iBaseModeWidth;
+/// Custom mode base height.
+    int iBaseModeHeight;
+/// Custom mode refresh rate.
+    int iRefreshRate;
+} ADLCustomMode, *LPADLCustomMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing Clock information for OD5 calls.
+///
+/// This structure is used to retrieve clock information for OD5 calls.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGetClocksOUT
+{
+    long ulHighCoreClock;
+    long ulHighMemoryClock;
+    long ulHighVddc;
+    long ulCoreMin;
+    long ulCoreMax;
+    long ulMemoryMin;
+    long ulMemoryMax;
+    long ulActivityPercent;
+    long ulCurrentCoreClock;
+    long ulCurrentMemoryClock;
+    long ulReserved;
+} ADLGetClocksOUT;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing HDTV information for display calls.
+///
+/// This structure is used to retrieve HDTV information information for display calls.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayConfig
+{
+/// Size of the structure
+  long ulSize;
+/// HDTV connector type.
+  long ulConnectorType;
+/// HDTV capabilities.
+  long ulDeviceData;
+/// Overridden HDTV capabilities.
+  long ulOverridedDeviceData;
+/// Reserved field
+  long ulReserved;
+} ADLDisplayConfig;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display device.
+///
+/// This structure is used to store display device information
+/// such as display index, type, name, connection status, mapped adapter and controller indexes,
+/// whether or not multiple VPUs are supported, local display connections or not (through Lasso), etc.
+/// This information can be returned to the user. Alternatively, it can be used to access various driver calls to set
+/// or fetch various display device related settings upon the user's request.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayID
+{
+/// The logical display index belonging to this adapter.
+    int iDisplayLogicalIndex;
+
+///\brief The physical display index.
+/// For example, display index 2 from adapter 2 can be used by current adapter 1.\n
+/// So current adapter may enumerate this adapter as logical display 7 but the physical display
+/// index is still 2.
+    int iDisplayPhysicalIndex;
+
+/// The persistent logical adapter index for the display.
+    int iDisplayLogicalAdapterIndex;
+
+///\brief The persistent physical adapter index for the display.
+/// It can be the current adapter or a non-local adapter. \n
+/// If this adapter index is different than the current adapter,
+/// the Display Non Local flag is set inside DisplayInfoValue.
+    int iDisplayPhysicalAdapterIndex;
+} ADLDisplayID, *LPADLDisplayID;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display device.
+///
+/// This structure is used to store various information about the display device.  This
+/// information can be returned to the user, or used to access various driver calls to set
+/// or fetch various display-device-related settings upon the user's request
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayInfo
+{
+/// The DisplayID structure
+    ADLDisplayID displayID;
+
+///\deprecated The controller index to which the display is mapped.\n Will not be used in the future\n
+    int  iDisplayControllerIndex;
+
+/// The display's EDID name.
+    char strDisplayName[ADL_MAX_PATH];
+
+/// The display's manufacturer name.
+    char strDisplayManufacturerName[ADL_MAX_PATH];
+
+/// The Display type. For example: CRT, TV, CV, DFP.
+    int  iDisplayType;
+
+/// The display output type. For example: HDMI, SVIDEO, COMPONMNET VIDEO.
+    int  iDisplayOutputType;
+
+/// The connector type for the device.
+    int  iDisplayConnector;
+
+///\brief The bit mask identifies the number of bits ADLDisplayInfo is currently using. \n
+/// It will be the sum all the bit definitions in ADL_DISPLAY_DISPLAYINFO_xxx.
+    int  iDisplayInfoMask;
+
+/// The bit mask identifies the display status. \ref define_displayinfomask
+    int  iDisplayInfoValue;
+} ADLDisplayInfo, *LPADLDisplayInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display port MST device.
+///
+/// This structure is used to store various MST information about the display port device.  This
+/// information can be returned to the user, or used to access various driver calls to
+/// fetch various display-device-related settings upon the user's request
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayDPMSTInfo
+{
+    /// The ADLDisplayID structure
+    ADLDisplayID displayID;
+
+    /// total bandwidth available on the DP connector
+    int    iTotalAvailableBandwidthInMpbs;
+    /// bandwidth allocated to this display
+    int    iAllocatedBandwidthInMbps;
+
+    // info from DAL DpMstSinkInfo
+    /// string identifier for the display
+    char    strGlobalUniqueIdentifier[ADL_MAX_PATH];
+
+    /// The link count of relative address, rad[0] upto rad[linkCount] are valid
+    int        radLinkCount;
+    /// The physical connector ID, used to identify the physical DP port
+    int        iPhysicalConnectorID;
+
+    /// Relative address, address scheme starts from source side
+    char    rad[ADL_MAX_RAD_LINK_COUNT];
+} ADLDisplayDPMSTInfo, *LPADLDisplayDPMSTInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the display mode definition used per controller.
+///
+/// This structure is used to store the display mode definition used per controller.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayMode
+{
+/// Vertical resolution (in pixels).
+   int  iPelsHeight;
+/// Horizontal resolution (in pixels).
+   int  iPelsWidth;
+/// Color depth.
+   int  iBitsPerPel;
+/// Refresh rate.
+   int  iDisplayFrequency;
+} ADLDisplayMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing detailed timing parameters.
+///
+/// This structure is used to store the detailed timing parameters.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDetailedTiming
+{
+/// Size of the structure.
+     int   iSize;
+/// Timing flags. \ref define_detailed_timing_flags
+     short sTimingFlags;
+/// Total width (columns).
+     short sHTotal;
+/// Displayed width.
+     short sHDisplay;
+/// Horizontal sync signal offset.
+     short sHSyncStart;
+/// Horizontal sync signal width.
+     short sHSyncWidth;
+/// Total height (rows).
+     short sVTotal;
+/// Displayed height.
+     short sVDisplay;
+/// Vertical sync signal offset.
+     short sVSyncStart;
+/// Vertical sync signal width.
+     short sVSyncWidth;
+/// Pixel clock value.
+     short sPixelClock;
+/// Overscan right.
+     short sHOverscanRight;
+/// Overscan left.
+     short sHOverscanLeft;
+/// Overscan bottom.
+     short sVOverscanBottom;
+/// Overscan top.
+     short sVOverscanTop;
+     short sOverscan8B;
+     short sOverscanGR;
+} ADLDetailedTiming;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing display mode information.
+///
+/// This structure is used to store the display mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayModeInfo
+{
+/// Timing standard of the current mode. \ref define_modetiming_standard
+  int  iTimingStandard;
+/// Applicable timing standards for the current mode.
+  int  iPossibleStandard;
+/// Refresh rate factor.
+  int  iRefreshRate;
+/// Num of pixels in a row.
+  int  iPelsWidth;
+/// Num of pixels in a column.
+  int  iPelsHeight;
+/// Detailed timing parameters.
+  ADLDetailedTiming  sDetailedTiming;
+} ADLDisplayModeInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display property.
+///
+/// This structure is used to store the display property for the current adapter.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayProperty
+{
+/// Must be set to sizeof the structure
+  int iSize;
+/// Must be set to \ref ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE or \ref ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING
+  int iPropertyType;
+/// Get or Set \ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER or \ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN or \ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO or \ref ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE
+  int iExpansionMode;
+/// Display Property supported? 1: Supported, 0: Not supported
+  int iSupport;
+/// Display Property current value
+  int iCurrent;
+/// Display Property Default value
+  int iDefault;
+} ADLDisplayProperty;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Clock.
+///
+/// This structure is used to store the clock information for the current adapter
+/// such as core clock and memory clock info.
+///\nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLClockInfo
+{
+/// Core clock in 10 KHz.
+    int iCoreClock;
+/// Memory clock in 10 KHz.
+    int iMemoryClock;
+} ADLClockInfo, *LPADLClockInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about I2C.
+///
+/// This structure is used to store the I2C information for the current adapter.
+/// This structure is used by the ADL_Display_WriteAndReadI2C() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLI2C
+{
+/// Size of the structure
+    int iSize;
+/// Numerical value representing hardware I2C.
+    int iLine;
+/// The 7-bit I2C slave device address, shifted one bit to the left.
+    int iAddress;
+/// The offset of the data from the address.
+    int iOffset;
+/// Read from or write to slave device. \ref ADL_DL_I2C_ACTIONREAD or \ref ADL_DL_I2C_ACTIONWRITE or \ref ADL_DL_I2C_ACTIONREAD_REPEATEDSTART
+    int iAction;
+/// I2C clock speed in KHz.
+    int iSpeed;
+/// A numerical value representing the number of bytes to be sent or received on the I2C bus.
+    int iDataSize;
+/// Address of the characters which are to be sent or received on the I2C bus.
+    char *pcData;
+} ADLI2C;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about EDID data.
+///
+/// This structure is used to store the information about EDID data for the adapter.
+/// This structure is used by the ADL_Display_EdidData_Get() and ADL_Display_EdidData_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayEDIDData
+{
+/// Size of the structure
+  int iSize;
+/// Set to 0
+  int iFlag;
+  /// Size of cEDIDData. Set by ADL_Display_EdidData_Get() upon return
+  int iEDIDSize;
+/// 0, 1 or 2. If set to 3 or above an error ADL_ERR_INVALID_PARAM is generated
+  int iBlockIndex;
+/// EDID data
+  char cEDIDData[ADL_MAX_EDIDDATA_SIZE];
+/// Reserved
+  int iReserved[4];
+}ADLDisplayEDIDData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about input of controller overlay adjustment.
+///
+/// This structure is used to store the information about input of controller overlay adjustment for the adapter.
+/// This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get, ADL_Display_ControllerOverlayAdjustmentData_Get, and
+/// ADL_Display_ControllerOverlayAdjustmentData_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLControllerOverlayInput
+{
+/// Should be set to the sizeof the structure
+  int  iSize;
+///\ref ADL_DL_CONTROLLER_OVERLAY_ALPHA or \ref ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX
+  int  iOverlayAdjust;
+/// Data.
+  int  iValue;
+/// Should be 0.
+  int  iReserved;
+} ADLControllerOverlayInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about overlay adjustment.
+///
+/// This structure is used to store the information about overlay adjustment for the adapter.
+/// This structure is used by the ADLControllerOverlayInfo() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdjustmentinfo
+{
+/// Default value
+  int iDefault;
+/// Minimum value
+  int iMin;
+/// Maximum Value
+  int iMax;
+/// Step value
+  int iStep;
+} ADLAdjustmentinfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about controller overlay information.
+///
+/// This structure is used to store information about controller overlay info for the adapter.
+/// This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLControllerOverlayInfo
+{
+/// Should be set to the sizeof the structure
+  int                    iSize;
+/// Data.
+  ADLAdjustmentinfo        sOverlayInfo;
+/// Should be 0.
+  int                    iReserved[3];
+} ADLControllerOverlayInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync module information.
+///
+/// This structure is used to retrieve GL-Sync module information for
+/// Workstation Framelock/Genlock.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGLSyncModuleID
+{
+/// Unique GL-Sync module ID.
+    int        iModuleID;
+/// GL-Sync GPU port index (to be passed into ADLGLSyncGenlockConfig.lSignalSource and ADLGlSyncPortControl.lSignalSource).
+    int        iGlSyncGPUPort;
+/// GL-Sync module firmware version of Boot Sector.
+    int        iFWBootSectorVersion;
+/// GL-Sync module firmware version of User Sector.
+    int        iFWUserSectorVersion;
+} ADLGLSyncModuleID , *LPADLGLSyncModuleID;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync ports capabilities.
+///
+/// This structure is used to retrieve hardware capabilities for the ports of the GL-Sync module
+/// for Workstation Framelock/Genlock (such as port type and number of associated LEDs).
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGLSyncPortCaps
+{
+/// Port type. Bitfield of ADL_GLSYNC_PORTTYPE_*  \ref define_glsync
+    int        iPortType;
+/// Number of LEDs associated for this port.
+    int        iNumOfLEDs;
+}ADLGLSyncPortCaps, *LPADLGLSyncPortCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync Genlock settings.
+///
+/// This structure is used to get and set genlock settings for the GPU ports of the GL-Sync module
+/// for Workstation Framelock/Genlock.\n
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGLSyncGenlockConfig
+{
+/// Specifies what fields in this structure are valid \ref define_glsync
+    int        iValidMask;
+/// Delay (ms) generating a sync signal.
+    int        iSyncDelay;
+/// Vector of framelock control bits. Bitfield of ADL_GLSYNC_FRAMELOCKCNTL_* \ref define_glsync
+    int        iFramelockCntlVector;
+/// Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_* \ref define_glsync
+    int        iSignalSource;
+/// Use sampled sync signal. A value of 0 specifies no sampling.
+    int        iSampleRate;
+/// For interlaced sync signals, the value can be ADL_GLSYNC_SYNCFIELD_1 or *_BOTH \ref define_glsync
+    int        iSyncField;
+/// The signal edge that should trigger synchronization. ADL_GLSYNC_TRIGGEREDGE_* \ref define_glsync
+    int        iTriggerEdge;
+/// Scan rate multiplier applied to the sync signal. ADL_GLSYNC_SCANRATECOEFF_* \ref define_glsync
+    int        iScanRateCoeff;
+}ADLGLSyncGenlockConfig, *LPADLGLSyncGenlockConfig;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync port information.
+///
+/// This structure is used to get status of the GL-Sync ports (BNC or RJ45s)
+/// for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncPortInfo
+{
+/// Type of GL-Sync port (ADL_GLSYNC_PORT_*).
+    int        iPortType;
+/// The number of LEDs for this port. It's also filled within ADLGLSyncPortCaps.
+    int        iNumOfLEDs;
+/// Port state ADL_GLSYNC_PORTSTATE_*  \ref define_glsync
+    int        iPortState;
+/// Scanned frequency for this port (vertical refresh rate in milliHz; 60000 means 60 Hz).
+    int        iFrequency;
+/// Used for ADL_GLSYNC_PORT_BNC. It is ADL_GLSYNC_SIGNALTYPE_*   \ref define_glsync
+    int        iSignalType;
+/// Used for ADL_GLSYNC_PORT_RJ45PORT*. It is GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*.  \ref define_glsync
+    int        iSignalSource;
+} ADLGlSyncPortInfo, *LPADLGlSyncPortInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync port control settings.
+///
+/// This structure is used to configure the GL-Sync ports (RJ45s only)
+/// for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncPortControl
+{
+/// Port to control ADL_GLSYNC_PORT_RJ45PORT1 or ADL_GLSYNC_PORT_RJ45PORT2   \ref define_glsync
+    int        iPortType;
+/// Port control data ADL_GLSYNC_PORTCNTL_*   \ref define_glsync
+    int        iControlVector;
+/// Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*   \ref define_glsync
+    int        iSignalSource;
+} ADLGlSyncPortControl;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync mode of a display.
+///
+/// This structure is used to get and set GL-Sync mode settings for a display connected to
+/// an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncMode
+{
+/// Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \ref define_glsync
+    int        iControlVector;
+/// Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \ref define_glsync
+    int        iStatusVector;
+/// Index of GL-Sync connector used to genlock the display/controller.
+    int        iGLSyncConnectorIndex;
+} ADLGlSyncMode, *LPADLGlSyncMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync mode of a display.
+///
+/// This structure is used to get and set GL-Sync mode settings for a display connected to
+/// an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncMode2
+{
+/// Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \ref define_glsync
+    int        iControlVector;
+/// Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \ref define_glsync
+    int        iStatusVector;
+/// Index of GL-Sync connector used to genlock the display/controller.
+    int        iGLSyncConnectorIndex;
+/// Index of the display to which this GLSync applies to.
+    int        iDisplayIndex;
+} ADLGlSyncMode2, *LPADLGlSyncMode2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the packet info of a display.
+///
+/// This structure is used to get and set the packet information of a display.
+/// This structure is used by ADLDisplayDataPacket.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct  ADLInfoPacket
+{
+    char hb0;
+    char hb1;
+    char hb2;
+/// sb0~sb27
+    char sb[28];
+}ADLInfoPacket;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the AVI packet info of a display.
+///
+/// This structure is used to get and set AVI the packet info of a display.
+/// This structure is used by ADLDisplayDataPacket.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAVIInfoPacket  //Valid user defined data/
+{
+/// byte 3, bit 7
+   char bPB3_ITC;
+/// byte 5, bit [7:4].
+   char bPB5;
+}ADLAVIInfoPacket;
+
+// Overdrive clock setting structure definition.
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Overdrive clock setting.
+///
+/// This structure is used to get the Overdrive clock setting.
+/// This structure is used by ADLAdapterODClockInfo.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODClockSetting
+{
+/// Deafult clock
+    int iDefaultClock;
+/// Current clock
+    int iCurrentClock;
+/// Maximum clcok
+    int iMaxClock;
+/// Minimum clock
+    int iMinClock;
+/// Requested clcock
+    int iRequestedClock;
+/// Step
+    int iStepClock;
+} ADLODClockSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Overdrive clock information.
+///
+/// This structure is used to get the Overdrive clock information.
+/// This structure is used by the ADL_Display_ODClockInfo_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterODClockInfo
+{
+/// Size of the structure
+    int iSize;
+/// Flag \ref define_clockinfo_flags
+    int iFlags;
+/// Memory Clock
+    ADLODClockSetting sMemoryClock;
+/// Engine Clock
+    ADLODClockSetting sEngineClock;
+} ADLAdapterODClockInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Overdrive clock configuration.
+///
+/// This structure is used to set the Overdrive clock configuration.
+/// This structure is used by the ADL_Display_ODClockConfig_Set() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterODClockConfig
+{
+/// Size of the structure
+  int iSize;
+/// Flag \ref define_clockinfo_flags
+  int iFlags;
+/// Memory Clock
+  int iMemoryClock;
+/// Engine Clock
+  int iEngineClock;
+} ADLAdapterODClockConfig;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about current power management related activity.
+///
+/// This structure is used to store information about current power management related activity.
+/// This structure (Overdrive 5 interfaces) is used by the ADL_PM_CurrentActivity_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMActivity
+{
+/// Must be set to the size of the structure
+    int iSize;
+/// Current engine clock.
+    int iEngineClock;
+/// Current memory clock.
+    int iMemoryClock;
+/// Current core voltage.
+    int iVddc;
+/// GPU utilization.
+    int iActivityPercent;
+/// Performance level index.
+    int iCurrentPerformanceLevel;
+/// Current PCIE bus speed.
+    int iCurrentBusSpeed;
+/// Number of PCIE bus lanes.
+    int iCurrentBusLanes;
+/// Maximum number of PCIE bus lanes.
+    int iMaximumBusLanes;
+/// Reserved for future purposes.
+    int iReserved;
+} ADLPMActivity;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about thermal controller.
+///
+/// This structure is used to store information about thermal controller.
+/// This structure is used by ADL_PM_ThermalDevices_Enum.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLThermalControllerInfo
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Possible valies: \ref ADL_DL_THERMAL_DOMAIN_OTHER or \ref ADL_DL_THERMAL_DOMAIN_GPU.
+  int iThermalDomain;
+///    GPU 0, 1, etc.
+  int iDomainIndex;
+/// Possible valies: \ref ADL_DL_THERMAL_FLAG_INTERRUPT or \ref ADL_DL_THERMAL_FLAG_FANCONTROL
+  int iFlags;
+} ADLThermalControllerInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about thermal controller temperature.
+///
+/// This structure is used to store information about thermal controller temperature.
+/// This structure is used by the ADL_PM_Temperature_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLTemperature
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Temperature in millidegrees Celsius.
+  int iTemperature;
+} ADLTemperature;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about thermal controller fan speed.
+///
+/// This structure is used to store information about thermal controller fan speed.
+/// This structure is used by the ADL_PM_FanSpeedInfo_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFanSpeedInfo
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// \ref define_fanctrl
+  int iFlags;
+/// Minimum possible fan speed value in percents.
+  int iMinPercent;
+/// Maximum possible fan speed value in percents.
+  int iMaxPercent;
+/// Minimum possible fan speed value in RPM.
+  int iMinRPM;
+/// Maximum possible fan speed value in RPM.
+  int iMaxRPM;
+} ADLFanSpeedInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about fan speed reported by thermal controller.
+///
+/// This structure is used to store information about fan speed reported by thermal controller.
+/// This structure is used by the ADL_Overdrive5_FanSpeed_Get() and ADL_Overdrive5_FanSpeed_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFanSpeedValue
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Possible valies: \ref ADL_DL_FANCTRL_SPEED_TYPE_PERCENT or \ref ADL_DL_FANCTRL_SPEED_TYPE_RPM
+  int iSpeedType;
+/// Fan speed value
+  int iFanSpeed;
+/// The only flag for now is: \ref ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED
+  int iFlags;
+} ADLFanSpeedValue;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the range of Overdrive parameter.
+///
+/// This structure is used to store information about the range of Overdrive parameter.
+/// This structure is used by ADLODParameters.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODParameterRange
+{
+/// Minimum parameter value.
+  int iMin;
+/// Maximum parameter value.
+  int iMax;
+/// Parameter step value.
+  int iStep;
+} ADLODParameterRange;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive parameters.
+///
+/// This structure is used to store information about Overdrive parameters.
+/// This structure is used by the ADL_Overdrive5_ODParameters_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODParameters
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Number of standard performance states.
+  int iNumberOfPerformanceLevels;
+/// Indicates whether the GPU is capable to measure its activity.
+  int iActivityReportingSupported;
+/// Indicates whether the GPU supports discrete performance levels or performance range.
+  int iDiscretePerformanceLevels;
+/// Reserved for future use.
+  int iReserved;
+/// Engine clock range.
+  ADLODParameterRange sEngineClock;
+/// Memory clock range.
+  ADLODParameterRange sMemoryClock;
+/// Core voltage range.
+  ADLODParameterRange sVddc;
+} ADLODParameters;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive level.
+///
+/// This structure is used to store information about Overdrive level.
+/// This structure is used by ADLODPerformanceLevels.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODPerformanceLevel
+{
+/// Engine clock.
+  int iEngineClock;
+/// Memory clock.
+  int iMemoryClock;
+/// Core voltage.
+  int iVddc;
+} ADLODPerformanceLevel;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive performance levels.
+///
+/// This structure is used to store information about Overdrive performance levels.
+/// This structure is used by the ADL_Overdrive5_ODPerformanceLevels_Get() and ADL_Overdrive5_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODPerformanceLevels
+{
+/// Must be set to sizeof( \ref ADLODPerformanceLevels ) + sizeof( \ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)
+  int iSize;
+  int iReserved;
+/// Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements.
+  ADLODPerformanceLevel aLevels [1];
+} ADLODPerformanceLevels;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the proper CrossfireX chains combinations.
+///
+/// This structure is used to store information about the CrossfireX chains combination for a particular adapter.
+/// This structure is used by the ADL_Adapter_Crossfire_Caps(), ADL_Adapter_Crossfire_Get(), and ADL_Adapter_Crossfire_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLCrossfireComb
+{
+/// Number of adapters in this combination.
+  int iNumLinkAdapter;
+/// A list of ADL indexes of the linked adapters in this combination.
+  int iAdaptLink[3];
+} ADLCrossfireComb;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing CrossfireX state and error information.
+///
+/// This structure is used to store state and error information about a particular adapter CrossfireX combination.
+/// This structure is used by the ADL_Adapter_Crossfire_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLCrossfireInfo
+{
+/// Current error code of this CrossfireX combination.
+  int iErrorCode;
+/// Current \ref define_crossfirestate
+  int iState;
+/// If CrossfireX is supported by this combination. The value is either \ref ADL_TRUE or \ref ADL_FALSE.
+  int iSupported;
+} ADLCrossfireInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the BIOS.
+///
+/// This structure is used to store various information about the Chipset.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLBiosInfo
+{
+    char strPartNumber[ADL_MAX_PATH];    ///< Part number.
+    char strVersion[ADL_MAX_PATH];        ///< Version number.
+    char strDate[ADL_MAX_PATH];        ///< BIOS date in yyyy/mm/dd hh:mm format.
+} ADLBiosInfo, *LPADLBiosInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about adapter location.
+///
+/// This structure is used to store information about adapter location.
+/// This structure is used by ADLMVPUStatus.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterLocation
+{
+/// PCI Bus number : 8 bits
+    int iBus;
+/// Device number : 5 bits
+    int iDevice;
+/// Function number : 3 bits
+    int iFunction;
+} ADLAdapterLocation,ADLBdf;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing version information
+///
+/// This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLVersionsInfo
+{
+    /// Driver Release (Packaging) Version (e.g. 8.71-100128n-094835E-ATI)
+    char strDriverVer[ADL_MAX_PATH];
+    /// Catalyst Version(e.g. "10.1").
+    char strCatalystVersion[ADL_MAX_PATH];
+    /// Web link to an XML file with information about the latest AMD drivers and locations (e.g. "http://www.amd.com/us/driverxml" )
+    char strCatalystWebLink[ADL_MAX_PATH];
+} ADLVersionsInfo, *LPADLVersionsInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing version information
+///
+/// This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLVersionsInfoX2
+{
+    /// Driver Release (Packaging) Version (e.g. "16.20.1035-160621a-303814C")
+    char strDriverVer[ADL_MAX_PATH];
+    /// Catalyst Version(e.g. "15.8").
+    char strCatalystVersion[ADL_MAX_PATH];
+    /// Crimson Version(e.g. "16.6.2").
+    char strCrimsonVersion[ADL_MAX_PATH];
+    /// Web link to an XML file with information about the latest AMD drivers and locations (e.g. "http://support.amd.com/drivers/xml/driver_09_us.xml" )
+    char strCatalystWebLink[ADL_MAX_PATH];
+} ADLVersionsInfoX2, *LPADLVersionsInfoX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about MultiVPU capabilities.
+///
+/// This structure is used to store information about MultiVPU capabilities.
+/// This structure is used by the ADL_Display_MVPUCaps_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMVPUCaps
+{
+/// Must be set to sizeof( ADLMVPUCaps ).
+  int iSize;
+/// Number of adapters.
+  int iAdapterCount;
+/// Bits set for all possible MVPU masters. \ref MVPU_ADAPTER_0 .. \ref MVPU_ADAPTER_3
+  int iPossibleMVPUMasters;
+/// Bits set for all possible MVPU slaves. \ref MVPU_ADAPTER_0 .. \ref MVPU_ADAPTER_3
+  int iPossibleMVPUSlaves;
+/// Registry path for each adapter.
+  char cAdapterPath[ADL_DL_MAX_MVPU_ADAPTERS][ADL_DL_MAX_REGISTRY_PATH];
+} ADLMVPUCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about MultiVPU status.
+///
+/// This structure is used to store information about MultiVPU status.
+/// Ths structure is used by the ADL_Display_MVPUStatus_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMVPUStatus
+{
+/// Must be set to sizeof( ADLMVPUStatus ).
+  int iSize;
+/// Number of active adapters.
+  int iActiveAdapterCount;
+/// MVPU status.
+  int iStatus;
+/// PCI Bus/Device/Function for each active adapter participating in MVPU.
+  ADLAdapterLocation aAdapterLocation[ADL_DL_MAX_MVPU_ADAPTERS];
+} ADLMVPUStatus;
+
+// Displays Manager structures
+
+///////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the activatable source.
+///
+/// This structure is used to store activatable source information
+/// This information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLActivatableSource
+{
+    /// The Persistent logical Adapter Index.
+    int iAdapterIndex;
+    /// The number of Activatable Sources.
+    int iNumActivatableSources;
+    /// The bit mask identifies the number of bits ActivatableSourceValue is using. (Not currnetly used)
+    int iActivatableSourceMask;
+    /// The bit mask identifies the status.  (Not currnetly used)
+    int iActivatableSourceValue;
+} ADLActivatableSource, *LPADLActivatableSource;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display mode.
+///
+/// This structure is used to store the display mode for the current adapter
+/// such as X, Y positions, screen resolutions, orientation,
+/// color depth, refresh rate, progressive or interlace mode, etc.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLMode
+{
+/// Adapter index.
+    int iAdapterIndex;
+/// Display IDs.
+    ADLDisplayID displayID;
+/// Screen position X coordinate.
+    int iXPos;
+/// Screen position Y coordinate.
+    int iYPos;
+/// Screen resolution Width.
+    int iXRes;
+/// Screen resolution Height.
+    int iYRes;
+/// Screen Color Depth. E.g., 16, 32.
+    int iColourDepth;
+/// Screen refresh rate. Could be fractional E.g. 59.97
+    float fRefreshRate;
+/// Screen orientation. E.g., 0, 90, 180, 270.
+    int iOrientation;
+/// Vista mode flag indicating Progressive or Interlaced mode.
+    int iModeFlag;
+/// The bit mask identifying the number of bits this Mode is currently using. It is the sum of all the bit definitions defined in \ref define_displaymode
+    int iModeMask;
+/// The bit mask identifying the display status. The detailed definition is in  \ref define_displaymode
+    int iModeValue;
+} ADLMode, *LPADLMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display target information.
+///
+/// This structure is used to store the display target information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayTarget
+{
+    /// The Display ID.
+    ADLDisplayID displayID;
+
+    /// The display map index identify this manner and the desktop surface.
+    int iDisplayMapIndex;
+
+    /// The bit mask identifies the number of bits DisplayTarget is currently using. It is the sum of all the bit definitions defined in \ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED.
+    int  iDisplayTargetMask;
+
+    /// The bit mask identifies the display status. The detailed definition is in \ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED.
+    int  iDisplayTargetValue;
+} ADLDisplayTarget, *LPADLDisplayTarget;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS bezel Mode information.
+///
+/// This structure is used to store the display SLS bezel Mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct tagADLBezelTransientMode
+{
+    /// Adapter Index
+    int iAdapterIndex;
+
+    /// SLS Map Index
+    int iSLSMapIndex;
+
+    /// The mode index
+    int iSLSModeIndex;
+
+    /// The mode
+    ADLMode displayMode;
+
+    /// The number of bezel offsets belongs to this map
+    int  iNumBezelOffset;
+
+    /// The first bezel offset array index in the native mode array
+    int  iFirstBezelOffsetArrayIndex;
+
+    /// The bit mask identifies the bits this structure is currently using. It will be the total OR of all the bit definitions.
+    int  iSLSBezelTransientModeMask;
+
+    /// The bit mask identifies the display status. The detail definition is defined below.
+    int  iSLSBezelTransientModeValue;
+} ADLBezelTransientMode, *LPADLBezelTransientMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the adapter display manner.
+///
+/// This structure is used to store adapter display manner information
+/// This information can be returned to the user. Alternatively, it can be used to access various driver calls to
+/// fetch various display device related display manner settings upon the user's request.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterDisplayCap
+{
+    /// The Persistent logical Adapter Index.
+    int iAdapterIndex;
+    /// The bit mask identifies the number of bits AdapterDisplayCap is currently using. Sum all the bits defined in ADL_ADAPTER_DISPLAYCAP_XXX
+    int  iAdapterDisplayCapMask;
+    /// The bit mask identifies the status. Refer to ADL_ADAPTER_DISPLAYCAP_XXX
+    int  iAdapterDisplayCapValue;
+} ADLAdapterDisplayCap, *LPADLAdapterDisplayCap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about display mapping.
+///
+/// This structure is used to store the display mapping data such as display manner.
+/// For displays with horizontal or vertical stretch manner,
+/// this structure also stores the display order, display row, and column data.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayMap
+{
+/// The current display map index. It is the OS desktop index. For example, if the OS index 1 is showing clone mode, the display map will be 1.
+    int iDisplayMapIndex;
+
+/// The Display Mode for the current map
+    ADLMode displayMode;
+
+/// The number of display targets belongs to this map\n
+    int iNumDisplayTarget;
+
+/// The first target array index in the Target array\n
+    int iFirstDisplayTargetArrayIndex;
+
+/// The bit mask identifies the number of bits DisplayMap is currently using. It is the sum of all the bit definitions defined in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx.
+     int  iDisplayMapMask;
+
+///The bit mask identifies the display status. The detailed definition is in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx.
+    int  iDisplayMapValue;
+} ADLDisplayMap, *LPADLDisplayMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the display device possible map for one GPU
+///
+/// This structure is used to store the display device possible map
+/// This information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleMap
+{
+    /// The current PossibleMap index. Each PossibleMap is assigned an index
+    int iIndex;
+    /// The adapter index identifying the GPU for which to validate these Maps & Targets
+    int iAdapterIndex;
+    /// Number of display Maps for this GPU to be validated
+    int iNumDisplayMap;
+    /// The display Maps list to validate
+    ADLDisplayMap* displayMap;
+    /// the number of display Targets for these display Maps
+    int iNumDisplayTarget;
+    /// The display Targets list for these display Maps to be validated.
+    ADLDisplayTarget* displayTarget;
+} ADLPossibleMap, *LPADLPossibleMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display possible mapping.
+///
+/// This structure is used to store the display possible mapping's controller index for the current display.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleMapping
+{
+    int iDisplayIndex;                ///< The display index. Each display is assigned an index.
+    int iDisplayControllerIndex;    ///< The controller index to which display is mapped.
+    int iDisplayMannerSupported;    ///< The supported display manner.
+} ADLPossibleMapping, *LPADLPossibleMapping;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the validated display device possible map result.
+///
+/// This structure is used to store the validated display device possible map result
+/// This information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleMapResult
+{
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iIndex;
+    // The bit mask identifies the number of bits   PossibleMapResult is currently using. It will be the sum all the bit definitions defined in ADL_DISPLAY_POSSIBLEMAPRESULT_VALID.
+    int iPossibleMapResultMask;
+    /// The bit mask identifies the possible map result. The detail definition is defined in ADL_DISPLAY_POSSIBLEMAPRESULT_XXX.
+    int iPossibleMapResultValue;
+} ADLPossibleMapResult, *LPADLPossibleMapResult;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Grid information.
+///
+/// This structure is used to store the display SLS Grid information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSGrid
+{
+/// The Adapter index.
+    int iAdapterIndex;
+
+/// The grid index.
+    int  iSLSGridIndex;
+
+/// The grid row.
+    int  iSLSGridRow;
+
+/// The grid column.
+    int  iSLSGridColumn;
+
+/// The grid bit mask identifies the number of bits DisplayMap is currently using. Sum of all bits defined in ADL_DISPLAY_SLSGRID_ORIENTATION_XXX
+    int  iSLSGridMask;
+
+/// The grid bit value identifies the display status. Refer to ADL_DISPLAY_SLSGRID_ORIENTATION_XXX
+    int  iSLSGridValue;
+} ADLSLSGrid, *LPADLSLSGrid;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Map information.
+///
+/// This structure is used to store the display SLS Map information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct    ADLSLSMap
+{
+    /// The Adapter Index
+    int iAdapterIndex;
+
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// Indicate the current grid
+    ADLSLSGrid grid;
+
+    /// OS surface index
+    int  iSurfaceMapIndex;
+
+     ///  Screen orientation. E.g., 0, 90, 180, 270
+     int iOrientation;
+
+    /// The number of display targets belongs to this map
+    int  iNumSLSTarget;
+
+    /// The first target array index in the Target array
+    int  iFirstSLSTargetArrayIndex;
+
+    /// The number of native modes belongs to this map
+    int  iNumNativeMode;
+
+    /// The first native mode array index in the native mode array
+    int  iFirstNativeModeArrayIndex;
+
+    /// The number of bezel modes belongs to this map
+    int  iNumBezelMode;
+
+    /// The first bezel mode array index in the native mode array
+    int  iFirstBezelModeArrayIndex;
+
+    /// The number of bezel offsets belongs to this map
+    int  iNumBezelOffset;
+
+    /// The first bezel offset array index in the
+    int  iFirstBezelOffsetArrayIndex;
+
+    /// The bit mask identifies the number of bits DisplayMap is currently using. Sum all the bit definitions defined in ADL_DISPLAY_SLSMAP_XXX.
+    int  iSLSMapMask;
+
+    /// The bit mask identifies the display map status. Refer to ADL_DISPLAY_SLSMAP_XXX
+    int  iSLSMapValue;
+} ADLSLSMap, *LPADLSLSMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Offset information.
+///
+/// This structure is used to store the display SLS Offset information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSOffset
+{
+    /// The Adapter Index
+    int iAdapterIndex;
+
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// The Display ID.
+    ADLDisplayID displayID;
+
+    /// SLS Bezel Mode Index
+    int iBezelModeIndex;
+
+    /// SLS Bezel Offset X
+    int iBezelOffsetX;
+
+    /// SLS Bezel Offset Y
+    int iBezelOffsetY;
+
+    /// SLS Display Width
+    int iDisplayWidth;
+
+    /// SLS Display Height
+    int iDisplayHeight;
+
+    /// The bit mask identifies the number of bits Offset is currently using.
+    int iBezelOffsetMask;
+
+    /// The bit mask identifies the display status.
+    int  iBezelffsetValue;
+} ADLSLSOffset, *LPADLSLSOffset;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Mode information.
+///
+/// This structure is used to store the display SLS Mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSMode
+{
+    /// The Adapter Index
+    int iAdapterIndex;
+
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// The mode index
+    int iSLSModeIndex;
+
+    /// The mode for this map.
+    ADLMode displayMode;
+
+    /// The bit mask identifies the number of bits Mode is currently using.
+    int iSLSNativeModeMask;
+
+    /// The bit mask identifies the display status.
+    int iSLSNativeModeValue;
+} ADLSLSMode, *LPADLSLSMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display Possible SLS Map information.
+///
+/// This structure is used to store the display Possible SLS Map information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleSLSMap
+{
+    /// The current display map index. It is the OS Desktop index.
+    /// For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// Number of display map to be validated.
+    int iNumSLSMap;
+
+    /// The display map list for validation
+    ADLSLSMap* lpSLSMap;
+
+    /// the number of display map config to be validated.
+    int iNumSLSTarget;
+
+    /// The display target list for validation.
+    ADLDisplayTarget* lpDisplayTarget;
+} ADLPossibleSLSMap, *LPADLPossibleSLSMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the SLS targets.
+///
+/// This structure is used to store the SLS targets information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSTarget
+{
+    /// the logic adapter index
+    int iAdapterIndex;
+
+    /// The SLS map index
+    int iSLSMapIndex;
+
+    /// The target ID
+    ADLDisplayTarget displayTarget;
+
+    /// Target postion X in SLS grid
+    int iSLSGridPositionX;
+
+    /// Target postion Y in SLS grid
+    int iSLSGridPositionY;
+
+    /// The view size width, height and rotation angle per SLS Target
+    ADLMode viewSize;
+
+    /// The bit mask identifies the bits in iSLSTargetValue are currently used
+    int iSLSTargetMask;
+
+    /// The bit mask identifies status info. It is for function extension purpose
+    int iSLSTargetValue;
+} ADLSLSTarget, *LPADLSLSTarget;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the Adapter offset stepping size.
+///
+/// This structure is used to store the Adapter offset stepping size information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLBezelOffsetSteppingSize
+{
+    /// the logic adapter index
+    int iAdapterIndex;
+
+    /// The SLS map index
+    int iSLSMapIndex;
+
+    /// Bezel X stepping size offset
+    int iBezelOffsetSteppingSizeX;
+
+    /// Bezel Y stepping size offset
+    int iBezelOffsetSteppingSizeY;
+
+    /// Identifies the bits this structure is currently using. It will be the total OR of all the bit definitions.
+    int iBezelOffsetSteppingSizeMask;
+
+    /// Bit mask identifies the display status.
+    int iBezelOffsetSteppingSizeValue;
+} ADLBezelOffsetSteppingSize, *LPADLBezelOffsetSteppingSize;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the overlap offset info for all the displays for each SLS mode.
+///
+/// This structure is used to store the no. of overlapped modes for each SLS Mode once user finishes the configuration from Overlap Widget
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSOverlappedMode
+{
+    /// the SLS mode for which the overlap is configured
+    ADLMode SLSMode;
+    /// the number of target displays in SLS.
+    int iNumSLSTarget;
+    /// the first target array index in the target array
+    int iFirstTargetArrayIndex;
+}ADLSLSTargetOverlap, *LPADLSLSTargetOverlap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver supported PowerExpress Config Caps
+///
+/// This structure is used to store the driver supported PowerExpress Config Caps
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPXConfigCaps
+{
+    /// The Persistent logical Adapter Index.
+    int iAdapterIndex;
+
+    /// The bit mask identifies the number of bits PowerExpress Config Caps is currently using. It is the sum of all the bit definitions defined in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants.
+    int  iPXConfigCapMask;
+
+    /// The bit mask identifies the PowerExpress Config Caps value. The detailed definition is in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants.
+    int  iPXConfigCapValue;
+} ADLPXConfigCaps, *LPADLPXConfigCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////
+///\brief Enum containing PX or HG type
+///
+/// This enum is used to get PX or hG type
+///
+/// \nosubgrouping
+//////////////////////////////////////////////////////////////////////////////////////////
+typedef enum ADLPxType
+{
+	//Not AMD related PX/HG or not PX or HG at all
+	ADL_PX_NONE = 0,
+	//A+A PX
+	ADL_SWITCHABLE_AMDAMD = 1,
+	// A+A HG
+	ADL_HG_AMDAMD = 2,
+	//A+I PX
+	ADL_SWITCHABLE_AMDOTHER = 3,
+	//A+I HG
+	ADL_HG_AMDOTHER = 4,
+}ADLPxType;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of an application
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationData
+{
+    /// Path Name
+    char strPathName[ADL_MAX_PATH];
+    /// File Name
+    char strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
+    /// Creation timestamp
+    char strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
+    /// Version
+    char strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
+}ADLApplicationData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of an application
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationDataX2
+{
+    /// Path Name
+    wchar_t strPathName[ADL_MAX_PATH];
+    /// File Name
+    wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
+    /// Creation timestamp
+    wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
+    /// Version
+    wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
+}ADLApplicationDataX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of an application including process id
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationDataX3
+{
+    /// Path Name
+    wchar_t strPathName[ADL_MAX_PATH];
+    /// File Name
+    wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
+    /// Creation timestamp
+    wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
+    /// Version
+    wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
+    //Application Process id
+    unsigned int iProcessId;
+}ADLApplicationDataX3;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information of a property of an application profile
+///
+/// This structure is used to store property information of an application profile
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct PropertyRecord
+{
+    /// Property Name
+    char strName [ADL_APP_PROFILE_PROPERTY_LENGTH];
+    /// Property Type
+    ADLProfilePropertyType eType;
+    /// Data Size in bytes
+    int iDataSize;
+    /// Property Value, can be any data type
+    unsigned char uData[1];
+}PropertyRecord;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application profile
+///
+/// This structure is used to store information of an application profile
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationProfile
+{
+    /// Number of properties
+    int iCount;
+    /// Buffer to store all property records
+    PropertyRecord record[1];
+}ADLApplicationProfile;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an OD5 Power Control feature
+///
+/// This structure is used to store information of an Power Control feature
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPowerControlInfo
+{
+/// Minimum value.
+int iMinValue;
+/// Maximum value.
+int iMaxValue;
+/// The minimum change in between minValue and maxValue.
+int iStepValue;
+ } ADLPowerControlInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an controller mode
+///
+/// This structure is used to store information of an controller mode
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLControllerMode
+{
+    /// This falg indicates actions that will be applied by set viewport
+    /// The value can be a combination of ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION,
+    /// ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK and ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE
+    int iModifiers;
+
+    /// Horizontal view starting position
+    int iViewPositionCx;
+
+    /// Vertical view starting position
+    int iViewPositionCy;
+
+    /// Horizontal left panlock position
+    int iViewPanLockLeft;
+
+    /// Horizontal right panlock position
+    int iViewPanLockRight;
+
+    /// Vertical top panlock position
+    int iViewPanLockTop;
+
+    /// Vertical bottom panlock position
+    int iViewPanLockBottom;
+
+    /// View resolution in pixels (width)
+    int iViewResolutionCx;
+
+    /// View resolution in pixels (hight)
+    int iViewResolutionCy;
+}ADLControllerMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about a display
+///
+/// This structure is used to store information about a display
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayIdentifier
+{
+    /// ADL display index
+    long ulDisplayIndex;
+
+    /// manufacturer ID of the display
+    long ulManufacturerId;
+
+    /// product ID of the display
+    long ulProductId;
+
+    /// serial number of the display
+    long ulSerialNo;
+} ADLDisplayIdentifier;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 clock range
+///
+/// This structure is used to store information about Overdrive 6 clock range
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6ParameterRange
+{
+    /// The starting value of the clock range
+    int     iMin;
+    /// The ending value of the clock range
+    int     iMax;
+    /// The minimum increment between clock values
+    int     iStep;
+} ADLOD6ParameterRange;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 capabilities
+///
+/// This structure is used to store information about Overdrive 6 capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6Capabilities
+{
+    /// Contains a bitmap of the OD6 capability flags.  Possible values: \ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,
+    /// \ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR
+    int     iCapabilities;
+    /// Contains a bitmap indicating the power states
+    /// supported by OD6.  Currently only the performance state
+    /// is supported. Possible Values: \ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE
+    int     iSupportedStates;
+    /// Number of levels. OD6 will always use 2 levels, which describe
+    /// the minimum to maximum clock ranges.
+    /// The 1st level indicates the minimum clocks, and the 2nd level
+    /// indicates the maximum clocks.
+    int     iNumberOfPerformanceLevels;
+    /// Contains the hard limits of the sclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLOD6ParameterRange     sEngineClockRange;
+    /// Contains the hard limits of the mclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLOD6ParameterRange     sMemoryClockRange;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6Capabilities;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 clock values.
+///
+/// This structure is used to store information about Overdrive 6 clock values.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6PerformanceLevel
+{
+    /// Engine (core) clock.
+    int iEngineClock;
+    /// Memory clock.
+    int iMemoryClock;
+} ADLOD6PerformanceLevel;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 clocks.
+///
+/// This structure is used to store information about Overdrive 6 clocks.  This is a
+/// variable-sized structure.  iNumberOfPerformanceLevels indicate how many elements
+/// are contained in the aLevels array.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6StateInfo
+{
+    /// Number of levels.  OD6 uses clock ranges instead of discrete performance levels.
+    /// iNumberOfPerformanceLevels is always 2.  The 1st level indicates the minimum clocks
+    /// in the range.  The 2nd level indicates the maximum clocks in the range.
+    int     iNumberOfPerformanceLevels;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+
+    /// Variable-sized array of levels.
+    /// The number of elements in the array is specified by iNumberofPerformanceLevels.
+    ADLOD6PerformanceLevel aLevels [1];
+} ADLOD6StateInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about current Overdrive 6 performance status.
+///
+/// This structure is used to store information about current Overdrive 6 performance status.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6CurrentStatus
+{
+    /// Current engine clock in 10 KHz.
+    int     iEngineClock;
+    /// Current memory clock in 10 KHz.
+    int     iMemoryClock;
+    /// Current GPU activity in percent.  This
+    /// indicates how "busy" the GPU is.
+    int     iActivityPercent;
+    /// Not used.  Reserved for future use.
+    int     iCurrentPerformanceLevel;
+    /// Current PCI-E bus speed
+    int     iCurrentBusSpeed;
+    /// Current PCI-E bus # of lanes
+    int     iCurrentBusLanes;
+    /// Maximum possible PCI-E bus # of lanes
+    int     iMaximumBusLanes;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6CurrentStatus;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 thermal contoller capabilities
+///
+/// This structure is used to store information about Overdrive 6 thermal controller capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6ThermalControllerCaps
+{
+    /// Contains a bitmap of thermal controller capability flags. Possible values: \ref ADL_OD6_TCCAPS_THERMAL_CONTROLLER, \ref ADL_OD6_TCCAPS_FANSPEED_CONTROL,
+    /// \ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ, \ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE, \ref ADL_OD6_TCCAPS_FANSPEED_RPM_READ, \ref ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE
+    int     iCapabilities;
+    /// Minimum fan speed expressed as a percentage
+    int     iFanMinPercent;
+    /// Maximum fan speed expressed as a percentage
+    int     iFanMaxPercent;
+    /// Minimum fan speed expressed in revolutions-per-minute
+    int     iFanMinRPM;
+    /// Maximum fan speed expressed in revolutions-per-minute
+    int     iFanMaxRPM;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6ThermalControllerCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 fan speed information
+///
+/// This structure is used to store information about Overdrive 6 fan speed information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6FanSpeedInfo
+{
+    /// Contains a bitmap of the valid fan speed type flags.  Possible values: \ref ADL_OD6_FANSPEED_TYPE_PERCENT, \ref ADL_OD6_FANSPEED_TYPE_RPM, \ref ADL_OD6_FANSPEED_USER_DEFINED
+    int     iSpeedType;
+    /// Contains current fan speed in percent (if valid flag exists in iSpeedType)
+    int     iFanSpeedPercent;
+    /// Contains current fan speed in RPM (if valid flag exists in iSpeedType)
+    int        iFanSpeedRPM;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6FanSpeedInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 fan speed value
+///
+/// This structure is used to store information about Overdrive 6 fan speed value
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6FanSpeedValue
+{
+    /// Indicates the units of the fan speed.  Possible values: \ref ADL_OD6_FANSPEED_TYPE_PERCENT, \ref ADL_OD6_FANSPEED_TYPE_RPM
+    int     iSpeedType;
+    /// Fan speed value (units as indicated above)
+    int     iFanSpeed;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6FanSpeedValue;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 PowerControl settings.
+///
+/// This structure is used to store information about Overdrive 6 PowerControl settings.
+/// PowerControl is the feature which allows the performance characteristics of the GPU
+/// to be adjusted by changing the PowerTune power limits.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6PowerControlInfo
+{
+    /// The minimum PowerControl adjustment value
+    int     iMinValue;
+    /// The maximum PowerControl adjustment value
+    int     iMaxValue;
+    /// The minimum difference between PowerControl adjustment values
+    int     iStepValue;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6PowerControlInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 PowerControl settings.
+///
+/// This structure is used to store information about Overdrive 6 PowerControl settings.
+/// PowerControl is the feature which allows the performance characteristics of the GPU
+/// to be adjusted by changing the PowerTune power limits.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6VoltageControlInfo
+{
+    /// The minimum VoltageControl adjustment value
+    int     iMinValue;
+    /// The maximum VoltageControl adjustment value
+    int     iMaxValue;
+    /// The minimum difference between VoltageControl adjustment values
+    int     iStepValue;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6VoltageControlInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing ECC statistics namely SEC counts and DED counts
+/// Single error count - count of errors that can be corrected
+/// Doubt Error Detect -  count of errors that cannot be corrected
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLECCData
+{
+    // Single error count - count of errors that can be corrected
+    int iSec;
+    // Double error detect - count of errors that cannot be corrected
+    int iDed;
+} ADLECCData;
+
+/// \brief Handle to ADL client context.
+///
+///  ADL clients obtain context handle from initial call to \ref ADL2_Main_Control_Create.
+///  Clients have to pass the handle to each subsequent ADL call and finally destroy
+///  the context with call to \ref ADL2_Main_Control_Destroy
+/// \nosubgrouping
+typedef void *ADL_CONTEXT_HANDLE;
+
+/// \brief Handle to ADL Frame Monitor Token.
+///
+///  Frame Monitor clients obtain handle from initial call to \ref ADL2_Adapter_FrameMetrics_FrameDuration_Enable
+///  Clients have to pass the handle to each subsequent ADL call to \ref ADL2_Adapter_FrameMetrics_FrameDuration_Get
+///  and finally destroy the token with call to \ref ADL2_Adapter_FrameMetrics_FrameDuration_Disable
+/// \nosubgrouping
+typedef void *ADL_FRAME_DURATION_HANDLE;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the display mode definition used per controller.
+///
+/// This structure is used to store the display mode definition used per controller.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayModeX2
+{
+/// Horizontal resolution (in pixels).
+   int  iWidth;
+/// Vertical resolution (in lines).
+   int  iHeight;
+/// Interlaced/Progressive. The value will be set for Interlaced as ADL_DL_TIMINGFLAG_INTERLACED. If not set it is progressive. Refer define_detailed_timing_flags.
+   int  iScanType;
+/// Refresh rate.
+   int  iRefreshRate;
+/// Timing Standard. Refer define_modetiming_standard.
+   int  iTimingStandard;
+} ADLDisplayModeX2;
+
+typedef enum ADLAppProcessState
+{
+	APP_PROC_INVALID = 0,          // Invalid Application
+	APP_PROC_PREMPTION = 1,          // The Application is being set up for Process Creation
+	APP_PROC_CREATION = 2,          // The Application's Main Process is created by the OS
+	APP_PROC_READ = 3,          // The Application's Data is ready to be read
+	APP_PROC_WAIT = 4,          // The Application is waiting for Timeout or Notification to Resume
+	APP_PROC_RUNNING = 5,          // The Application is running
+	APP_PROC_TERMINATE = 6           // The Application is about to terminate
+}ADLAppProcessState;
+
+typedef enum ADLAppInterceptionListType
+{
+	ADL_INVALID_FORMAT = 0,
+	ADL_IMAGEFILEFORMAT = 1,
+	ADL_ENVVAR = 2
+}ADLAppInterceptionListType;
+
+typedef struct ADLAppInterceptionInfo
+{
+	wchar_t                     AppName[ADL_MAX_PATH]; // the file name of the application or env var
+	unsigned int                ProcessId;
+	ADLAppInterceptionListType  AppFormat;
+	ADLAppProcessState          AppState;
+} ADLAppInterceptionInfo;
+
+typedef enum ADL_AP_DATABASE // same as _SHARED_AP_DATABASE in "inc/shared/shared_escape.h"
+{
+	ADL_AP_DATABASE__SYSTEM,
+	ADL_AP_DATABASE__USER,
+	ADL_AP_DATABASE__OEM
+} ADL_AP_DATABASE;
+
+typedef struct ADLAppInterceptionInfoX2
+{
+	wchar_t                     AppName[ADL_MAX_PATH]; // the file name of the application or env var
+	unsigned int                ProcessId;
+	unsigned int                WaitForResumeNeeded;
+	wchar_t                     CommandLine[ADL_MAX_PATH]; // The command line on app start/stop event
+	ADLAppInterceptionListType  AppFormat;
+	ADLAppProcessState          AppState;
+} ADLAppInterceptionInfoX2;
+
+typedef struct ADLAppInterceptionInfoX3
+{
+    wchar_t                     AppName[ADL_MAX_PATH]; // the file name of the application or env var
+    unsigned int                ProcessId;
+    unsigned int                WaitForResumeNeeded;
+    unsigned int                RayTracingStatus; // returns the Ray Tracing status if it is enabled atleast once in session.
+    wchar_t                     CommandLine[ADL_MAX_PATH]; // The command line on app start/stop event
+    ADLAppInterceptionListType  AppFormat;
+    ADLAppProcessState          AppState;
+} ADLAppInterceptionInfoX3;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information info for a property record in a profile
+///
+/// This structure is used to store info for a property record in a profile
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPropertyRecordCreate
+{
+	/// Name of the property
+	wchar_t * strPropertyName;
+	/// Data type of the property
+	ADLProfilePropertyType eType;
+	// Value of the property
+	wchar_t * strPropertyValue;
+} ADLPropertyRecordCreate;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information info for an application record
+///
+/// This structure is used to store info for an application record
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationRecord
+{
+    /// Title of the application
+    wchar_t * strTitle;
+    /// File path of the application
+    wchar_t * strPathName;
+    /// File name of the application
+    wchar_t * strFileName;
+    /// File versin the application
+    wchar_t * strVersion;
+    /// Nostes on the application
+    wchar_t * strNotes;
+    /// Driver area which the application uses
+    wchar_t * strArea;
+    /// Name of profile assigned to the application
+    wchar_t * strProfileName;
+    // Source where this application record come from
+    ADL_AP_DATABASE recordSource;
+} ADLApplicationRecord;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 extension capabilities
+///
+/// This structure is used to store information about Overdrive 6 extension capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6CapabilitiesEx
+{
+    /// Contains a bitmap of the OD6 extension capability flags.  Possible values: \ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,
+    /// \ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR,
+    /// \ref ADL_OD6_CAPABILITY_POWER_CONTROL, \ref ADL_OD6_CAPABILITY_VOLTAGE_CONTROL, \ref ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT,
+    //// \ref ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK
+    int iCapabilities;
+    /// The Power states that support clock and power customization.  Only performance state is currently supported.
+    /// Possible Values: \ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE
+    int iSupportedStates;
+    /// Returns the hard limits of the SCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages.
+    ADLOD6ParameterRange sEngineClockPercent;
+    /// Returns the hard limits of the MCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages.
+    ADLOD6ParameterRange sMemoryClockPercent;
+    /// Returns the hard limits of the Power Limit adjustment range.  Power limit should not be adjusted outside this range.  The values are specified as +/- percentages.
+    ADLOD6ParameterRange sPowerControlPercent;
+    /// Reserved for future expansion of the structure.
+    int iExtValue;
+    /// Reserved for future expansion of the structure.
+    int iExtMask;
+} ADLOD6CapabilitiesEx;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 extension state information
+///
+/// This structure is used to store information about Overdrive 6 extension state information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6StateEx
+{
+    /// The current engine clock adjustment value, specified as a +/- percent.
+    int iEngineClockPercent;
+    /// The current memory clock adjustment value, specified as a +/- percent.
+    int iMemoryClockPercent;
+    /// The current power control adjustment value, specified as a +/- percent.
+    int iPowerControlPercent;
+    /// Reserved for future expansion of the structure.
+    int iExtValue;
+    /// Reserved for future expansion of the structure.
+    int iExtMask;
+} ADLOD6StateEx;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 extension recommended maximum clock adjustment values
+///
+/// This structure is used to store information about Overdrive 6 extension recommended maximum clock adjustment values
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6MaxClockAdjust
+{
+    /// The recommended maximum engine clock adjustment in percent, for the specified power limit value.
+    int iEngineClockMax;
+    /// The recommended maximum memory clock adjustment in percent, for the specified power limit value.
+    /// Currently the memory is independent of the Power Limit setting, so iMemoryClockMax will always return the maximum
+    /// possible adjustment value.  This field is here for future enhancement in case we add a dependency between Memory Clock
+    /// adjustment and Power Limit setting.
+    int iMemoryClockMax;
+    /// Reserved for future expansion of the structure.
+    int iExtValue;
+    /// Reserved for future expansion of the structure.
+    int iExtMask;
+} ADLOD6MaxClockAdjust;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Connector information
+///
+/// this structure is used to get the connector information like length, positions & etc.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectorInfo
+{
+    ///index of the connector(0-based)
+    int iConnectorIndex;
+    ///used for disply identification/ordering
+    int iConnectorId;
+    ///index of the slot, 0-based index.
+    int iSlotIndex;
+    ///Type of the connector. \ref define_connector_types
+    int iType;
+    ///Position of the connector(in millimeters), from the right side of the slot.
+    int iOffset;
+    ///Length of the connector(in millimeters).
+    int iLength;
+} ADLConnectorInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the slot information
+///
+/// this structure is used to get the slot information like length of the slot, no of connectors on the slot & etc.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLBracketSlotInfo
+{
+    ///index of the slot, 0-based index.
+    int iSlotIndex;
+    ///length of the slot(in millimeters).
+    int iLength;
+    ///width of the slot(in millimeters).
+    int iWidth;
+} ADLBracketSlotInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing MST branch information
+///
+/// this structure is used to store the MST branch information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMSTRad
+{
+    ///depth of the link.
+    int iLinkNumber;
+    /// Relative address, address scheme starts from source side
+    char rad[ADL_MAX_RAD_LINK_COUNT];
+} ADLMSTRad;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing port information
+///
+/// this structure is used to get the display or MST branch information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDevicePort
+{
+    ///index of the connector.
+    int iConnectorIndex;
+    ///Relative MST address. If MST RAD contains 0 it means DP or Root of the MST topology. For non DP connectors MST RAD is ignored.
+    ADLMSTRad aMSTRad;
+} ADLDevicePort;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing supported connection types and properties
+///
+/// this structure is used to get the supported connection types and supported properties of given connector
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSupportedConnections
+{
+    ///Bit vector of supported connections. Bitmask is defined in constants section. \ref define_connection_types
+    int iSupportedConnections;
+    ///Array of bitvectors. Each bit vector represents supported properties for one connection type. Index of this array is connection type (bit number in mask).
+    int iSupportedProperties[ADL_MAX_CONNECTION_TYPES];
+} ADLSupportedConnections;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing connection state of the connector
+///
+/// this structure is used to get the current Emulation status and mode of the given connector
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectionState
+{
+    ///The value is bit vector. Each bit represents status. See masks constants for details. \ref define_emulation_status
+    int iEmulationStatus;
+    ///It contains information about current emulation mode. See constants for details. \ref define_emulation_mode
+    int iEmulationMode;
+    ///If connection is active it will contain display id, otherwise CWDDEDI_INVALID_DISPLAY_INDEX
+    int iDisplayIndex;
+} ADLConnectionState;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing connection properties information
+///
+/// this structure is used to retrieve the properties of connection type
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectionProperties
+{
+    //Bit vector. Represents actual properties. Supported properties for specific connection type. \ref define_connection_properties
+    int iValidProperties;
+    //Bitrate(in MHz). Could be used for MST branch, DP or DP active dongle. \ref define_linkrate_constants
+    int iBitrate;
+    //Number of lanes in DP connection. \ref define_lanecount_constants
+    int iNumberOfLanes;
+    //Color depth(in bits). \ref define_colordepth_constants
+    int iColorDepth;
+    //3D capabilities. It could be used for some dongles. For instance: alternate framepack. Value of this property is bit vector.
+    int iStereo3DCaps;
+    ///Output Bandwidth. Could be used for MST branch, DP or DP Active dongle. \ref define_linkrate_constants
+    int iOutputBandwidth;
+} ADLConnectionProperties;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing connection information
+///
+/// this structure is used to retrieve the data from driver which includes
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectionData
+{
+    ///Connection type. based on the connection type either iNumberofPorts or IDataSize,EDIDdata is valid, \ref define_connection_types
+    int iConnectionType;
+    ///Specifies the connection properties.
+    ADLConnectionProperties aConnectionProperties;
+    ///Number of ports
+    int iNumberofPorts;
+    ///Number of Active Connections
+    int iActiveConnections;
+    ///actual size of EDID data block size.
+    int iDataSize;
+    ///EDID Data
+    char EdidData[ADL_MAX_DISPLAY_EDID_DATA_SIZE];
+} ADLConnectionData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an controller mode including Number of Connectors
+///
+/// This structure is used to store information of an controller mode
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterCapsX2
+{
+    /// AdapterID for this adapter
+    int iAdapterID;
+    /// Number of controllers for this adapter
+    int iNumControllers;
+    /// Number of displays for this adapter
+    int iNumDisplays;
+    /// Number of overlays for this adapter
+    int iNumOverlays;
+    /// Number of GLSyncConnectors
+    int iNumOfGLSyncConnectors;
+    /// The bit mask identifies the adapter caps
+    int iCapsMask;
+    /// The bit identifies the adapter caps \ref define_adapter_caps
+    int iCapsValue;
+    /// Number of Connectors for this adapter
+    int iNumConnectors;
+}ADLAdapterCapsX2;
+
+typedef enum ADL_ERROR_RECORD_SEVERITY
+{
+    ADL_GLOBALLY_UNCORRECTED  = 1,
+    ADL_LOCALLY_UNCORRECTED   = 2,
+    ADL_DEFFERRED             = 3,
+    ADL_CORRECTED             = 4
+}ADL_ERROR_RECORD_SEVERITY;
+
+typedef union _ADL_ECC_EDC_FLAG
+{
+    struct
+    {
+        unsigned int isEccAccessing        : 1;
+        unsigned int reserved              : 31;
+    }bits;
+    unsigned int u32All;
+}ADL_ECC_EDC_FLAG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about EDC Error Record
+///
+/// This structure is used to store EDC Error Record
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLErrorRecord
+{
+    // Severity of error
+    ADL_ERROR_RECORD_SEVERITY Severity;
+
+    // Is the counter valid?
+    int  countValid;
+
+    // Counter value, if valid
+    unsigned int count;
+
+    // Is the location information valid?
+    int locationValid;
+
+    // Physical location of error
+    unsigned int CU; // CU number on which error occurred, if known
+    char StructureName[32]; // e.g. LDS, TCC, etc.
+
+    // Time of error record creation (e.g. time of query, or time of poison interrupt)
+    char tiestamp[32];
+
+    unsigned int padding[3];
+}ADLErrorRecord;
+
+typedef enum ADL_EDC_BLOCK_ID
+{
+    ADL_EDC_BLOCK_ID_SQCIS = 1,
+    ADL_EDC_BLOCK_ID_SQCDS = 2,
+    ADL_EDC_BLOCK_ID_SGPR  = 3,
+    ADL_EDC_BLOCK_ID_VGPR  = 4,
+    ADL_EDC_BLOCK_ID_LDS   = 5,
+    ADL_EDC_BLOCK_ID_GDS   = 6,
+    ADL_EDC_BLOCK_ID_TCL1  = 7,
+    ADL_EDC_BLOCK_ID_TCL2  = 8
+}ADL_EDC_BLOCK_ID;
+
+typedef enum ADL_ERROR_INJECTION_MODE
+{
+    ADL_ERROR_INJECTION_MODE_SINGLE      = 1,
+    ADL_ERROR_INJECTION_MODE_MULTIPLE    = 2,
+    ADL_ERROR_INJECTION_MODE_ADDRESS     = 3
+}ADL_ERROR_INJECTION_MODE;
+
+typedef union _ADL_ERROR_PATTERN
+{
+    struct
+    {
+        unsigned long  EccInjVector         :  16;
+        unsigned long  EccInjEn             :  9;
+        unsigned long  EccBeatEn            :  4;
+        unsigned long  EccChEn              :  4;
+        unsigned long  reserved             :  31;
+    } bits;
+    unsigned long long u64Value;
+} ADL_ERROR_PATTERN;
+
+typedef struct ADL_ERROR_INJECTION_DATA
+{
+    unsigned long long errorAddress;
+    ADL_ERROR_PATTERN errorPattern;
+}ADL_ERROR_INJECTION_DATA;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about EDC Error Injection
+///
+/// This structure is used to store EDC Error Injection
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLErrorInjection
+{
+    ADL_EDC_BLOCK_ID blockId;
+    ADL_ERROR_INJECTION_MODE errorInjectionMode;
+}ADLErrorInjection;
+
+typedef struct ADLErrorInjectionX2
+{
+    ADL_EDC_BLOCK_ID blockId;
+    ADL_ERROR_INJECTION_MODE errorInjectionMode;
+    ADL_ERROR_INJECTION_DATA errorInjectionData;
+}ADLErrorInjectionX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing per display FreeSync capability information.
+///
+/// This structure is used to store the FreeSync capability of both the display and
+/// the GPU the display is connected to.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFreeSyncCap
+{
+    /// FreeSync capability flags. \ref define_freesync_caps
+    int iCaps;
+    /// Reports minimum FreeSync refresh rate supported by the display in micro hertz
+    int iMinRefreshRateInMicroHz;
+    /// Reports maximum FreeSync refresh rate supported by the display in micro hertz
+    int iMaxRefreshRateInMicroHz;
+    /// Index of FreeSync Label to use:  ADL_FREESYNC_LABEL_*
+    unsigned char ucLabelIndex;
+    /// Reserved
+    char cReserved[3];
+    int iReserved[4];
+} ADLFreeSyncCap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing per display Display Connectivty Experience Settings
+///
+/// This structure is used to store the Display Connectivity Experience settings of a
+/// display
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDceSettings
+{
+    DceSettingsType type;                       // Defines which structure is in the union below
+    union
+    {
+        struct
+        {
+            bool qualityDetectionEnabled;
+        } HdmiLq;
+        struct
+        {
+            DpLinkRate linkRate;                // Read-only
+            unsigned int numberOfActiveLanes;   // Read-only
+            unsigned int numberofTotalLanes;    // Read-only
+            int relativePreEmphasis;            // Allowable values are -2 to +2
+            int relativeVoltageSwing;           // Allowable values are -2 to +2
+            int persistFlag;
+        } DpLink;
+        struct
+        {
+            bool linkProtectionEnabled;         // Read-only
+        } Protection;
+    } Settings;
+    int iReserved[15];
+} ADLDceSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Graphic Core
+///
+/// This structure is used to get Graphic Core Info
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGraphicCoreInfo
+{
+    /// indicate the graphic core generation
+    int iGCGen;
+
+    union
+    {
+        /// Total number of CUs. Valid for GCN (iGCGen == GCN)
+        int iNumCUs;
+        /// Total number of WGPs. Valid for RDNA (iGCGen == RDNA)
+        int iNumWGPs;
+    };
+
+    union
+    {
+        /// Number of processing elements per CU. Valid for GCN (iGCGen == GCN)
+        int iNumPEsPerCU;
+        /// Number of processing elements per WGP. Valid for RDNA (iGCGen == RDNA)
+        int iNumPEsPerWGP;
+    };
+
+    /// Total number of SIMDs. Valid for Pre GCN (iGCGen == Pre-GCN)
+    int iNumSIMDs;
+
+    /// Total number of ROPs. Valid for both GCN and Pre GCN
+    int iNumROPs;
+
+    /// reserved for future use
+    int iReserved[11];
+}ADLGraphicCoreInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N clock range
+///
+/// This structure is used to store information about Overdrive N clock range
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNParameterRange
+{
+    /// The starting value of the clock range
+    int     iMode;
+    /// The starting value of the clock range
+    int     iMin;
+    /// The ending value of the clock range
+    int     iMax;
+    /// The minimum increment between clock values
+    int     iStep;
+    /// The default clock values
+    int     iDefault;
+} ADLODNParameterRange;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N capabilities
+///
+/// This structure is used to store information about Overdrive N capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNCapabilities
+{
+    /// Number of levels which describe the minimum to maximum clock ranges.
+    /// The 1st level indicates the minimum clocks, and the 2nd level
+    /// indicates the maximum clocks.
+    int     iMaximumNumberOfPerformanceLevels;
+    /// Contains the hard limits of the sclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sEngineClockRange;
+    /// Contains the hard limits of the mclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sMemoryClockRange;
+    /// Contains the hard limits of the vddc range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     svddcRange;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     power;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     powerTuneTemperature;
+    /// Contains the hard limits of the Temperature range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanTemperature;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanSpeed;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     minimumPerformanceClock;
+} ADLODNCapabilities;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N capabilities
+///
+/// This structure is used to store information about Overdrive N capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNCapabilitiesX2
+{
+    /// Number of levels which describe the minimum to maximum clock ranges.
+    /// The 1st level indicates the minimum clocks, and the 2nd level
+    /// indicates the maximum clocks.
+    int     iMaximumNumberOfPerformanceLevels;
+    /// bit vector, which tells what are the features are supported.
+    /// \ref: ADLODNFEATURECONTROL
+    int iFlags;
+    /// Contains the hard limits of the sclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sEngineClockRange;
+    /// Contains the hard limits of the mclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sMemoryClockRange;
+    /// Contains the hard limits of the vddc range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     svddcRange;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     power;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     powerTuneTemperature;
+    /// Contains the hard limits of the Temperature range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanTemperature;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanSpeed;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     minimumPerformanceClock;
+    /// Contains the hard limits of the throttleNotification
+    ADLODNParameterRange throttleNotificaion;
+    /// Contains the hard limits of the Auto Systemclock
+    ADLODNParameterRange autoSystemClock;
+} ADLODNCapabilitiesX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive level.
+///
+/// This structure is used to store information about Overdrive level.
+/// This structure is used by ADLODPerformanceLevels.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevel
+{
+    /// clock.
+    int iClock;
+    /// VDCC.
+    int iVddc;
+    /// enabled
+    int iEnabled;
+} ADLODNPerformanceLevel;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N performance levels.
+///
+/// This structure is used to store information about Overdrive performance levels.
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevels
+{
+    int iSize;
+    //Automatic/manual
+    int iMode;
+    /// Must be set to sizeof( \ref ADLODPerformanceLevels ) + sizeof( \ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)
+    int iNumberOfPerformanceLevels;
+    /// Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements.
+    ADLODNPerformanceLevel aLevels[1];
+} ADLODNPerformanceLevels;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N Fan Speed.
+///
+/// This structure is used to store information about Overdrive Fan control .
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNFanControl
+{
+    int iMode;
+    int iFanControlMode;
+    int iCurrentFanSpeedMode;
+    int iCurrentFanSpeed;
+    int iTargetFanSpeed;
+    int iTargetTemperature;
+    int iMinPerformanceClock;
+    int iMinFanLimit;
+} ADLODNFanControl;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N power limit.
+///
+/// This structure is used to store information about Overdrive power limit.
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPowerLimitSetting
+{
+    int iMode;
+    int iTDPLimit;
+    int iMaxOperatingTemperature;
+} ADLODNPowerLimitSetting;
+
+typedef struct ADLODNPerformanceStatus
+{
+    int iCoreClock;
+    int iMemoryClock;
+    int iDCEFClock;
+    int iGFXClock;
+    int iUVDClock;
+    int iVCEClock;
+    int iGPUActivityPercent;
+    int iCurrentCorePerformanceLevel;
+    int iCurrentMemoryPerformanceLevel;
+    int iCurrentDCEFPerformanceLevel;
+    int iCurrentGFXPerformanceLevel;
+    int iUVDPerformanceLevel;
+    int iVCEPerformanceLevel;
+    int iCurrentBusSpeed;
+    int iCurrentBusLanes;
+    int iMaximumBusLanes;
+    int iVDDC;
+    int iVDDCI;
+} ADLODNPerformanceStatus;
+
+///\brief Structure containing information about Overdrive level.
+///
+/// This structure is used to store information about Overdrive level.
+/// This structure is used by ADLODPerformanceLevels.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevelX2
+{
+    /// clock.
+    int iClock;
+    /// VDCC.
+    int iVddc;
+    /// enabled
+    int iEnabled;
+    /// MASK
+    int iControl;
+} ADLODNPerformanceLevelX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N performance levels.
+///
+/// This structure is used to store information about Overdrive performance levels.
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevelsX2
+{
+    int iSize;
+    //Automatic/manual
+    int iMode;
+    /// Must be set to sizeof( \ref ADLODPerformanceLevels ) + sizeof( \ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)
+    int iNumberOfPerformanceLevels;
+    /// Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements.
+    ADLODNPerformanceLevelX2 aLevels[1];
+} ADLODNPerformanceLevelsX2;
+
+typedef enum ADLODNCurrentPowerType
+{
+    ODN_GPU_TOTAL_POWER = 0,
+    ODN_GPU_PPT_POWER,
+    ODN_GPU_SOCKET_POWER,
+    ODN_GPU_CHIP_POWER
+} ADLODNCurrentPowerType;
+
+// in/out: CWDDEPM_CURRENTPOWERPARAMETERS
+typedef struct ADLODNCurrentPowerParameters
+{
+    int   size;
+    ADLODNCurrentPowerType   powerType;
+    int  currentPower;
+} ADLODNCurrentPowerParameters;
+
+//ODN Ext range data structure
+typedef struct ADLODNExtSingleInitSetting
+{
+	int mode;
+	int minValue;
+	int maxValue;
+	int step;
+	int defaultValue;
+} ADLODNExtSingleInitSetting;
+
+//OD8 Ext range data structure
+typedef struct ADLOD8SingleInitSetting
+{
+    int featureID;
+    int minValue;
+    int maxValue;
+    int defaultValue;
+} ADLOD8SingleInitSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive8 initial setting
+///
+/// This structure is used to store information about Overdrive8 initial setting
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD8InitSetting
+{
+    int count;
+    int overdrive8Capabilities;
+    ADLOD8SingleInitSetting  od8SettingTable[OD8_COUNT];
+} ADLOD8InitSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive8 current setting
+///
+/// This structure is used to store information about Overdrive8 current setting
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD8CurrentSetting
+{
+    int count;
+    int Od8SettingTable[OD8_COUNT];
+} ADLOD8CurrentSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive8 set setting
+///
+/// This structure is used to store information about Overdrive8 set setting
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLOD8SingleSetSetting
+{
+    int value;
+    int requested;      // 0 - default , 1 - requested
+    int reset;          // 0 - do not reset , 1 - reset setting back to default
+} ADLOD8SingleSetSetting;
+
+typedef struct ADLOD8SetSetting
+{
+    int count;
+    ADLOD8SingleSetSetting  od8SettingTable[OD8_COUNT];
+} ADLOD8SetSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Performance Metrics data
+///
+/// This structure is used to store information about Performance Metrics data output
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSingleSensorData
+{
+    int supported;
+    int  value;
+} ADLSingleSensorData;
+
+typedef struct ADLPMLogDataOutput
+{
+    int size;
+    ADLSingleSensorData sensors[ADL_PMLOG_MAX_SENSORS];
+}ADLPMLogDataOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about PPLog settings.
+///
+/// This structure is used to store information about PPLog settings.
+/// This structure is used by the ADL2_PPLogSettings_Set() and ADL2_PPLogSettings_Get() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPPLogSettings
+{
+    int BreakOnAssert;
+    int BreakOnWarn;
+    int LogEnabled;
+    int LogFieldMask;
+    int LogDestinations;
+    int LogSeverityEnabled;
+    int LogSourceMask;
+    int PowerProfilingEnabled;
+    int PowerProfilingTimeInterval;
+}ADLPPLogSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related Frames Per Second for AC and DC.
+///
+/// This structure is used to store information related AC and DC Frames Per Second settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFPSSettingsOutput
+{
+    /// size
+    int ulSize;
+    /// FPS Monitor is enabled in the AC state if 1
+    int bACFPSEnabled;
+    /// FPS Monitor is enabled in the DC state if 1
+    int bDCFPSEnabled;
+    /// Current Value of FPS Monitor in AC state
+    int ulACFPSCurrent;
+    /// Current Value of FPS Monitor in DC state
+    int ulDCFPSCurrent;
+    /// Maximum FPS Threshold allowed in PPLib for AC
+    int ulACFPSMaximum;
+    /// Minimum FPS Threshold allowed in PPLib for AC
+    int ulACFPSMinimum;
+    /// Maximum FPS Threshold allowed in PPLib for DC
+    int ulDCFPSMaximum;
+    /// Minimum FPS Threshold allowed in PPLib for DC
+    int ulDCFPSMinimum;
+} ADLFPSSettingsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related Frames Per Second for AC and DC.
+///
+/// This structure is used to store information related AC and DC Frames Per Second settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFPSSettingsInput
+{
+    /// size
+    int ulSize;
+    /// Settings are for Global FPS (used by CCC)
+    int bGlobalSettings;
+    /// Current Value of FPS Monitor in AC state
+    int ulACFPSCurrent;
+    /// Current Value of FPS Monitor in DC state
+    int ulDCFPSCurrent;
+    /// Reserved
+    int ulReserved[6];
+} ADLFPSSettingsInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related power management logging.
+///
+/// This structure is used to store support information for power management logging.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+enum { ADL_PMLOG_MAX_SUPPORTED_SENSORS = 256 };
+
+typedef struct ADLPMLogSupportInfo
+{
+    /// list of sensors defined by ADL_PMLOG_SENSORS
+    unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
+    /// Reserved
+    int ulReserved[16];
+} ADLPMLogSupportInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information to start power management logging.
+///
+/// This structure is used as input to ADL2_Adapter_PMLog_Start
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMLogStartInput
+{
+    /// list of sensors defined by ADL_PMLOG_SENSORS
+    unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
+    /// Sample rate in milliseconds
+    unsigned long ulSampleRate;
+    /// Reserved
+    int ulReserved[15];
+} ADLPMLogStartInput;
+
+typedef struct ADLPMLogData
+{
+    /// Structure version
+    unsigned int ulVersion;
+    /// Current driver sample rate
+    unsigned int ulActiveSampleRate;
+    /// Timestamp of last update
+    unsigned long long ulLastUpdated;
+    /// 2D array of senesor and values
+    unsigned int ulValues[ADL_PMLOG_MAX_SUPPORTED_SENSORS][2];
+    /// Reserved
+    unsigned int ulReserved[256];
+} ADLPMLogData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information to start power management logging.
+///
+/// This structure is returned as output from ADL2_Adapter_PMLog_Start
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMLogStartOutput
+{
+    /// Pointer to memory address containing logging data
+    union
+    {
+        void* pLoggingAddress;
+        unsigned long long ptr_LoggingAddress;
+    };
+    /// Reserved
+    int ulReserved[14];
+} ADLPMLogStartOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information to query limts of power management logging.
+///
+/// This structure is returned as output from ADL2_Adapter_PMLog_SensorLimits_Get
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMLogSensorLimits
+{
+    int SensorLimits[ADL_PMLOG_MAX_SENSORS][2]; //index 0: min, 1: max
+} ADLPMLogSensorLimits;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Get Error Counts Information
+///
+/// This structure is used to store RAS Error Counts Get Input Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASGetErrorCountsInput
+{
+    unsigned int                Reserved[16];
+} ADLRASGetErrorCountsInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Get Error Counts Information
+///
+/// This structure is used to store RAS Error Counts Get Output Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASGetErrorCountsOutput
+{
+    unsigned int                CorrectedErrors;    // includes both DRAM and SRAM ECC
+    unsigned int                UnCorrectedErrors;  // includes both DRAM and SRAM ECC
+    unsigned int                Reserved[14];
+} ADLRASGetErrorCountsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Get Error Counts Information
+///
+/// This structure is used to store RAS Error Counts Get Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASGetErrorCounts
+{
+    unsigned int                InputSize;
+    ADLRASGetErrorCountsInput   Input;
+    unsigned int                OutputSize;
+    ADLRASGetErrorCountsOutput  Output;
+} ADLRASGetErrorCounts;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Counts Reset Information
+///
+/// This structure is used to store RAS Error Counts Reset Input Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASResetErrorCountsInput
+{
+    unsigned int                Reserved[8];
+} ADLRASResetErrorCountsInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Counts Reset Information
+///
+/// This structure is used to store RAS Error Counts Reset Output Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASResetErrorCountsOutput
+{
+    unsigned int                Reserved[8];
+} ADLRASResetErrorCountsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Counts Reset Information
+///
+/// This structure is used to store RAS Error Counts Reset Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASResetErrorCounts
+{
+    unsigned int                    InputSize;
+    ADLRASResetErrorCountsInput     Input;
+    unsigned int                    OutputSize;
+    ADLRASResetErrorCountsOutput    Output;
+} ADLRASResetErrorCounts;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Injection information
+///
+/// This structure is used to store RAS Error Injection input information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASErrorInjectonInput
+{
+    unsigned long long Address;
+    ADL_RAS_INJECTION_METHOD Value;
+    ADL_RAS_BLOCK_ID BlockId;
+    ADL_RAS_ERROR_TYPE InjectErrorType;
+    ADL_MEM_SUB_BLOCK_ID SubBlockIndex;
+    unsigned int padding[9];
+} ADLRASErrorInjectonInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Injection information
+///
+/// This structure is used to store RAS Error Injection output information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASErrorInjectionOutput
+{
+    unsigned int ErrorInjectionStatus;
+    unsigned int padding[15];
+} ADLRASErrorInjectionOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Injection information
+///
+/// This structure is used to store RAS Error Injection information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASErrorInjection
+{
+    unsigned int                           InputSize;
+    ADLRASErrorInjectonInput               Input;
+    unsigned int                           OutputSize;
+    ADLRASErrorInjectionOutput             Output;
+} ADLRASErrorInjection;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of a recently ran or currently running application
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSGApplicationInfo
+{
+    /// Application file name
+    wchar_t strFileName[ADL_MAX_PATH];
+    /// Application file path
+    wchar_t strFilePath[ADL_MAX_PATH];
+    /// Application version
+    wchar_t strVersion[ADL_MAX_PATH];
+    /// Timestamp at which application has run
+    long long int timeStamp;
+    /// Holds whether the applicaition profile exists or not
+    unsigned int iProfileExists;
+    /// The GPU on which application runs
+    unsigned int iGPUAffinity;
+    /// The BDF of the GPU on which application runs
+    ADLBdf GPUBdf;
+} ADLSGApplicationInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related Frames Per Second for AC and DC.
+///
+/// This structure is used to store information related AC and DC Frames Per Second settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+enum { ADLPreFlipPostProcessingInfoInvalidLUTIndex = 0xFFFFFFFF };
+
+enum ADLPreFlipPostProcessingLUTAlgorithm
+{
+    ADLPreFlipPostProcessingLUTAlgorithm_Default = 0,
+    ADLPreFlipPostProcessingLUTAlgorithm_Full,
+    ADLPreFlipPostProcessingLUTAlgorithm_Approximation
+};
+
+typedef struct ADLPreFlipPostProcessingInfo
+{
+    /// size
+    int ulSize;
+    /// Current active state
+    int bEnabled;
+    /// Current selected LUT index.  0xFFFFFFF returned if nothing selected.
+    int ulSelectedLUTIndex;
+    /// Current selected LUT Algorithm
+    int ulSelectedLUTAlgorithm;
+    /// Reserved
+    int ulReserved[12];
+} ADLPreFlipPostProcessingInfo;
+
+typedef struct ADL_ERROR_REASON
+{
+    int boost; //ON, when boost is Enabled
+    int delag; //ON, when delag is Enabled
+    int chill; //ON, when chill is Enabled
+    int proVsr; //ON, when proVsr is Enabled
+}ADL_ERROR_REASON;
+
+typedef struct ADL_ERROR_REASON2
+{
+    int boost; //ON, when boost is Enabled
+    int delag; //ON, when delag is Enabled
+    int chill; //ON, when chill is Enabled
+    int proVsr; //ON, when proVsr is Enabled
+    int upscale; //ON, when RSR is Enabled
+}ADL_ERROR_REASON2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DELAG Settings change reason
+///
+///  Elements of DELAG settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DELAG_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+	int GlobalLimitFPSChanged; //Set when Global enable value is changed
+}ADL_DELAG_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DELAG Settings
+///
+///  Elements of DELAG settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DELAG_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+	int GlobalLimitFPS; //Global Limit FPS
+	int GlobalLimitFPS_MinLimit; //Gloabl Limit FPS slider min limit value
+	int GlobalLimitFPS_MaxLimit; //Gloabl Limit FPS slider max limit value
+	int GlobalLimitFPS_Step; //Gloabl Limit FPS step  value
+}ADL_DELAG_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about BOOST Settings change reason
+///
+///  Elements of BOOST settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_BOOST_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+	int GlobalMinResChanged; //Set when Global min resolution value is changed
+}ADL_BOOST_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about BOOST Settings
+///
+///  Elements of BOOST settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_BOOST_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+	int GlobalMinRes; //Gloabl Min Resolution value
+	int GlobalMinRes_MinLimit; //Gloabl Min Resolution slider min limit value
+	int GlobalMinRes_MaxLimit; //Gloabl Min Resolution slider max limit value
+	int GlobalMinRes_Step; //Gloabl Min Resolution step  value
+}ADL_BOOST_SETTINGS;
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about ProVSR Settings change reason
+///
+///  Elements of ProVSR settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_PROVSR_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+}ADL_PROVSR_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Pro VSR Settings
+///
+///  Elements of ProVSR settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_PROVSR_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+}ADL_PROVSR_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Image Boost(OGL) Settings change reason
+///
+///  Elements of Image Boost settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_IMAGE_BOOST_NOTFICATION_REASON
+{
+    int HotkeyChanged; //Set when Hotkey value is changed
+    int GlobalEnableChanged; //Set when Global enable value is changed
+}ADL_IMAGE_BOOST_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about OGL IMAGE BOOST Settings
+///
+///  Elements of OGL IMAGE BOOST settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_IMAGE_BOOST_SETTINGS
+{
+    int Hotkey; // Hotkey value
+    int GlobalEnable; //Global enable value
+}ADL_IMAGE_BOOST_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about RIS Settings change reason
+///
+///  Elements of RIS settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RIS_NOTFICATION_REASON
+{
+	unsigned int GlobalEnableChanged; //Set when Global enable value is changed
+	unsigned int GlobalSharpeningDegreeChanged; //Set when Global sharpening Degree value is changed
+}ADL_RIS_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about RIS Settings
+///
+///  Elements of RIS settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RIS_SETTINGS
+{
+	int GlobalEnable; //Global enable value
+	int GlobalSharpeningDegree; //Global sharpening value
+	int GlobalSharpeningDegree_MinLimit; //Gloabl sharpening slider min limit value
+	int GlobalSharpeningDegree_MaxLimit; //Gloabl sharpening slider max limit value
+	int GlobalSharpeningDegree_Step; //Gloabl sharpening step  value
+}ADL_RIS_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about CHILL Settings change reason
+///
+///  Elements of Chiil settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_CHILL_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+	int GlobalMinFPSChanged; //Set when Global min FPS value is changed
+	int GlobalMaxFPSChanged; //Set when Global max FPS value is changed
+}ADL_CHILL_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about CHILL Settings
+///
+///  Elements of Chill settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_CHILL_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+	int GlobalMinFPS; //Global Min FPS value
+	int GlobalMaxFPS; //Global Max FPS value
+	int GlobalFPS_MinLimit; //Gloabl FPS slider min limit value
+	int GlobalFPS_MaxLimit; //Gloabl FPS slider max limit value
+	int GlobalFPS_Step; //Gloabl FPS Slider step  value
+}ADL_CHILL_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DRIVERUPSCALE Settings change reason
+///
+///  Elements of DRIVERUPSCALE settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DRIVERUPSCALE_NOTFICATION_REASON
+{
+    int ModeOverrideEnabledChanged;     //Set when Global min resolution value is changed
+    int GlobalEnabledChanged;           //Set when Global enable value is changed
+}ADL_DRIVERUPSCALE_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DRIVERUPSCALE Settings
+///
+///  Elements of DRIVERUPSCALE settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DRIVERUPSCALE_SETTINGS
+{
+    int ModeOverrideEnabled;
+    int GlobalEnabled;
+}ADL_DRIVERUPSCALE_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief  Structure Containing R G B values for Radeon USB LED Bar
+///
+/// Elements of RGB Values.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_COLOR_CONFIG
+{
+	unsigned short R : 8; // Red Value
+	unsigned short G : 8; // Green Value
+	unsigned short B : 8; // Blue Value
+}ADL_RADEON_LED_COLOR_CONFIG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure Containing All Generic LED configuration for user requested LED pattern. The driver will apply the confgiuration as requested
+///
+///  Elements of Radeon USB LED configuration.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_PATTERN_CONFIG_GENERIC
+{
+	short brightness : 8; // Brightness of LED
+	short speed : 8; // Speed of LED pattern
+	bool directionCounterClockWise; //Direction of LED Pattern
+	ADL_RADEON_LED_COLOR_CONFIG colorConfig; // RGB value of LED pattern
+	char morseCodeText[ADL_RADEON_LED_MAX_MORSE_CODE]; // Morse Code user input for Morse Code LED pattern
+	char morseCodeTextOutPut[ADL_RADEON_LED_MAX_MORSE_CODE]; // Driver set output representation of Morse Code
+	int  morseCodeTextOutPutLen; // Length of Morse Code output
+}ADL_RADEON_LED_PATTERN_CONFIG_GENERIC;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure Containing All custom grid pattern LED configuration for user requested LED grid pattern. The driver will apply the confgiuration as requested
+///
+///  Elements of Radeon USB LED custom grid configuration.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_CUSTOM_LED_CONFIG
+{
+	short brightness : 8; // Brightness of LED
+	ADL_RADEON_LED_COLOR_CONFIG colorConfig[ADL_RADEON_LED_MAX_LED_ROW_ON_GRID][ADL_RADEON_LED_MAX_LED_COLUMN_ON_GRID]; // Full grid array representation of Radeon LED to be populated by user
+}ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure Containing All Radeon USB LED requests and controls.
+///
+/// Elements of Radeon USB LED Controls.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_PATTERN_CONFIG
+{
+	ADL_RADEON_USB_LED_BAR_CONTROLS control; //Requested LED pattern
+
+    union
+    {
+		ADL_RADEON_LED_PATTERN_CONFIG_GENERIC genericPararmeters; //Requested pattern configuration settings
+		ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG customGridConfig; //Requested custom grid configuration settings
+    };
+}ADL_RADEON_LED_PATTERN_CONFIG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the graphics adapter with extended caps
+///
+/// This structure is used to store various information about the graphics adapter.  This
+/// information can be returned to the user. Alternatively, it can be used to access various driver calls to set
+/// or fetch various settings upon the user's request.
+/// This AdapterInfoX2 struct extends the AdapterInfo struct in adl_structures.h
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct AdapterInfoX2
+{
+    /// \ALL_STRUCT_MEM
+
+    /// Size of the structure.
+    int iSize;
+    /// The ADL index handle. One GPU may be associated with one or two index handles
+    int iAdapterIndex;
+    /// The unique device ID associated with this adapter.
+    char strUDID[ADL_MAX_PATH];
+    /// The BUS number associated with this adapter.
+    int iBusNumber;
+    /// The driver number associated with this adapter.
+    int iDeviceNumber;
+    /// The function number.
+    int iFunctionNumber;
+    /// The vendor ID associated with this adapter.
+    int iVendorID;
+    /// Adapter name.
+    char strAdapterName[ADL_MAX_PATH];
+    /// Display name. For example, "\\\\Display0"
+    char strDisplayName[ADL_MAX_PATH];
+    /// Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\.\\Display1 can be found from OS
+    int iPresent;
+    /// Exist or not; 1 is exist and 0 is not present.
+    int iExist;
+    /// Driver registry path.
+    char strDriverPath[ADL_MAX_PATH];
+    /// Driver registry path Ext for.
+    char strDriverPathExt[ADL_MAX_PATH];
+    /// PNP string from Windows.
+    char strPNPString[ADL_MAX_PATH];
+    /// It is generated from EnumDisplayDevices.
+    int iOSDisplayIndex;
+    /// The bit mask identifies the adapter info
+    int iInfoMask;
+    /// The bit identifies the adapter info \ref define_adapter_info
+    int iInfoValue;
+} AdapterInfoX2, *LPAdapterInfoX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver  gamut space , whether it is related to source or to destination, overlay or graphics
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef  struct ADLGamutReference
+{
+    /// mask whether it is related to source or to destination, overlay or graphics
+    int      iGamutRef;
+}ADLGamutReference;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver supported gamut spaces , capability method
+///
+/// This structure is used to get driver all supported gamut spaces
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLGamutInfo
+{
+    ///Any combination of following ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CUSTOM
+    int    SupportedGamutSpace;
+
+    ///Any combination of following ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_CUSTOM
+    int    SupportedWhitePoint;
+} ADLGamutInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver point coordinates
+///
+/// This structure is used to store the driver point coodinates for gamut and white point
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLPoint
+{
+    /// x coordinate
+    int          iX;
+    /// y coordinate
+    int          iY;
+} ADLPoint;
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver supported gamut coordinates
+///
+/// This structure is used to store the driver supported supported gamut coordinates
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLGamutCoordinates
+{
+    /// red channel chromasity coordinate
+    ADLPoint      Red;
+    /// green channel chromasity coordinate
+    ADLPoint      Green;
+    /// blue channel chromasity coordinate
+    ADLPoint      Blue;
+} ADLGamutCoordinates;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver current gamut space , parent struct for ADLGamutCoordinates and ADLWhitePoint
+/// This structure is used to get/set driver supported gamut space
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef  struct ADLGamutData
+{
+    ///used as mask and could be 4 options
+    ///BIT_0 If flag ADL_GAMUT_REFERENCE_SOURCE is asserted set operation is related to gamut source ,
+    ///if not gamut destination
+    ///BIT_1 If flag ADL_GAMUT_GAMUT_VIDEO_CONTENT is asserted
+    ///BIT_2,BIT_3 used as mask and could be 4 options custom (2) + predefined (2)
+    ///0.  Gamut predefined,        white point predefined -> 0                | 0
+    ///1.  Gamut predefined,        white point custom     -> 0                | ADL_CUSTOM_WHITE_POINT
+    ///2.  White point predefined,  gamut custom           -> 0                | ADL_CUSTOM_GAMUT
+    ///3.  White point custom,      gamut custom           -> ADL_CUSTOM_GAMUT | ADL_CUSTOM_WHITE_POINT
+    int        iFeature;
+
+    ///one of ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CIE_RGB
+    int         iPredefinedGamut;
+
+    ///one of ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_9300K
+    int         iPredefinedWhitePoint;
+
+    ///valid when in mask avails ADL_CUSTOM_WHITE_POINT
+    ADLPoint             CustomWhitePoint;
+
+    ///valid when in mask avails ADL_CUSTOM_GAMUT
+    ADLGamutCoordinates  CustomGamut;
+} ADLGamutData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing detailed timing parameters.
+///
+/// This structure is used to store the detailed timing parameters.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDetailedTimingX2
+{
+    /// Size of the structure.
+    int   iSize;
+    /// Timing flags. \ref define_detailed_timing_flags
+    int sTimingFlags;
+    /// Total width (columns).
+    int sHTotal;
+    /// Displayed width.
+    int sHDisplay;
+    /// Horizontal sync signal offset.
+    int sHSyncStart;
+    /// Horizontal sync signal width.
+    int sHSyncWidth;
+    /// Total height (rows).
+    int sVTotal;
+    /// Displayed height.
+    int sVDisplay;
+    /// Vertical sync signal offset.
+    int sVSyncStart;
+    /// Vertical sync signal width.
+    int sVSyncWidth;
+    /// Pixel clock value.
+    int sPixelClock;
+    /// Overscan right.
+    short sHOverscanRight;
+    /// Overscan left.
+    short sHOverscanLeft;
+    /// Overscan bottom.
+    short sVOverscanBottom;
+    /// Overscan top.
+    short sVOverscanTop;
+    short sOverscan8B;
+    short sOverscanGR;
+} ADLDetailedTimingX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing display mode information.
+///
+/// This structure is used to store the display mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayModeInfoX2
+{
+    /// Timing standard of the current mode. \ref define_modetiming_standard
+    int  iTimingStandard;
+    /// Applicable timing standards for the current mode.
+    int  iPossibleStandard;
+    /// Refresh rate factor.
+    int  iRefreshRate;
+    /// Num of pixels in a row.
+    int  iPelsWidth;
+    /// Num of pixels in a column.
+    int  iPelsHeight;
+    /// Detailed timing parameters.
+    ADLDetailedTimingX2  sDetailedTiming;
+} ADLDisplayModeInfoX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about I2C.
+///
+/// This structure is used to store the I2C information for the current adapter.
+/// This structure is used by \ref ADL_Display_WriteAndReadI2CLargePayload
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLI2CLargePayload
+{
+    /// Size of the structure
+    int iSize;
+    /// Numerical value representing hardware I2C.
+    int iLine;
+    /// The 7-bit I2C slave device address.
+    int iAddress;
+    /// The offset of the data from the address.
+    int iOffset;
+    /// Read from or write to slave device. \ref ADL_DL_I2C_ACTIONREAD or \ref ADL_DL_I2C_ACTIONWRITE
+    int iAction;
+    /// I2C clock speed in KHz.
+    int iSpeed;
+    /// I2C option flags.  \ref define_ADLI2CLargePayload
+    int iFlags;
+    /// A numerical value representing the number of bytes to be sent or received on the I2C bus.
+    int iDataSize;
+    /// Address of the characters which are to be sent or received on the I2C bus.
+    char *pcData;
+} ADLI2CLargePayload;
+
+/// Size in bytes of the Feature Name
+#define ADL_FEATURE_NAME_LENGTH 	16
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Multimedia Feature Name
+///
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFeatureName
+{
+    /// The Feature Name
+    char FeatureName[ADL_FEATURE_NAME_LENGTH];
+}	ADLFeatureName, *LPADLFeatureName;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about MM Feature Capabilities.
+///
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFeatureCaps
+{
+    /// The Feature Name
+    ADLFeatureName	Name;
+    //	char strFeatureName[ADL_FEATURE_NAME_LENGTH];
+
+    /// Group ID. All Features in the same group are shown sequentially in the same UI Page.
+    int  iGroupID;
+
+    /// Visual ID. Places one or more features in a Group Box. If zero, no Group Box is added.
+    int  iVisualID;
+
+    /// Page ID. All Features with the same Page ID value are shown together on the same UI page.
+    int iPageID;
+
+    /// Feature Property Mask. Indicates which are the valid bits for iFeatureProperties.
+    int iFeatureMask;
+
+    /// Feature Property Values. See definitions for ADL_FEATURE_PROPERTIES_XXX
+    int  iFeatureProperties;
+
+    /// Apperance of the User-Controlled Boolean.
+    int  iControlType;
+
+    /// Style of the User-Controlled Boolean.
+    int  iControlStyle;
+
+    /// Apperance of the Adjustment Controls.
+    int  iAdjustmentType;
+
+    /// Style of the Adjustment Controls.
+    int  iAdjustmentStyle;
+
+    /// Default user-controlled boolean value. Valid only if ADLFeatureCaps supports user-controlled boolean.
+    int bDefault;
+
+    /// Minimum integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iMin;
+
+    /// Maximum integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iMax;
+
+    /// Step integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iStep;
+
+    /// Default integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iDefault;
+
+    /// Minimum float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fMin;
+
+    /// Maximum float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fMax;
+
+    /// Step float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fStep;
+
+    /// Default float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fDefault;
+
+    /// The Mask for available bits for enumerated values.(If ADLFeatureCaps supports ENUM values)
+    int EnumMask;
+} ADLFeatureCaps, *LPADLFeatureCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about MM Feature Values.
+///
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFeatureValues
+{
+    /// The Feature Name
+    ADLFeatureName	Name;
+    //	char strFeatureName[ADL_FEATURE_NAME_LENGTH];
+
+    /// User controlled Boolean current value. Valid only if ADLFeatureCaps supports Boolean.
+    int bCurrent;
+
+    /// Current integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iCurrent;
+
+    /// Current float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fCurrent;
+
+    /// The States for the available bits for enumerated values.
+    int EnumStates;
+} ADLFeatureValues, *LPADLFeatureValues;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing HDCP Settings info
+///
+/// This structure is used to store the HDCP settings of a
+/// display
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLHDCPSettings
+{
+	int iHDCPProtectionVersion; // Version, starting from 1
+	int iHDCPCaps; //Caps used to ensure at least one protection scheme is supported, 1 is HDCP1X and 2 is HDCP22
+	int iAllowAll; //Allow all is true, disable all is false
+	int iHDCPVale;
+	int iHDCPMask;
+} ADLHDCPSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing Mantle App  info
+///
+/// This structure is used to store the Mantle Driver information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLMantleAppInfo
+{
+	/// mantle api version
+	int   apiVersion;
+	/// mantle driver version
+	long   driverVersion;
+	/// mantle vendroe id
+	long   vendorId;
+	/// mantle device id
+	long   deviceId;
+	/// mantle gpu type;
+	int     gpuType;
+	/// gpu name
+	char     gpuName[256];
+	/// mem size
+	int     maxMemRefsPerSubmission;
+	/// virtual mem size
+	long long virtualMemPageSize;
+	/// mem update
+	long long maxInlineMemoryUpdateSize;
+	/// bound descriptot
+	long     maxBoundDescriptorSets;
+	/// thread group size
+	long     maxThreadGroupSize;
+	/// time stamp frequency
+	long  long timestampFrequency;
+	/// color target
+	long     multiColorTargetClears;
+}ADLMantleAppInfo, *LPADLMantleAppInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about SDIData
+///This structure is used to store information about the state of the SDI whether it is on
+///or off and the current size of the segment or aperture size.
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSDIData
+{
+	/// The SDI state, ADL_SDI_ON or ADL_SDI_OFF, for the current SDI mode
+	int iSDIState;
+	/// Size of the memory segment for SDI (in MB).
+	int iSizeofSDISegment;
+} ADLSDIData, *LPADLSDIData;
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about FRTCPRO Settings
+///
+///  Elements of FRTCPRO settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_FRTCPRO_Settings
+{
+    int DefaultState;              //The default status for FRTC pro
+    int CurrentState;              //The current enable/disable status for FRTC pro
+    unsigned int DefaultValue;     //The default FPS value for FRTC pro.
+    unsigned int CurrentValue;      //The current FPS value for FRTC pro.
+    unsigned int maxSupportedFps;      //The max value for FRTC pro.
+    unsigned int minSupportedFps;      //The min value for FRTC pro.
+}ADL_FRTCPRO_Settings, *LPADLFRTCProSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about FRTCPRO Settings changed reason
+///
+///  Reason of FRTCPRO changed.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_FRTCPRO_CHANGED_REASON
+{
+    int StateChanged;               // FRTCPro state changed
+    int ValueChanged;               // FRTCPro value changed
+}ADL_FRTCPRO_CHANGED_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing the display mode definition used per controller.
+///
+/// This structure is used to store the display mode definition used per controller.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DL_DISPLAY_MODE
+{
+    int  iPelsHeight;                      // Vertical resolution (in pixels).
+    int  iPelsWidth;                       // Horizontal resolution (in pixels).
+    int  iBitsPerPel;                      // Color depth.
+    int  iDisplayFrequency;                // Refresh rate.
+} ADL_DL_DISPLAY_MODE;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related DCE support
+///
+/// This structure is used to store a bit vector of possible DCE support
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef union _ADLDCESupport
+{
+    struct
+    {
+        unsigned int PrePhasis : 1;
+        unsigned int voltageSwing : 1;
+        unsigned int reserved : 30;
+    }bits;
+    unsigned int u32All;
+}ADLDCESupport;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure for Smart shift 2.0 settings
+///
+/// This structure is used to return the smart shift settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSmartShiftSettings
+{
+	int iMinRange;
+	int iMaxRange;
+	int iDefaultMode; //Refer to CWDDEPM_ODN_CONTROL_TYPE
+	int iDefaultValue;
+	int iCurrentMode;
+	int iCurrentValue;
+    int iFlags; //refer to define_smartshift_bits
+}ADLSmartShiftSettings, *LPADLSmartShiftSettings;
+#endif /* ADL_STRUCTURES_H_ */
diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 1e447f38ded..6b4d04d9eb9 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -10,17 +10,22 @@
 @ stub ADL2_AdapterLimitation_Caps
 @ stub ADL2_AdapterX2_Caps
 @ stub ADL2_Adapter_AMDAndNonAMDDIsplayClone_Get
-@ stub ADL2_Adapter_ASICFamilyType_Get
+@ cdecl -arch=i386 ADL2_Adapter_ASICFamilyType_Get(ptr long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_ASICFamilyType_Get(ptr long ptr ptr)
 @ stub ADL2_Adapter_ASICInfo_Get
 @ stub ADL2_Adapter_Accessibility_Get
 @ stub ADL2_Adapter_AceDefaults_Restore
-@ stub ADL2_Adapter_Active_Get
+@ cdecl -arch=i386 ADL2_Adapter_Active_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_Active_Get(ptr long ptr)
 @ stub ADL2_Adapter_Active_Set
 @ stub ADL2_Adapter_Active_SetPrefer
-@ stub ADL2_Adapter_AdapterInfoX2_Get
+@ cdecl -arch=i386 ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
 @ stub ADL2_Adapter_AdapterInfoX3_Get
-@ stub ADL2_Adapter_AdapterInfoX4_Get
-@ stub ADL2_Adapter_AdapterInfo_Get
+@ cdecl -arch=i386 ADL2_Adapter_AdapterInfoX4_Get(ptr long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_AdapterInfoX4_Get(ptr long ptr ptr)
+@ cdecl -arch=i386 ADL2_Adapter_AdapterInfo_Get(ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Adapter_AdapterInfo_Get(ptr ptr long)
 @ stub ADL2_Adapter_AdapterList_Disable
 @ stub ADL2_Adapter_AdapterLocationPath_Get
 @ stub ADL2_Adapter_Aspects_Get
@@ -49,7 +54,8 @@
 @ stub ADL2_Adapter_CrossdisplayInfo_Get
 @ stub ADL2_Adapter_CrossdisplayInfo_Set
 @ stub ADL2_Adapter_CrossfireX2_Get
-@ stub ADL2_Adapter_Crossfire_Caps
+@ cdecl -arch=i386 ADL2_Adapter_Crossfire_Caps(ptr long ptr ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_Crossfire_Caps(ptr long ptr ptr ptr)
 @ stub ADL2_Adapter_Crossfire_Get
 @ stub ADL2_Adapter_Crossfire_Set
 @ stub ADL2_Adapter_DefaultAudioChannelTable_Load
@@ -82,7 +88,8 @@
 @ stub ADL2_Adapter_FrameMetrics_Stop
 @ stub ADL2_Adapter_Gamma_Get
 @ stub ADL2_Adapter_Gamma_Set
-@ stub ADL2_Adapter_Graphic_Core_Info_Get
+@ cdecl -arch=i386 ADL2_Adapter_Graphic_Core_Info_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_Graphic_Core_Info_Get(ptr long ptr)
 @ stub ADL2_Adapter_HBC_Caps
 @ stub ADL2_Adapter_HBM_ECC_UC_Check
 @ stub ADL2_Adapter_Headless_Get
@@ -93,14 +100,17 @@
 @ stub ADL2_Adapter_LocalDisplayState_Get
 @ stub ADL2_Adapter_MVPU_Set
 @ stub ADL2_Adapter_MaxCursorSize_Get
-@ stub ADL2_Adapter_MemoryInfo2_Get
-@ stub ADL2_Adapter_MemoryInfo_Get
+@ cdecl -arch=i386 ADL2_Adapter_MemoryInfo2_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_MemoryInfo2_Get(ptr long ptr)
+@ cdecl -arch=i386 ADL2_Adapter_MemoryInfo_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_MemoryInfo_Get(ptr long ptr)
 @ stub ADL2_Adapter_MirabilisSupport_Get
 @ stub ADL2_Adapter_ModeSwitch
 @ stub ADL2_Adapter_ModeTimingOverride_Caps
 @ stub ADL2_Adapter_Modes_ReEnumerate
 @ stub ADL2_Adapter_NumberOfActivatableSources_Get
-@ stdcall ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
+@ cdecl -arch=i386 ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
 @ stub ADL2_Adapter_ObservedClockInfo_Get
 @ stub ADL2_Adapter_PMLog_Start
 @ stub ADL2_Adapter_PMLog_Stop
@@ -249,7 +259,8 @@
 @ stub ADL2_Display_DCE_Get
 @ stub ADL2_Display_DCE_Set
 @ stub ADL2_Display_DDCBlockAccess_Get
-@ stub ADL2_Display_DDCInfo2_Get
+@ cdecl -arch=i386 ADL2_Display_DDCInfo2_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_DDCInfo2_Get(ptr long long ptr)
 @ stub ADL2_Display_DDCInfo_Get
 @ stub ADL2_Display_Deflicker_Get
 @ stub ADL2_Display_Deflicker_Set
@@ -257,9 +268,11 @@
 @ stub ADL2_Display_DisplayContent_Cap
 @ stub ADL2_Display_DisplayContent_Get
 @ stub ADL2_Display_DisplayContent_Set
-@ stub ADL2_Display_DisplayInfo_Get
+@ cdecl -arch=i386 ADL2_Display_DisplayInfo_Get(ptr long ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Display_DisplayInfo_Get(ptr long ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfigX2_Set
-@ stub ADL2_Display_DisplayMapConfig_Get
+@ cdecl -arch=i386 ADL2_Display_DisplayMapConfig_Get(ptr long ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Display_DisplayMapConfig_Get(ptr long ptr ptr ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfig_PossibleAddAndRemove
 @ stub ADL2_Display_DisplayMapConfig_Set
 @ stub ADL2_Display_DisplayMapConfig_Validate
@@ -270,7 +283,8 @@
 @ stub ADL2_Display_DpMstInfo_Get
 @ stub ADL2_Display_DummyVirtual_Destroy
 @ stub ADL2_Display_DummyVirtual_Get
-@ stub ADL2_Display_EdidData_Get
+@ cdecl -arch=i386 ADL2_Display_EdidData_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_EdidData_Get(ptr long long ptr)
 @ stub ADL2_Display_EdidData_Set
 @ stub ADL2_Display_EnumDisplays_Get
 @ stub ADL2_Display_FilterSVideo_Get
@@ -281,7 +295,8 @@
 @ stub ADL2_Display_FormatsOverride_Set
 @ stub ADL2_Display_FreeSyncState_Get
 @ stub ADL2_Display_FreeSyncState_Set
-@ stub ADL2_Display_FreeSync_Cap
+@ cdecl -arch=i386 ADL2_Display_FreeSync_Cap(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_FreeSync_Cap(ptr long long ptr)
 @ stub ADL2_Display_GamutMapping_Get
 @ stub ADL2_Display_GamutMapping_Reset
 @ stub ADL2_Display_GamutMapping_Set
@@ -315,7 +330,8 @@
 @ stub ADL2_Display_ModeTimingOverride_Delete
 @ stub ADL2_Display_ModeTimingOverride_Get
 @ stub ADL2_Display_ModeTimingOverride_Set
-@ stub ADL2_Display_Modes_Get
+@ cdecl -arch=i386 ADL2_Display_Modes_Get(ptr long long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Display_Modes_Get(ptr long long ptr ptr)
 @ stub ADL2_Display_Modes_Set
 @ stub ADL2_Display_Modes_X2_Get
 @ stub ADL2_Display_MonitorPowerState_Set
@@ -369,14 +385,16 @@
 @ stub ADL2_Display_SLSMapConfigX2_Get
 @ stub ADL2_Display_SLSMapConfig_Create
 @ stub ADL2_Display_SLSMapConfig_Delete
-@ stub ADL2_Display_SLSMapConfig_Get
+@ cdecl -arch=i386 ADL2_Display_SLSMapConfig_Get(ptr long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Display_SLSMapConfig_Get(ptr long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
 @ stub ADL2_Display_SLSMapConfig_ImageCropType_Set
 @ stub ADL2_Display_SLSMapConfig_Rearrange
 @ stub ADL2_Display_SLSMapConfig_SetState
 @ stub ADL2_Display_SLSMapConfig_SupportedImageCropType_Get
 @ stub ADL2_Display_SLSMapConfig_Valid
 @ stub ADL2_Display_SLSMapIndexList_Get
-@ stub ADL2_Display_SLSMapIndex_Get
+@ cdecl -arch=i386 ADL2_Display_SLSMapIndex_Get(ptr long long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Display_SLSMapIndex_Get(ptr long long ptr ptr)
 @ stub ADL2_Display_SLSMiddleMode_Get
 @ stub ADL2_Display_SLSMiddleMode_Set
 @ stub ADL2_Display_SLSRecords_Get
@@ -387,7 +405,8 @@
 @ stub ADL2_Display_Size_Get
 @ stub ADL2_Display_Size_Set
 @ stub ADL2_Display_SourceContentAttribute_Get
-@ stub ADL2_Display_SourceContentAttribute_Set
+@ cdecl -arch=i386 ADL2_Display_SourceContentAttribute_Set(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_SourceContentAttribute_Set(ptr long long ptr)
 @ stub ADL2_Display_SplitDisplay_Caps
 @ stub ADL2_Display_SplitDisplay_Get
 @ stub ADL2_Display_SplitDisplay_RestoreDesktopConfiguration
@@ -429,11 +448,17 @@
 @ stub ADL2_GPUVerInfo_Get
 @ stub ADL2_GcnAsicInfo_Get
 @ stub ADL2_Graphics_IsDetachableGraphicsPlatform_Get
-@ stub ADL2_Graphics_IsGfx9AndAbove
+@ cdecl -arch=i386 ADL2_Graphics_IsGfx9AndAbove(ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_IsGfx9AndAbove(ptr)
 @ stub ADL2_Graphics_MantleVersion_Get
-@ stub ADL2_Graphics_Platform_Get
-@ stdcall ADL2_Graphics_VersionsX2_Get(ptr ptr)
-@ stub ADL2_Graphics_Versions_Get
+@ cdecl -arch=i386 ADL2_Graphics_Platform_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_Platform_Get(ptr ptr)
+@ cdecl -arch=i386 ADL2_Graphics_VersionsX2_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_VersionsX2_Get(ptr ptr)
+@ cdecl -arch=i386 ADL2_Graphics_VersionsX3_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_VersionsX3_Get(ptr long ptr)
+@ cdecl -arch=i386 ADL2_Graphics_Versions_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_Versions_Get(ptr ptr)
 @ stub ADL2_Graphics_VulkanVersion_Get
 @ stub ADL2_HybridGraphicsGPU_Set
 @ stub ADL2_MGPUSLS_Status_Set
@@ -450,9 +475,14 @@
 @ stub ADL2_MMD_VideoColor_Get
 @ stub ADL2_MMD_VideoColor_Set
 @ stub ADL2_MMD_Video_Caps
-@ stub ADL2_Main_ControlX2_Create
-@ stdcall ADL2_Main_Control_Create(ptr long ptr)
-@ stub ADL2_Main_Control_Destroy
+@ cdecl -arch=i386 ADL2_Main_ControlX3_Create(ptr long ptr long long)
+@ stdcall -arch=!i386 ADL2_Main_ControlX3_Create(ptr long ptr long long)
+@ cdecl -arch=i386 ADL2_Main_ControlX2_Create(ptr long ptr long)
+@ stdcall -arch=!i386 ADL2_Main_ControlX2_Create(ptr long ptr long)
+@ cdecl -arch=i386 ADL2_Main_Control_Create(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Main_Control_Create(ptr long ptr)
+@ cdecl -arch=i386 ADL2_Main_Control_Destroy(ptr)
+@ stdcall -arch=!i386 ADL2_Main_Control_Destroy(ptr)
 @ stub ADL2_Main_Control_GetProcAddress
 @ stub ADL2_Main_Control_IsFunctionValid
 @ stub ADL2_Main_Control_Refresh
@@ -478,7 +508,8 @@
 @ stub ADL2_Overdrive5_ThermalDevices_Enum
 @ stub ADL2_Overdrive6_AdvancedFan_Caps
 @ stub ADL2_Overdrive6_CapabilitiesEx_Get
-@ stub ADL2_Overdrive6_Capabilities_Get
+@ cdecl -arch=i386 ADL2_Overdrive6_Capabilities_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Overdrive6_Capabilities_Get(ptr long ptr)
 @ stub ADL2_Overdrive6_ControlI2C
 @ stub ADL2_Overdrive6_CurrentPower_Get
 @ stub ADL2_Overdrive6_CurrentStatus_Get
@@ -497,7 +528,8 @@
 @ stub ADL2_Overdrive6_PowerControl_Set
 @ stub ADL2_Overdrive6_StateEx_Get
 @ stub ADL2_Overdrive6_StateEx_Set
-@ stub ADL2_Overdrive6_StateInfo_Get
+@ cdecl -arch=i386 ADL2_Overdrive6_StateInfo_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Overdrive6_StateInfo_Get(ptr long long ptr)
 @ stub ADL2_Overdrive6_State_Reset
 @ stub ADL2_Overdrive6_State_Set
 @ stub ADL2_Overdrive6_TargetTemperatureData_Get
@@ -537,7 +569,8 @@
 @ stub ADL2_OverdriveN_MemoryClocks_Set
 @ stub ADL2_OverdriveN_MemoryTimingLevel_Get
 @ stub ADL2_OverdriveN_MemoryTimingLevel_Set
-@ stub ADL2_OverdriveN_PerformanceStatus_Get
+@ cdecl -arch=i386 ADL2_OverdriveN_PerformanceStatus_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_OverdriveN_PerformanceStatus_Get(ptr long ptr)
 @ stub ADL2_OverdriveN_PowerLimit_Get
 @ stub ADL2_OverdriveN_PowerLimit_Set
 @ stub ADL2_OverdriveN_SCLKAutoOverClock_Get
@@ -548,12 +581,14 @@
 @ stub ADL2_OverdriveN_SystemClocksX2_Set
 @ stub ADL2_OverdriveN_SystemClocks_Get
 @ stub ADL2_OverdriveN_SystemClocks_Set
-@ stub ADL2_OverdriveN_Temperature_Get
+@ cdecl -arch=i386 ADL2_OverdriveN_Temperature_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_OverdriveN_Temperature_Get(ptr long long ptr)
 @ stub ADL2_OverdriveN_Test_Set
 @ stub ADL2_OverdriveN_ThrottleNotification_Get
 @ stub ADL2_OverdriveN_ZeroRPMFan_Get
 @ stub ADL2_OverdriveN_ZeroRPMFan_Set
-@ stub ADL2_Overdrive_Caps
+@ cdecl -arch=i386 ADL2_Overdrive_Caps(ptr long ptr ptr ptr)
+@ stdcall -arch=!i386 ADL2_Overdrive_Caps(ptr long ptr ptr ptr)
 @ stub ADL2_PPLogSettings_Get
 @ stub ADL2_PPLogSettings_Set
 @ stub ADL2_PPW_Caps
@@ -681,14 +716,17 @@
 @ stub ADL_APO_AudioDelay_Set
 @ stub ADL_AdapterLimitation_Caps
 @ stub ADL_AdapterX2_Caps
-@ stdcall ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
+@ cdecl -arch=i386 ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
+@ stdcall -arch=!i386 ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
 @ stub ADL_Adapter_ASICInfo_Get
 @ stub ADL_Adapter_Accessibility_Get
 @ stub ADL_Adapter_Active_Get
 @ stub ADL_Adapter_Active_Set
 @ stub ADL_Adapter_Active_SetPrefer
-@ stub ADL_Adapter_AdapterInfoX2_Get
-@ stdcall ADL_Adapter_AdapterInfo_Get(ptr long)
+@ cdecl -arch=i386 ADL_Adapter_AdapterInfoX2_Get(ptr)
+@ stdcall -arch=!i386 ADL_Adapter_AdapterInfoX2_Get(ptr)
+@ cdecl -arch=i386 ADL_Adapter_AdapterInfo_Get(ptr long)
+@ stdcall -arch=!i386 ADL_Adapter_AdapterInfo_Get(ptr long)
 @ stub ADL_Adapter_AdapterList_Disable
 @ stub ADL_Adapter_Aspects_Get
 @ stub ADL_Adapter_AudioChannelSplitConfiguration_Get
@@ -714,8 +752,8 @@
 @ stub ADL_Adapter_CrossdisplayInfo_Get
 @ stub ADL_Adapter_CrossdisplayInfo_Set
 @ stub ADL_Adapter_CrossfireX2_Get
-@ stdcall ADL_Adapter_Crossfire_Caps(long ptr ptr ptr)
-@ stdcall ADL_Adapter_Crossfire_Get(long ptr ptr)
+@ stub ADL_Adapter_Crossfire_Caps(long ptr ptr ptr)
+@ stub ADL_Adapter_Crossfire_Get(long ptr ptr)
 @ stub ADL_Adapter_Crossfire_Set
 @ stub ADL_Adapter_DefaultAudioChannelTable_Load
 @ stub ADL_Adapter_DisplayAudioEndpoint_Enable
@@ -736,15 +774,18 @@
 @ stub ADL_Adapter_LocalDisplayState_Get
 @ stub ADL_Adapter_MaxCursorSize_Get
 @ stub ADL_Adapter_MemoryInfo2_Get
-@ stdcall ADL_Adapter_MemoryInfo_Get(long ptr)
+@ cdecl -arch=i386 ADL_Adapter_MemoryInfo_Get(long ptr)
+@ stdcall -arch=!i386 ADL_Adapter_MemoryInfo_Get(long ptr)
 @ stub ADL_Adapter_MirabilisSupport_Get
 @ stub ADL_Adapter_ModeSwitch
 @ stub ADL_Adapter_ModeTimingOverride_Caps
 @ stub ADL_Adapter_Modes_ReEnumerate
 @ stub ADL_Adapter_NumberOfActivatableSources_Get
-@ stdcall ADL_Adapter_NumberOfAdapters_Get(ptr)
-@ stdcall ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
-@ stub ADL_Adapter_ObservedGameClockInfo_Get
+@ cdecl -arch=i386 ADL_Adapter_NumberOfAdapters_Get(ptr)
+@ stdcall -arch=!i386 ADL_Adapter_NumberOfAdapters_Get(ptr)
+@ stub ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
+@ cdecl -arch=i386 ADL_Adapter_ObservedGameClockInfo_Get(ptr long ptr ptr ptr ptr)
+@ stdcall -arch=!i386 ADL_Adapter_ObservedGameClockInfo_Get(ptr long ptr ptr ptr ptr)
 @ stub ADL_Adapter_Primary_Get
 @ stub ADL_Adapter_Primary_Set
 @ stub ADL_Adapter_RegValueInt_Get
@@ -844,8 +885,10 @@
 @ stub ADL_Display_DisplayContent_Cap
 @ stub ADL_Display_DisplayContent_Get
 @ stub ADL_Display_DisplayContent_Set
-@ stdcall ADL_Display_DisplayInfo_Get(long long ptr long)
-@ stdcall ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
+@ cdecl -arch=i386 ADL_Display_DisplayInfo_Get(long long ptr long)
+@ stdcall -arch=!i386 ADL_Display_DisplayInfo_Get(long long ptr long)
+@ cdecl -arch=i386 ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
 @ stub ADL_Display_DisplayMapConfig_PossibleAddAndRemove
 @ stub ADL_Display_DisplayMapConfig_Set
 @ stub ADL_Display_DisplayMapConfig_Validate
@@ -853,7 +896,8 @@
 @ stub ADL_Display_DitherState_Set
 @ stub ADL_Display_Downscaling_Caps
 @ stub ADL_Display_DpMstInfo_Get
-@ stub ADL_Display_EdidData_Get
+@ cdecl -arch=i386 ADL_Display_EdidData_Get(long long ptr)
+@ stdcall -arch=!i386 ADL_Display_EdidData_Get(long long ptr)
 @ stub ADL_Display_EdidData_Set
 @ stub ADL_Display_EnumDisplays_Get
 @ stub ADL_Display_FilterSVideo_Get
@@ -890,7 +934,8 @@
 @ stub ADL_Display_ModeTimingOverride_Delete
 @ stub ADL_Display_ModeTimingOverride_Get
 @ stub ADL_Display_ModeTimingOverride_Set
-@ stub ADL_Display_Modes_Get
+@ cdecl -arch=i386 ADL_Display_Modes_Get(long long ptr ptr)
+@ stdcall -arch=!i386 ADL_Display_Modes_Get(long long ptr ptr)
 @ stub ADL_Display_Modes_Set
 @ stub ADL_Display_MonitorPowerState_Set
 @ stub ADL_Display_NativeAUXChannel_Access
@@ -932,11 +977,13 @@
 @ stub ADL_Display_SLSMapConfigX2_Get
 @ stub ADL_Display_SLSMapConfig_Create
 @ stub ADL_Display_SLSMapConfig_Delete
-@ stub ADL_Display_SLSMapConfig_Get
+@ cdecl -arch=i386 ADL_Display_SLSMapConfig_Get(long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL_Display_SLSMapConfig_Get(long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
 @ stub ADL_Display_SLSMapConfig_Rearrange
 @ stub ADL_Display_SLSMapConfig_SetState
 @ stub ADL_Display_SLSMapIndexList_Get
-@ stub ADL_Display_SLSMapIndex_Get
+@ cdecl -arch=i386 ADL_Display_SLSMapIndex_Get(long long ptr ptr)
+@ stdcall -arch=!i386 ADL_Display_SLSMapIndex_Get(long long ptr ptr)
 @ stub ADL_Display_SLSMiddleMode_Get
 @ stub ADL_Display_SLSMiddleMode_Set
 @ stub ADL_Display_SLSRecords_Get
@@ -969,8 +1016,10 @@
 @ stub ADL_Display_WriteAndReadI2CLargePayload
 @ stub ADL_Display_WriteAndReadI2CRev_Get
 @ stub ADL_Flush_Driver_Data
-@ stdcall ADL_Graphics_Platform_Get(ptr)
-@ stdcall ADL_Graphics_Versions_Get(ptr)
+@ cdecl -arch=i386 ADL_Graphics_Platform_Get(ptr)
+@ stdcall -arch=!i386 ADL_Graphics_Platform_Get(ptr)
+@ cdecl -arch=i386 ADL_Graphics_Versions_Get(ptr)
+@ stdcall -arch=!i386 ADL_Graphics_Versions_Get(ptr)
 @ stub ADL_MMD_FeatureList_Get
 @ stub ADL_MMD_FeatureValuesX2_Get
 @ stub ADL_MMD_FeatureValuesX2_Set
@@ -984,12 +1033,16 @@
 @ stub ADL_MMD_VideoColor_Get
 @ stub ADL_MMD_VideoColor_Set
 @ stub ADL_MMD_Video_Caps
-@ stub ADL_Main_ControlX2_Create
-@ stdcall ADL_Main_Control_Create(ptr long)
-@ stdcall ADL_Main_Control_Destroy()
+@ cdecl -arch=i386 ADL_Main_ControlX2_Create(ptr long long)
+@ stdcall -arch=!i386 ADL_Main_ControlX2_Create(ptr long long)
+@ cdecl -arch=i386 ADL_Main_Control_Create(ptr long)
+@ stdcall -arch=!i386 ADL_Main_Control_Create(ptr long)
+@ cdecl -arch=i386 ADL_Main_Control_Destroy()
+@ stdcall -arch=!i386 ADL_Main_Control_Destroy()
 @ stub ADL_Main_Control_GetProcAddress
 @ stub ADL_Main_Control_IsFunctionValid
-@ stub ADL_Main_Control_Refresh
+@ cdecl -arch=i386 ADL_Main_Control_Refresh()
+@ stdcall -arch=!i386 ADL_Main_Control_Refresh()
 @ stub ADL_Main_LogDebug_Set
 @ stub ADL_Main_LogError_Set
 @ stub ADL_Overdrive5_CurrentActivity_Get
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 9399025f94b..1c97b25962b 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -1,493 +1,1290 @@
-/* Headers: https://github.com/GPUOpen-LibrariesAndSDKs/display-library */
+/*
+ * atiadlxx implementation
+ *
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
 
 #include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
 
-#define COBJMACROS
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "windef.h"
 #include "winbase.h"
-#include "winuser.h"
-#include "objbase.h"
-#include "initguid.h"
+#include "winternl.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
 
-#include "dxgi.h"
-
-#define MAX_GPUS 64
-#define VENDOR_AMD 0x1002
-
-#define ADL_OK                            0
-#define ADL_ERR                          -1
-#define ADL_ERR_INVALID_PARAM            -3
-#define ADL_ERR_INVALID_ADL_IDX          -5
-#define ADL_ERR_NOT_SUPPORTED            -8
-#define ADL_ERR_NULL_POINTER             -9
+#include "wine/vulkan.h"
+#include "wine/asm.h"
 
-#define ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED            0x00000001
-#define ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED               0x00000002
-#define ADL_DISPLAY_DISPLAYINFO_MASK 0x31fff
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
 
-#define ADL_ASIC_DISCRETE    (1 << 0)
-#define ADL_ASIC_MASK        0xAF
+#include "dxgi1_6.h"
 
-enum ADLPlatForm
-{
-    GRAPHICS_PLATFORM_DESKTOP  = 0,
-    GRAPHICS_PLATFORM_MOBILE   = 1
-};
-#define GRAPHICS_PLATFORM_UNKNOWN -1
+#include "dxvk_interfaces.h"
 
+#include "unixlib.h"
 
-static IDXGIFactory *dxgi_factory;
+#include "amdheaders/adl_sdk.h"
+#include <wingdi.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(atiadlxx);
 
-BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
-{
-    TRACE("(%p, %u, %p)\n", instance, reason, reserved);
+#define AMD_VENDOR_ID 0x1002
 
-    switch (reason)
-    {
-    case DLL_PROCESS_ATTACH:
-        DisableThreadLibraryCalls(instance);
-        break;
-    }
+/* TODO split into multiple files */
 
-    return TRUE;
-}
+/* TODO: Switch adapter_descs to this structure */
+typedef struct _ADLAdapter {
+    DXGI_ADAPTER_DESC1 desc;
+    int monitor_index;
+} ADLAdapter;
 
-typedef void *(CALLBACK *ADL_MAIN_MALLOC_CALLBACK)(int);
-typedef void *ADL_CONTEXT_HANDLE;
-
-ADL_MAIN_MALLOC_CALLBACK adl_malloc;
-#define ADL_MAX_PATH 256
-
-typedef struct ADLVersionsInfo
-{
-    char strDriverVer[ADL_MAX_PATH];
-    char strCatalystVersion[ADL_MAX_PATH];
-    char strCatalystWebLink[ADL_MAX_PATH];
-} ADLVersionsInfo, *LPADLVersionsInfo;
-
-typedef struct ADLVersionsInfoX2
-{
-    char strDriverVer[ADL_MAX_PATH];
-    char strCatalystVersion[ADL_MAX_PATH];
-    char strCrimsonVersion[ADL_MAX_PATH];
-    char strCatalystWebLink[ADL_MAX_PATH];
-} ADLVersionsInfoX2, *LPADLVersionsInfoX2;
-
-typedef struct ADLAdapterInfo {
-    int iSize;
-    int iAdapterIndex;
-    char strUDID[ADL_MAX_PATH];
-    int iBusNumber;
-    int iDeviceNumber;
-    int iFunctionNumber;
-    int iVendorID;
-    char strAdapterName[ADL_MAX_PATH];
-    char strDisplayName[ADL_MAX_PATH];
-    int iPresent;
-    int iExist;
-    char strDriverPath[ADL_MAX_PATH];
-    char strDriverPathExt[ADL_MAX_PATH];
-    char strPNPString[ADL_MAX_PATH];
-    int iOSDisplayIndex;
-} ADLAdapterInfo, *LPADLAdapterInfo;
-
-typedef struct ADLDisplayID
-{
-    int iDisplayLogicalIndex;
-    int iDisplayPhysicalIndex;
-    int iDisplayLogicalAdapterIndex;
-    int iDisplayPhysicalAdapterIndex;
-} ADLDisplayID, *LPADLDisplayID;
-
-typedef struct ADLDisplayInfo
-{
-    ADLDisplayID displayID;
-    int  iDisplayControllerIndex;
-    char strDisplayName[ADL_MAX_PATH];
-    char strDisplayManufacturerName[ADL_MAX_PATH];
-    int  iDisplayType;
-    int  iDisplayOutputType;
-    int  iDisplayConnector;
-    int  iDisplayInfoMask;
-    int  iDisplayInfoValue;
-} ADLDisplayInfo, *LPADLDisplayInfo;
-
-typedef struct ADLCrossfireComb
-{
-    int iNumLinkAdapter;
-    int iAdaptLink[3];
-} ADLCrossfireComb;
-
-typedef struct ADLCrossfireInfo
-{
-  int iErrorCode;
-  int iState;
-  int iSupported;
-} ADLCrossfireInfo;
-
-typedef struct ADLMemoryInfo
-{
-    long long iMemorySize;
-    char strMemoryType[ADL_MAX_PATH];
-    long long iMemoryBandwidth;
-} ADLMemoryInfo, *LPADLMemoryInfo;
-
-typedef struct ADLDisplayTarget
-{
-    ADLDisplayID displayID;
-    int iDisplayMapIndex;
-    int iDisplayTargetMask;
-    int iDisplayTargetValue;
-} ADLDisplayTarget, *LPADLDisplayTarget;
-
-typedef struct ADLMode
-{
-    int iAdapterIndex;
-    ADLDisplayID displayID;
-    int iXPos;
-    int iYPos;
-    int iXRes;
-    int iYRes;
-    int iColourDepth;
-    float fRefreshRate;
-    int iOrientation;
-    int iModeFlag;
-    int iModeMask;
-    int iModeValue;
-} ADLMode, *LPADLMode;
-
-typedef struct ADLDisplayMap
-{
-    int iDisplayMapIndex;
-    ADLMode displayMode;
-    int iNumDisplayTarget;
-    int iFirstDisplayTargetArrayIndex;
-    int iDisplayMapMask;
-    int iDisplayMapValue;
-} ADLDisplayMap, *LPADLDisplayMap;
-
-static const ADLVersionsInfo version = {
+typedef struct _ADL_CONTEXT
+{
+    ADLThreadingModel model;
+    ADL_MAIN_MALLOC_CALLBACK callback;
+    IDXGIFactory1 *factory;
+    IDXGIVkInteropFactory1 *dxgi_interop;
+    DXGI_ADAPTER_DESC1 *adapter_descs;
+    BOOL adl1;
+    int monitor_count;
+    int adapter_count;
+    int enum_connected_adapters;
+} ADL_CONTEXT;
+
+static ADL_CONTEXT global_adl_context;
+
+static const ADLVersionsInfo global_versions_info =
+{
     "99.19.02-230831a-396538C-AMD-Software-Adrenalin-Edition",
-    "",
+    "99.10", /*BF4 reads this version*/
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
-static const ADLVersionsInfoX2 version2 = {
+static const ADLVersionsInfoX2 global_versions_infox2 =
+{
     "99.19.02-230831a-396538C-AMD-Software-Adrenalin-Edition",
-    "",
+    "99.10", /*BF4 reads this version*/
     "99.10.2",
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
-int WINAPI ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
+static void create_dxgi_factory(IDXGIFactory1 **factory)
 {
-    FIXME("cb %p, arg %d, ptr %p stub!\n", cb, arg, ptr);
+    static typeof(CreateDXGIFactory1) *pCreateDxgiFactory1 = NULL;
+
+    if (!pCreateDxgiFactory1)
+    {
+        HMODULE dxgi_module = LoadLibraryW( L"dxgi.dll" );
+        if (!dxgi_module)
+        {
+            ERR("Failed to load dxgi.dll\n");
+            return;
+        }
+
+        pCreateDxgiFactory1 = (void *)GetProcAddress(dxgi_module, "CreateDXGIFactory1");
+        if (!pCreateDxgiFactory1)
+        {
+            ERR("Failed to get CreateDXGIFactory1\n");
+            return;
+        }
+    }
+
+    if(FAILED(pCreateDxgiFactory1(&IID_IDXGIFactory1, (void **)factory)))
+    {
+        ERR("Failed to create IDXGIFactory1\n");
+        return;
+    }
+}
+
+static INIT_ONCE unix_init_once = INIT_ONCE_STATIC_INIT;
+static BOOL unix_lib_initialized;
+
+#define ATI_CALL(func, args) WINE_UNIX_CALL( unix_ ## func, args )
+
+#ifdef __i386__
+#define AMDAPI __cdecl
+#else
+#define AMDAPI __stdcall
+#endif
+
+static BOOL WINAPI init_unix_lib_once( INIT_ONCE *once, void *param, void **context )
+{
+    unix_lib_initialized = !__wine_init_unix_call() && !ATI_CALL( init, NULL );
+    return TRUE;
+}
+
+static BOOL init_unix_lib(void)
+{
+    InitOnceExecuteOnce( &unix_init_once, init_unix_lib_once, NULL, NULL );
+    return unix_lib_initialized;
+}
+
+static int WINAPI count_monitors(HMONITOR monitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)
+{
+    int *count = (int *)dwData;
+    (*count)++;
+    return TRUE;
+}
+
+static int init_context_descs(ADL_CONTEXT *context, int *num_adapters, DXGI_ADAPTER_DESC1 *descs)
+{
+    IDXGIAdapter1 *adapter = NULL;
+    DXGI_ADAPTER_DESC1 desc;
+    int i = 0;
+
+    TRACE("(%p, %p, %p)\n", context, num_adapters, descs);
+
+    if(!context)
+        return ADL_ERR;
+
+    for(; SUCCEEDED(IDXGIFactory1_EnumAdapters1(context->factory, i, &adapter)); i++)
+    {
+        IDXGIAdapter1_GetDesc1(adapter, &desc);
+
+        if(desc.VendorId != AMD_VENDOR_ID)
+            i--;
+        else if(descs)
+            descs[i] = desc;
+
+        IDXGIAdapter1_Release(adapter);
+    }
+
+    *num_adapters = i;
+
     return ADL_OK;
 }
 
-int WINAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
+static char* wchar_to_char(const WCHAR *src)
 {
-    FIXME("cb %p, arg %d stub!\n", cb, arg);
-    adl_malloc = cb;
+    int len = wcslen(src);
+    char *dst = calloc(len + 1, sizeof(char));
+    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, len, NULL, NULL);
 
+    return dst;
+}
 
-    if (SUCCEEDED(CreateDXGIFactory(&IID_IDXGIFactory, (void**) &dxgi_factory)))
-        return ADL_OK;
-    else
+int AMDAPI ADL2_Main_ControlX3_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADL_CONTEXT_HANDLE* context, ADLThreadingModel model, int options)
+{
+    ADL_CONTEXT *adl_context = NULL;
+    TRACE("(%p, %d, %p, %d, %d)\n", callback, enum_connected_adapters, context, model, options);
+
+    if (!init_unix_lib())
+    {
+        ERR("Failed to initialize unixlib\n");
+        return ADL_ERR;
+    }
+
+    adl_context = calloc(1, sizeof(ADL_CONTEXT));
+
+    adl_context->model = model;
+    adl_context->callback = callback;
+    adl_context->enum_connected_adapters = enum_connected_adapters;
+    adl_context->adl1 = false;
+
+    create_dxgi_factory(&adl_context->factory);
+
+    if(!adl_context->factory)
+    {
+        ERR("Failed to create IDXGIFactory1\n");
+        return ADL_ERR;
+    }
+
+    if(FAILED(IDXGIFactory1_QueryInterface(adl_context->factory, &IID_IDXGIVkInteropFactory1, (void **)&adl_context->dxgi_interop)))
+    {
+        ERR("Failed to get IDXGIVkInteropFactory1\n");
+        return ADL_ERR;
+    }
+
+    EnumDisplayMonitors(NULL, NULL, count_monitors, (LPARAM)&adl_context->monitor_count);
+
+    *context = adl_context;
+
+    init_context_descs(adl_context, &adl_context->adapter_count, NULL);
+
+    adl_context->adapter_descs = calloc(adl_context->adapter_count, sizeof(DXGI_ADAPTER_DESC1));
+
+    init_context_descs(adl_context, &adl_context->adapter_count, adl_context->adapter_descs);
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Main_ControlX2_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADL_CONTEXT_HANDLE* context, ADLThreadingModel model)
+{
+    return ADL2_Main_ControlX3_Create(callback, enum_connected_adapters, context, model, 0);
+}
+
+int AMDAPI ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADL_CONTEXT_HANDLE* context)
+{
+    return ADL2_Main_ControlX2_Create(callback, enum_connected_adapters, context, ADL_THREADING_UNLOCKED);
+}
+
+int AMDAPI ADL2_Main_Control_Destroy(ADL_CONTEXT *context)
+{
+    TRACE("(%p)\n", context);
+
+    if(!context)
         return ADL_ERR;
+
+    if(context->factory)
+        IDXGIFactory1_Release(context->factory);
+
+    if(context->dxgi_interop)
+        IDXGIVkInteropFactory1_Release(context->dxgi_interop);
+
+    free(context->adapter_descs);
+    free(context);
+
+    return ADL_OK;
 }
 
-int WINAPI ADL_Main_Control_Destroy(void)
+int AMDAPI ADL2_Main_Control_Refresh(ADL_CONTEXT *context)
 {
-    FIXME("stub!\n");
+    TRACE("(%p)\n", context);
 
-    if (dxgi_factory != NULL)
-        IUnknown_Release(dxgi_factory);
+    if(!context)
+        return ADL_ERR;
 
     return ADL_OK;
 }
 
-int WINAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
+int AMDAPI ADL_Main_ControlX2_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADLThreadingModel threadingModel)
 {
-    FIXME("ptr %p, count %p stub!\n", ptr, count);
+    TRACE("(%p, %d, %d)\n", callback, enum_connected_adapters, threadingModel);
+
+    if (!init_unix_lib())
+    {
+        ERR("Failed to initialize unixlib\n");
+        return ADL_ERR;
+    }
+
+    global_adl_context.model = threadingModel;
+    global_adl_context.callback = callback;
+    global_adl_context.enum_connected_adapters = enum_connected_adapters;
+    global_adl_context.adl1 = true;
+
+    EnumDisplayMonitors(NULL, NULL, count_monitors, (LPARAM)&global_adl_context.monitor_count);
+
+    create_dxgi_factory(&global_adl_context.factory);
+
+    if(!global_adl_context.factory)
+    {
+        ERR("Failed to create IDXGIFactory1\n");
+        return ADL_ERR;
+    }
+
+    if(FAILED(IDXGIFactory1_QueryInterface(global_adl_context.factory, &IID_IDXGIVkInteropFactory1, (void **)&global_adl_context.dxgi_interop)))
+    {
+        ERR("Failed to get IDXGIVkInteropFactory1\n");
+        return ADL_ERR;
+    }
+
+    init_context_descs(&global_adl_context, &global_adl_context.adapter_count, NULL);
 
-    *count = 0;
+    global_adl_context.adapter_descs = calloc(global_adl_context.adapter_count, sizeof(DXGI_ADAPTER_DESC1));
+
+    init_context_descs(&global_adl_context, &global_adl_context.adapter_count, global_adl_context.adapter_descs);
 
     return ADL_OK;
 }
 
-int WINAPI ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE *ptr, ADLVersionsInfoX2 *ver)
+int AMDAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters)
+{
+    return ADL_Main_ControlX2_Create(callback, enum_connected_adapters, ADL_THREADING_UNLOCKED);
+}
+
+int AMDAPI ADL_Main_Control_Refresh(void)
+{
+    return ADL2_Main_Control_Refresh(&global_adl_context);
+}
+
+int AMDAPI ADL_Main_Control_Destroy(void)
 {
-    FIXME("ptr %p, ver %p stub!\n", ptr, ver);
-    memcpy(ver, &version2, sizeof(version2));
+    TRACE("()\n");
+
+    if(global_adl_context.factory)
+        IDXGIFactory1_Release(global_adl_context.factory);
+
+    if(global_adl_context.dxgi_interop)
+        IDXGIVkInteropFactory1_Release(global_adl_context.dxgi_interop);
+
+    free(global_adl_context.adapter_descs);
+
     return ADL_OK;
 }
 
-int WINAPI ADL_Graphics_Versions_Get(ADLVersionsInfo *ver)
+int AMDAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT *context, int *num_adapters)
 {
-    FIXME("ver %p stub!\n", ver);
-    memcpy(ver, &version, sizeof(version));
+    TRACE("(%p, %p)\n", context, num_adapters);
+
+    if(!context || !num_adapters)
+        return ADL_ERR;
+
+    *num_adapters = context->adapter_count * context->monitor_count;
+
     return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_NumberOfAdapters_Get(int *count)
+static int convert_to_gen(uint32_t asic_family)
 {
-    IDXGIAdapter *adapter;
+    if(asic_family >= AsicFamily_RDNA)
+        return ADL_GRAPHIC_CORE_GENERATION_RDNA;
+    if(asic_family >= AsicFamily_GCN1)
+        return ADL_GRAPHIC_CORE_GENERATION_GCN;
+    if(asic_family == AsicFamily_PreGCN)
+        return ADL_GRAPHIC_CORE_GENERATION_PRE_GCN;
+
+    return ADL_GRAPHIC_CORE_GENERATION_UNDEFINED;
+}
+
+int AMDAPI ADL2_Adapter_Graphic_Core_Info_Get(ADL_CONTEXT *context, int index, ADLGraphicCoreInfo* info)
+{
+    struct get_device_info_params params = {0};
+    TRACE("(%p, %d, %p)\n", context, index, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    if(index >= context->adapter_count)
+        return ADL_ERR;
 
-    FIXME("count %p stub!\n", count);
+    params.device_id = context->adapter_descs[index].DeviceId;
 
-    *count = 0;
-    while (SUCCEEDED(IDXGIFactory_EnumAdapters(dxgi_factory, *count, &adapter)))
+    if(!ATI_CALL( get_device_info, &params ))
     {
-        (*count)++;
-        IUnknown_Release(adapter);
+        info->iNumCUs = params.num_cu;
+        info->iNumROPs = params.num_rops;
+        info->iNumWGPs = params.num_wgp;
+        info->iGCGen = convert_to_gen(params.asic_family);
+        return ADL_OK;
     }
 
-    TRACE("*count = %d\n", *count);
-    return ADL_OK;
+    return ADL_ERR;
 }
 
-static int get_adapter_desc(int adapter_index, DXGI_ADAPTER_DESC *desc)
+int AMDAPI ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT *context, ADLVersionsInfoX2 *versions_info)
 {
-    IDXGIAdapter *adapter;
-    HRESULT hr;
+    TRACE("(%p, %p)\n", context, versions_info);
 
-    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
+    if(!context || !versions_info)
         return ADL_ERR;
 
-    hr = IDXGIAdapter_GetDesc(adapter, desc);
+    *versions_info = global_versions_infox2;
 
-    IUnknown_Release(adapter);
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Graphics_VersionsX3_Get(ADL_CONTEXT *context, int adapter_idx, ADLVersionsInfoX2 *versions_nfo)
+{
+    FIXME("Ignoring adapter index %d\n", adapter_idx);
 
-    return SUCCEEDED(hr) ? ADL_OK : ADL_ERR;
+    return ADL2_Graphics_VersionsX2_Get(context, versions_nfo);
 }
 
-/* yep, seriously */
-static int convert_vendor_id(int id)
+int AMDAPI ADL2_Graphics_Versions_Get(ADL_CONTEXT *context, ADLVersionsInfo *versions_info)
 {
-    char str[16];
-    snprintf(str, ARRAY_SIZE(str), "%x", id);
-    return atoi(str);
+    TRACE("(%p, %p)\n", context, versions_info);
+
+    if(!context || !versions_info)
+        return ADL_ERR;
+
+    *versions_info = global_versions_info;
+
+    return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
+int AMDAPI ADL_Graphics_Versions_Get(ADLVersionsInfo *versions_info)
 {
-    int count, i;
-    DXGI_ADAPTER_DESC adapter_desc;
+    return ADL2_Graphics_Versions_Get(&global_adl_context, versions_info);
+}
 
-    FIXME("adapters %p, input_size %d, stub!\n", adapters, input_size);
+int AMDAPI ADL2_Graphics_Platform_Get(ADL_CONTEXT *context, int *platform)
+{
+    FIXME("(%p) stub\n", platform);
 
-    ADL_Adapter_NumberOfAdapters_Get(&count);
+    if(!platform || !context)
+        return ADL_ERR;
 
-    if (!adapters) return ADL_ERR_INVALID_PARAM;
-    if (input_size != count * sizeof(ADLAdapterInfo)) return ADL_ERR_INVALID_PARAM;
+    *platform = GRAPHICS_PLATFORM_DESKTOP;
 
-    memset(adapters, 0, input_size);
+    return ADL_OK;
+}
 
-    for (i = 0; i < count; i++)
+int AMDAPI ADL_Graphics_Platform_Get(int *platform)
+{
+    return ADL2_Graphics_Platform_Get(&global_adl_context, platform);
+}
+
+int AMDAPI ADL2_Graphics_IsGfx9AndAbove(ADL_CONTEXT *context)
+{
+    struct get_device_info_params params = {0};
+    TRACE("(%p)\n", context);
+
+    if(!context)
+        return ADL_ERR;
+
+    params.device_id = context->adapter_descs[0].DeviceId;
+
+    if(!ATI_CALL( get_device_info, &params ))
     {
-        adapters[i].iSize = sizeof(ADLAdapterInfo);
-        adapters[i].iAdapterIndex = i;
+        return params.asic_family >= AsicFamily_Vega;
+    }
 
-        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
-            return ADL_ERR;
+    return FALSE;
+}
+
+int AMDAPI ADL2_Adapter_AdapterInfo_Get(ADL_CONTEXT *context, AdapterInfo *info, int size)
+{
+    TRACE("(%p, %p, %d)\n", context, info, size);
+
+    size /= sizeof(AdapterInfo);
 
-        adapters[i].iVendorID = convert_vendor_id(adapter_desc.VendorId);
+    if(!context || !info)
+        return ADL_ERR;
+
+    for(int l = 0; l < size; l++)
+    {
+        if(context->adapter_descs[l].VendorId == AMD_VENDOR_ID)
+        {
+            char strUDID[256];
+            char *dst;
+            info[l].iSize = sizeof(AdapterInfo);
+            info[l].iAdapterIndex = l;
+            info[l].iVendorID = AMD_VENDOR_ID;
+            info[l].iBusNumber = context->adapter_descs[l].DeviceId;
+            strcpy(info[l].strDisplayName, "\\\\.\\DISPLAY1");
+            sprintf(strUDID, "PCI\\VEN_%04X&DEV_%04X&REV_%02X", context->adapter_descs[l].VendorId, context->adapter_descs[l].DeviceId, 0);
+            strcpy(info[l].strUDID, strUDID);
+            info[l].iPresent = 1;
+            info[l].iExist = 1;
+            info[l].iDeviceNumber = l;
+            dst = wchar_to_char(context->adapter_descs[l].Description);
+            strcpy(info[l].strAdapterName, dst);
+            TRACE("added adapter %s\n", dst);
+            free(dst);
+        }
     }
 
     return ADL_OK;
 }
 
-int WINAPI ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
+int AMDAPI ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT *context, AdapterInfo **info)
 {
-    IDXGIAdapter *adapter;
-    IDXGIOutput *output;
-    int i;
+    TRACE("(%p, %p)\n", context, info);
+
+    if(!context || !info)
+        return ADL_ERR;
 
-    FIXME("adapter %d, num_displays %p, info %p stub!\n", adapter_index, num_displays, info);
+    *info = (AdapterInfo*)context->callback(sizeof(AdapterInfo) * context->adapter_count);
 
-    if (info == NULL || num_displays == NULL) return ADL_ERR_NULL_POINTER;
+    if(!*info)
+        return ADL_ERR;
+
+    memset(*info, 0, sizeof(AdapterInfo) * context->adapter_count);
+
+    return ADL2_Adapter_AdapterInfo_Get(context, *info, sizeof(AdapterInfo) * context->adapter_count);
+}
 
-    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
-        return ADL_ERR_INVALID_PARAM;
+int AMDAPI ADL_Adapter_ObservedGameClockInfo_Get(ADL_CONTEXT *context, int index, int *base, int *game, int *boost, int *memory)
+{
+    struct get_device_info_params params = {0};
+    FIXME("(%p, %d, %p, %p, %p, %p) semi-stub\n", context, index, base, game, boost, memory);
+
+    if(!context || !base || !game || !boost || !memory)
+        return ADL_ERR;
 
-    *num_displays = 0;
+    params.device_id = context->adapter_descs[index].DeviceId;
 
-    while (SUCCEEDED(IDXGIAdapter_EnumOutputs(adapter, *num_displays, &output)))
+    if(!ATI_CALL( get_device_info, &params ))
     {
-        (*num_displays)++;
-        IUnknown_Release(output);
+        *base = params.min_core_clock;
+        *game = params.core_clock;
+        *boost = params.core_clock;
+        *memory = params.memory_clock;
+        return ADL_OK;
     }
 
-    IUnknown_Release(adapter);
+    return ADL_ERR;
+}
+
+int AMDAPI ADL2_Adapter_MemoryInfo_Get(ADL_CONTEXT *context, int index, ADLMemoryInfo *info)
+{
+    struct get_device_info_params params = {0};
+    TRACE("(%p, %d, %p)\n", context, index, info);
+
+    if(!context || !info)
+        return ADL_ERR;
 
-    if (*num_displays == 0)
+    params.device_id = context->adapter_descs[index].DeviceId;
+
+    if(!ATI_CALL( get_device_info, &params ))
+    {
+        info->iMemorySize = context->adapter_descs[index].DedicatedVideoMemory;
+        info->iMemoryBandwidth = params.memory_bandwidth;
+        strcpy(info->strMemoryType, "GDDR6");
         return ADL_OK;
+    }
+
+    return ADL_ERR;
+}
 
-    *info = adl_malloc(*num_displays * sizeof(**info));
-    memset(*info, 0, *num_displays * sizeof(**info));
+int AMDAPI ADL2_Display_DisplayInfo_Get(ADL_CONTEXT *context, int index, int *displays, ADLDisplayInfo **infos, int force_detect)
+{
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    IDXGIAdapter1 *adapter = NULL;
+    IDXGIOutput *output = NULL;
+    HRESULT res;
+    TRACE("(%p, %d, %p, %p, %d)\n", context, index, displays, infos, force_detect);
+
+    if(!context || !displays || !infos)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+
+    res = IDXGIFactory1_EnumAdapters1(context->factory, index, &adapter);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIAdapter1\n");
+        return ADL_ERR;
+    }
+
+    res = IDXGIAdapter1_EnumOutputs(adapter, 0, &output);
 
-    for (i = 0; i < *num_displays; i++)
+    if(FAILED(res))
     {
-        (*info)[i].displayID.iDisplayLogicalIndex = i;
-        (*info)[i].iDisplayInfoValue = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
-        (*info)[i].iDisplayInfoMask = (*info)[i].iDisplayInfoValue;
+        ERR("Failed to get IDXGIOutput\n");
+        return ADL_ERR;
+    }
+
+    IDXGIAdapter1_Release(adapter);
+    IDXGIOutput_Release(output);
+
+    *displays = context->monitor_count;
+    *infos = context->callback(sizeof(ADLDisplayInfo) * context->monitor_count);
+
+    if(!*infos)
+        return ADL_ERR;
+
+    devmode.dmSize = sizeof(DEVMODEA);
+
+    for(int i = 0; i < context->monitor_count; i++)
+    {
+        ADLDisplayInfo* info = (*infos) + i;
+
+        EnumDisplayDevicesA(NULL, i, &dispdev, 0);
+
+        EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+        info->displayID.iDisplayLogicalAdapterIndex = index;
+        info->displayID.iDisplayLogicalIndex = i;
+        info->displayID.iDisplayPhysicalAdapterIndex = index;
+        info->displayID.iDisplayPhysicalIndex = i;
+
+        strcpy(info->strDisplayName, dispdev.DeviceString);
+        /* FIXME */
+        strcpy(info->strDisplayManufacturerName, "Samsung");
+        info->iDisplayConnector = ADL_DISPLAY_CONTYPE_DISPLAYPORT;
+        info->iDisplayControllerIndex = 0;
+        info->iDisplayInfoMask = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
+        info->iDisplayInfoValue = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
+        info->iDisplayOutputType = ADL_DT_LCD_PANEL;
+        /* FIXME */
+        info->iDisplayOutputType = 0;
     }
 
     return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
+int AMDAPI ADL2_Display_Modes_Get(ADL_CONTEXT *context, int index, int display, int *num_modes, ADLMode **modes)
 {
-    FIXME("adapter %d, preffered %p, num_comb %p, comb %p stub!\n", adapter_index, preffered, num_comb, comb);
-    return ADL_ERR;
+    IDXGIAdapter1 *adapter = NULL;
+    IDXGIOutput *output = NULL;
+    uint32_t num_modes_dxgi;
+    HRESULT res;
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    DXGI_MODE_DESC *modes_dxgi = NULL;
+    TRACE("(%p, %d, %d, %p, %p)\n", context, index, display, num_modes, modes);
+
+    if(!context || !num_modes || !modes)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+    if(display == -1)
+        display = 0;
+
+    res = IDXGIFactory1_EnumAdapters1(context->factory, index, &adapter);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIAdapter1\n");
+        return ADL_ERR;
+    }
+
+    res = IDXGIAdapter1_EnumOutputs(adapter, display, &output);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIOutput\n");
+        return ADL_ERR;
+    }
+
+    res = IDXGIOutput_GetDisplayModeList(output, DXGI_FORMAT_R8G8B8A8_UNORM, 0, &num_modes_dxgi, NULL);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get display mode list\n");
+        return ADL_ERR;
+    }
+
+    modes_dxgi = calloc(num_modes_dxgi, sizeof(DXGI_MODE_DESC));
+
+    res = IDXGIOutput_GetDisplayModeList(output, DXGI_FORMAT_R8G8B8A8_UNORM, 0, &num_modes_dxgi, modes_dxgi);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get display mode list\n");
+        return ADL_ERR;
+    }
+
+    if(!modes_dxgi)
+        return ADL_ERR;
+
+    *num_modes = num_modes_dxgi;
+    *modes = (ADLMode*)context->callback(sizeof(ADLMode) * num_modes_dxgi);
+
+    if(!*modes)
+    {
+        free(modes_dxgi);
+        return ADL_ERR;
+    }
+
+    EnumDisplayDevicesA(NULL, display, &dispdev, 0);
+
+    EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+    for(uint32_t i = 0; i < num_modes_dxgi; i++)
+    {
+        ADLMode *mode = (*modes) + (num_modes_dxgi - i - 1);
+        mode->fRefreshRate = (float)modes_dxgi[i].RefreshRate.Numerator / (float)modes_dxgi[i].RefreshRate.Denominator;
+        mode->iColourDepth = devmode.dmBitsPerPel;
+        mode->iAdapterIndex = index;
+        mode->iXPos = devmode.dmPosition.x;
+        mode->iYPos = devmode.dmPosition.y;
+        mode->iXRes = modes_dxgi[i].Width;
+        mode->iYRes = modes_dxgi[i].Height;
+        mode->iOrientation = devmode.dmOrientation * 90;
+        mode->iModeFlag = modes_dxgi[i].ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE ?
+                                        ADL_DISPLAY_MODE_PROGRESSIVE_FLAG : ADL_DISPLAY_MODE_INTERLACED_FLAG;
+        /* FIXME */
+        mode->iModeMask = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+        mode->iModeValue = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+
+        mode->displayID.iDisplayLogicalAdapterIndex = index;
+        mode->displayID.iDisplayLogicalIndex = i;
+        mode->displayID.iDisplayPhysicalAdapterIndex = index;
+        mode->displayID.iDisplayPhysicalIndex = i;
+    }
+
+    free(modes_dxgi);
+    IDXGIAdapter1_Release(adapter);
+    IDXGIOutput_Release(output);
+
+    return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_Crossfire_Get(int adapter_index, ADLCrossfireComb *comb, ADLCrossfireInfo *info)
+int AMDAPI ADL_Display_Modes_Get(int index, int display, int *num_modes, ADLMode **modes)
 {
-    FIXME("adapter %d, comb %p, info %p, stub!\n", adapter_index, comb, info);
-    return ADL_ERR;
+    return ADL2_Display_Modes_Get(&global_adl_context, index, display, num_modes, modes);
+}
+
+static int convert_colorspace(DXGI_COLOR_SPACE_TYPE type)
+{
+    switch(type)
+    {
+        case DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709:
+            return ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888;
+        default: /* FIXME */
+            FIXME("unknown colorspace %#x\n", type);
+            return ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888;
+    }
 }
 
-int WINAPI ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int *valids)
+int AMDAPI ADL2_Display_FreeSync_Cap(ADL_CONTEXT *context, int index, int display, ADLFreeSyncCap *caps)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    FIXME("(%p, %d, %d, %p) stub! faking freesync support\n", context, index, display, caps);
+
+    if(!context || !caps)
+        return ADL_ERR;
 
-    FIXME("adapter %d, asic_type %p, valids %p, stub!\n", adapter_index, asic_type, valids);
+    if(index == -1)
+        index = 0;
 
-    if (asic_type == NULL || valids == NULL)
-        return  ADL_ERR_NULL_POINTER;
+    if(display == -1)
+        display = 0;
 
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK)
-        return ADL_ERR_INVALID_ADL_IDX;
+    EnumDisplayDevicesA(NULL, display, &dispdev, 0);
 
-    if (adapter_desc.VendorId != VENDOR_AMD)
-        return ADL_ERR_NOT_SUPPORTED;
+    EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
 
-    *asic_type = ADL_ASIC_DISCRETE;
-    *valids = ADL_ASIC_MASK;
+    caps->iCaps = ADL_FREESYNC_CAP_SUPPORTED | ADL_FREESYNC_CAP_CURRENTMODESUPPORTED | ADL_FREESYNC_CAP_GPUSUPPORTED;
+    caps->iMaxRefreshRateInMicroHz = devmode.dmDisplayFrequency * 1000000;
+    caps->iMinRefreshRateInMicroHz = devmode.dmDisplayFrequency * 1000000;
+    caps->ucLabelIndex = ADL_FREESYNC_LABEL_FREESYNC_PREMIUM_PRO;
 
     return ADL_OK;
 }
 
-static int get_max_clock(const char *clock, int default_value)
+int AMDAPI ADL2_Display_DDCInfo2_Get(ADL_CONTEXT *context, int index, int display, ADLDDCInfo2 *info)
 {
-    char path[MAX_PATH], line[256];
-    FILE *file;
-    int drm_card, value = 0;
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    IDXGIOutput* output = NULL;
+    IDXGIOutput6 *output6 = NULL;
+    IDXGIAdapter1 *adapter = NULL;
+    ADLFreeSyncCap caps;
+    DXGI_OUTPUT_DESC1 desc;
+    HRESULT res;
+    TRACE("(%p, %d, %d, %p)\n", context, index, display, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+
+    if(display == -1)
+        display = 0;
+
+    EnumDisplayDevicesA(NULL, display, &dispdev, 0);
 
-    for (drm_card = 0; drm_card < MAX_GPUS; drm_card++)
+    EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+    res = IDXGIFactory1_EnumAdapters1(context->factory, index, &adapter);
+
+    if(FAILED(res))
     {
-        sprintf(path, "/sys/class/drm/card%d/device/pp_dpm_%s", drm_card, clock);
-        file = fopen(path, "r");
+        ERR("Failed to get IDXGIAdapter1\n");
+        return ADL_ERR;
+    }
 
-        if (file == NULL)
-            continue;
+    res = IDXGIAdapter1_EnumOutputs(adapter, display, &output);
 
-        while (fgets(line, sizeof(line), file) != NULL)
-        {
-            char *number;
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIOutput\n");
+        return ADL_ERR;
+    }
 
-            number = strchr(line, ' ');
-            if (number == NULL)
-            {
-                WARN("pp_dpm_%s file has unexpected format\n", clock);
-                break;
-            }
+    res = IDXGIOutput_QueryInterface(output, &IID_IDXGIOutput6, (void **)&output6);
 
-            number++;
-            value = max(strtol(number, NULL, 0), value);
-        }
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIOutput6\n");
+        return ADL_ERR;
     }
 
-    if (value != 0)
-        return value;
+    res = IDXGIOutput6_GetDesc1(output6, &desc);
 
-    return default_value;
+    if(FAILED(res))
+    {
+        ERR("Failed to get output description\n");
+        return ADL_ERR;
+    }
+
+    memset(info, 0, sizeof(ADLDDCInfo2));
+
+    info->iNativeDisplayChromaticityBlueX = desc.BluePrimary[0];
+    info->iNativeDisplayChromaticityBlueY = desc.BluePrimary[1];
+    info->iNativeDisplayChromaticityGreenX = desc.GreenPrimary[0];
+    info->iNativeDisplayChromaticityGreenY = desc.GreenPrimary[1];
+    info->iNativeDisplayChromaticityRedX = desc.RedPrimary[0];
+    info->iNativeDisplayChromaticityRedY = desc.RedPrimary[1];
+    info->iNativeDisplayChromaticityWhitePointX = desc.WhitePoint[0];
+    info->iNativeDisplayChromaticityWhitePointY = desc.WhitePoint[1];
+
+    ADL2_Display_FreeSync_Cap(context, index, display, &caps);
+
+    TRACE("output_desc.ColorSpace %#x.\n", desc.ColorSpace);
+    if (desc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020)
+    {
+        TRACE("Reporting monitor %s as HDR10 supported.\n", debugstr_a((char*)devmode.dmDeviceName));
+        /* FIXME check if freesync is supported */
+        info->iSupportedHDR = ADL_HDR_CEA861_3;
+
+        if(caps.iCaps & ADL_FREESYNC_CAP_SUPPORTED)
+            info->iSupportedHDR |= ADL_HDR_FREESYNC_HDR;
+    }
+
+    /* FIXME */
+    info->iFreesyncFlags = caps.iCaps;
+
+    info->ulMaxRefresh = devmode.dmDisplayFrequency;
+    info->ulPTMRefreshRate = devmode.dmDisplayFrequency;
+    info->ulPTMCx = devmode.dmPelsWidth;
+    info->ulPTMCy = devmode.dmPelsHeight;
+    info->ulMaxVResolution = devmode.dmPelsHeight;
+    info->ulMaxHResolution = devmode.dmPelsWidth;
+    strcpy(info->cDisplayName, (char*)devmode.dmDeviceName);
+
+    info->iPanelPixelFormat = convert_colorspace(desc.ColorSpace);
+
+    info->ulSupportsDDC = 1;
+    info->ulSize = sizeof(ADLDDCInfo2);
+    info->ulMinLuminanceData = desc.MinLuminance;
+    info->ulMaxLuminanceData = desc.MaxLuminance;
+    info->ulAvgLuminanceData = desc.MaxFullFrameLuminance;
+
+    IDXGIAdapter1_Release(adapter);
+    IDXGIOutput_Release(output);
+
+    /* TODO add the rest of the data */
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Display_DisplayMapConfig_Get(ADL_CONTEXT *context, int index, int *num_display_maps, ADLDisplayMap **display_maps,
+                                                        int *num_display_target, ADLDisplayTarget **display_target, int options)
+{
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    FIXME("(%p, %d, %p, %p, %p, %p, %d) semi-stub\n", context, index, num_display_maps, display_maps, num_display_target, display_target, options);
+
+    if(!context || !num_display_maps || !display_maps || !num_display_target || !display_target)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+
+    if(options > 1)
+        FIXME("options %#x not supported\n", options);
+
+
+    *num_display_maps = context->monitor_count;
+    *num_display_target = context->monitor_count;
+
+    *display_maps = context->callback(sizeof(ADLDisplayMap) * context->monitor_count);
+    *display_target = context->callback(sizeof(ADLDisplayTarget) * context->monitor_count);
+
+    for(int i = 0; i < context->monitor_count; i++)
+    {
+        ADLDisplayMap *map = (*display_maps) + i;
+        ADLDisplayTarget *target = (*display_target) + i;
+        ADLMode mode;
+
+        EnumDisplayDevicesA(NULL, i, &dispdev, 0);
+        EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+        map->iDisplayMapIndex = i;
+        map->iNumDisplayTarget = 1;
+        map->iFirstDisplayTargetArrayIndex = i;
+
+        mode.displayID.iDisplayLogicalAdapterIndex = index;
+        mode.displayID.iDisplayLogicalIndex = i;
+        mode.displayID.iDisplayPhysicalAdapterIndex = index;
+        mode.displayID.iDisplayPhysicalIndex = i;
+
+        mode.fRefreshRate = (float)devmode.dmDisplayFrequency;
+        mode.iColourDepth = devmode.dmBitsPerPel;
+        mode.iAdapterIndex = index;
+        mode.iXPos = devmode.dmPosition.x;
+        mode.iYPos = devmode.dmPosition.y;
+        mode.iXRes = devmode.dmPelsWidth;
+        mode.iYRes = devmode.dmPelsHeight;
+        mode.iOrientation = devmode.dmOrientation * 90;
+        mode.iModeFlag = ADL_DISPLAY_MODE_PROGRESSIVE_FLAG;
+        /* FIXME */
+        mode.iModeMask = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+        mode.iModeValue = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+
+        map->displayMode = mode;
+        map->iDisplayMapMask = ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE;
+        map->iDisplayMapValue = ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE;
+
+        target->displayID.iDisplayLogicalAdapterIndex = index;
+        target->displayID.iDisplayLogicalIndex = i;
+        target->displayID.iDisplayPhysicalAdapterIndex = index;
+        target->displayID.iDisplayPhysicalIndex = i;
+
+        target->iDisplayMapIndex = i;
+        target->iDisplayTargetMask = ADL_DISPLAY_DISPLAYTARGET_PREFERRED;
+        target->iDisplayTargetValue = i == 0 ? ADL_DISPLAY_DISPLAYTARGET_PREFERRED : 0;
+    }
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_DisplayMapConfig_Get(int index, int *num_display_maps, ADLDisplayMap **display_maps,
+                                                        int *num_display_target, ADLDisplayTarget **display_target, int options)
+{
+    return ADL2_Display_DisplayMapConfig_Get(&global_adl_context, index, num_display_maps, display_maps, num_display_target, display_target, options);
 }
 
-/* documented in the "Linux Specific APIs" section, present and used on Windows */
-/* the name and documentation suggests that this returns current freqs, but it's actually max */
-int WINAPI ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock, int *memory_clock)
+int AMDAPI ADL_Display_DisplayInfo_Get(int index, int *num_displays, ADLDisplayInfo **infos, int force_detect)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
+    return ADL2_Display_DisplayInfo_Get(&global_adl_context, index, num_displays, infos, force_detect);
+}
+
+int AMDAPI ADL_Adapter_AdapterInfo_Get(AdapterInfo *info, int size)
+{
+    return ADL2_Adapter_AdapterInfo_Get(&global_adl_context, info, size);
+}
+
+int AMDAPI ADL_Adapter_AdapterInfoX2_Get(AdapterInfo **info)
+{
+    return ADL2_Adapter_AdapterInfoX2_Get(&global_adl_context, info);
+}
+
+int AMDAPI ADL_Adapter_MemoryInfo_Get(int index, ADLMemoryInfo *info)
+{
+    return ADL2_Adapter_MemoryInfo_Get(&global_adl_context, index, info);
+}
+
+int AMDAPI ADL_Adapter_NumberOfAdapters_Get(int *num_adapters)
+{
+    return ADL2_Adapter_NumberOfAdapters_Get(&global_adl_context, num_adapters);
+}
+
+int AMDAPI ADL2_Adapter_ASICFamilyType_Get(ADL_CONTEXT *context, int index, int *asic_types, int *valids)
+{
+    struct get_device_info_params params = {0};
+    FIXME("(%p, %d, %p, %p) semi-stub\n", context, index, asic_types, valids);
+
+    if(!context || !asic_types || !valids)
+        return ADL_ERR;
+
+    if(context->adapter_descs[index].VendorId != AMD_VENDOR_ID)
+        return ADL_ERR;
+
+    params.device_id = context->adapter_descs[index].DeviceId;
 
-    FIXME("adapter %d, core_clock %p, memory_clock %p, stub!\n", adapter_index, core_clock, memory_clock);
+    if(ATI_CALL( get_device_info, &params ))
+        return ADL_ERR;
+
+    *asic_types = params.is_apu ? ADL_ASIC_INTEGRATED : ADL_ASIC_DISCRETE;
+    *valids = 0xAF; /* ADL_ASIC_MASK */
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Adapter_ASICFamilyType_Get(int index, int *asic_types, int *valids)
+{
+    return ADL2_Adapter_ASICFamilyType_Get(&global_adl_context, index, asic_types, valids);
+}
 
-    if (core_clock == NULL || memory_clock == NULL) return ADL_ERR;
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
-    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR_INVALID_ADL_IDX;
+int AMDAPI ADL2_Overdrive_Caps(ADL_CONTEXT *context, int index, int *supported, int *enabled, int *version)
+{
+    FIXME("(%p, %d, %p, %p, %p) stub\n", context, index, supported, enabled, version);
 
-    /* default values based on RX580 */
-    *core_clock = get_max_clock("sclk", 1350);
-    *memory_clock = get_max_clock("mclk", 2000);
+    if(!context || !supported || !enabled || !version)
+        return ADL_ERR;
 
-    TRACE("*core_clock: %i, *memory_clock %i\n", *core_clock, *memory_clock);
+    *supported = ADL_TRUE;
+    *enabled = ADL_FALSE;
+    *version = 6;
 
     return ADL_OK;
 }
 
-/* documented in the "Linux Specific APIs" section, present and used on Windows */
-int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
+int AMDAPI ADL2_Overdrive6_Capabilities_Get(ADL_CONTEXT *context, int index, ADLOD6Capabilities *caps)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
+    int base, game, boost, memory;
+    FIXME("(%p, %d, %p) semi-stub\n", context, index, caps);
 
-    FIXME("adapter %d, mem_info %p stub!\n", adapter_index, mem_info);
+    if(!context || !caps)
+        return ADL_ERR;
 
-    if (mem_info == NULL) return ADL_ERR_NULL_POINTER;
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
-    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR;
 
-    mem_info->iMemorySize = adapter_desc.DedicatedVideoMemory;
-    mem_info->iMemoryBandwidth = 256000; /* not exposed on Linux, probably needs a lookup table */
+    caps->iCapabilities = ADL_OD6_CAPABILITY_POWER_CONTROL | ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION |
+                             ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR | ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION;
+    caps->iNumberOfPerformanceLevels = 2;
+    caps->iExtMask = 0;
+    caps->iExtValue = 0;
+    ADL_Adapter_ObservedGameClockInfo_Get(context, index, &base, &game, &boost, &memory);
+    caps->iSupportedStates = ADL_OD6_SUPPORTEDSTATE_PERFORMANCE;
+    caps->sEngineClockRange.iMax = game;
+    caps->sEngineClockRange.iMin = base;
+    caps->sMemoryClockRange.iMax = memory;
+    caps->sMemoryClockRange.iMin = 100; /* assume 100 is base */
 
-    TRACE("iMemoryBandwidth %s, iMemorySize %s\n",
-            wine_dbgstr_longlong(mem_info->iMemoryBandwidth),
-            wine_dbgstr_longlong(mem_info->iMemorySize));
     return ADL_OK;
 }
 
-int WINAPI ADL_Graphics_Platform_Get(int *platform)
+int AMDAPI ADL2_Overdrive6_StateInfo_Get(ADL_CONTEXT *context, int index, int type, ADLOD6StateInfo *info)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
-    int count, i;
+    int base, game, boost, memory;
+    FIXME("(%p, %d, %d, %p) semi-stub\n", context, index, type, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    info->iExtMask = 0;
+    info->iExtValue = 0;
+    info->iNumberOfPerformanceLevels = 2;
+    ADL_Adapter_ObservedGameClockInfo_Get(context, index, &base, &game, &boost, &memory);
+    /* assume caller allocated the struct in the correct way */
+    info->aLevels[0].iEngineClock = base;
+    info->aLevels[0].iMemoryClock = 100; /* assume 100 is base */
+    info->aLevels[1].iEngineClock = game;
+    info->aLevels[1].iMemoryClock = memory;
 
-    FIXME("platform %p, stub!\n", platform);
+    return ADL_OK;
+}
 
-    *platform = GRAPHICS_PLATFORM_UNKNOWN;
+int AMDAPI ADL2_Adapter_AdapterInfoX4_Get(ADL_CONTEXT *context, int index, int *num_adapters, AdapterInfoX2 **info)
+{
+    AdapterInfoX2 *info2;
+    char *dst;
+    TRACE("(%p, %d, %p, %p)\n", context, index, num_adapters, info);
 
-    ADL_Adapter_NumberOfAdapters_Get(&count);
 
-    for (i = 0; i < count; i ++)
+    if(index == -1)
     {
-        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
-            continue;
+        *num_adapters = context->adapter_count;
+        *info = context->callback(sizeof(AdapterInfoX2) * context->adapter_count);
+
+        if(!*info)
+            return ADL_ERR;
+
+        info2 = *info;
+
+        for(int i = 0; i < context->adapter_count; i++)
+        {
+            info2[i].iSize = sizeof(AdapterInfoX2);
+            info2[i].iAdapterIndex = i;
+            info2[i].iPresent = 1;
+            info2[i].iExist = 1;
+            dst = wchar_to_char(context->adapter_descs[index].Description);
+            strcpy(info2->strAdapterName, dst);
+            free(dst);
+            info2[i].iVendorID = AMD_VENDOR_ID;
+            info2[i].iBusNumber = context->adapter_descs[i].DeviceId;
+            info2[i].iDeviceNumber = i;
+        }
 
-        if (adapter_desc.VendorId == VENDOR_AMD)
-            *platform = GRAPHICS_PLATFORM_DESKTOP;
+        return ADL_OK;
     }
 
-    /* NOTE: The real value can be obtained by doing:
-     * 1. ioctl(DRM_AMDGPU_INFO) with AMDGPU_INFO_DEV_INFO - dev_info.ids_flags & AMDGPU_IDS_FLAGS_FUSION
-     * 2. VkPhysicalDeviceType() if we ever want to use Vulkan directly
-     */
+    *info = context->callback(sizeof(AdapterInfoX2));
+
+    if(!*info)
+        return ADL_ERR;
+
+    info2 = *info;
+
+    memset(info2, 0, sizeof(AdapterInfoX2));
+
+    info2->iSize = sizeof(AdapterInfoX2);
+    info2->iAdapterIndex = index;
+    info2->iPresent = 1;
+    info2->iExist = 1;
+    info2->iDeviceNumber = index;
+    dst = wchar_to_char(context->adapter_descs[index].Description);
+    strcpy(info2->strAdapterName, dst);
+    free(dst);
+    info2->iVendorID = AMD_VENDOR_ID;
+    info2->iBusNumber = context->adapter_descs[index].DeviceId;
+
 
     return ADL_OK;
 }
 
-
-int WINAPI ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
-        int *display_target_count, ADLDisplayTarget **display_targets, int options)
+int AMDAPI ADL2_Adapter_MemoryInfo2_Get(ADL_CONTEXT *context, int index, ADLMemoryInfo2 *info)
 {
-    FIXME("adapter_index %d, display_map_count %p, display_maps %p, "
-            "display_target_count %p, display_targets %p, options %d stub.\n",
-            adapter_index, display_map_count, display_maps, display_target_count,
-            display_targets, options);
+    struct get_device_info_params params = {0};
+    TRACE("(%p, %d, %p)\n", context, index, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    params.device_id = context->adapter_descs[index].DeviceId;
+
+    if(!ATI_CALL( get_device_info, &params ))
+    {
+        info->iMemorySize = context->adapter_descs[index].DedicatedVideoMemory;
+        info->iMemoryBandwidth = params.memory_bandwidth;
+        strcpy(info->strMemoryType, "GDDR6");
+        info->iHyperMemorySize = 0;
+        info->iVisibleMemorySize = context->adapter_descs[index].SharedSystemMemory;
+        info->iInvisibleMemorySize = 0;
+        return ADL_OK;
+    }
 
     return ADL_ERR;
 }
+
+int AMDAPI ADL2_Display_SLSMapIndex_Get(ADL_CONTEXT *context, int index, int num_displays, ADLDisplayTarget *targets, int *ret)
+{
+    FIXME("(%p, %d, %d, %p, %p) stub\n", context, index, num_displays, targets, ret);
+
+    if(!context || !targets || !ret)
+        return ADL_ERR;
+
+    *ret = 0;
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_SLSMapIndex_Get(int index, int num_displays, ADLDisplayTarget *targets, int *ret)
+{
+    return ADL2_Display_SLSMapIndex_Get(&global_adl_context, index, num_displays, targets, ret);
+}
+
+int AMDAPI ADL2_Display_SLSMapConfig_Get( 	ADL_CONTEXT *  	context,
+		int  	iAdapterIndex,
+		int  	iSLSMapIndex,
+		ADLSLSMap *  	lpSLSMap,
+		int *  	lpNumSLSTarget,
+		ADLSLSTarget **  	lppSLSTarget,
+		int *  	lpNumNativeMode,
+		ADLSLSMode **  	lppNativeMode,
+		int *  	lpNumBezelMode,
+		ADLBezelTransientMode **  	lppBezelMode,
+		int *  	lpNumTransientMode,
+		ADLBezelTransientMode **  	lppTransientMode,
+		int *  	lpNumSLSOffset,
+		ADLSLSOffset **  	lppSLSOffset,
+		int  	iOption )
+{
+    FIXME("(%p, %d, %d, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %d) stub\n", context, iAdapterIndex,
+            iSLSMapIndex, lpSLSMap, lpNumSLSTarget, lppSLSTarget, lpNumNativeMode, lppNativeMode,
+            lpNumBezelMode, lppBezelMode, lpNumTransientMode, lppTransientMode, lpNumSLSOffset, lppSLSOffset, iOption);
+
+    if(!context || !lpSLSMap || !lpNumSLSTarget || !lppSLSTarget || !lpNumNativeMode ||
+    !lppNativeMode || !lpNumBezelMode || !lppBezelMode || !lpNumTransientMode ||
+    !lppTransientMode || !lpNumSLSOffset || !lppSLSOffset)
+        return ADL_ERR;
+
+    *lpNumSLSTarget = 0;
+    *lpNumNativeMode = 0;
+    *lpNumBezelMode = 0;
+    *lpNumTransientMode = 0;
+    *lpNumSLSOffset = 0;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_SLSMapConfig_Get(
+        int  	iAdapterIndex,
+		int  	iSLSMapIndex,
+		ADLSLSMap *  	lpSLSMap,
+		int *  	lpNumSLSTarget,
+		ADLSLSTarget **  	lppSLSTarget,
+		int *  	lpNumNativeMode,
+		ADLSLSMode **  	lppNativeMode,
+		int *  	lpNumBezelMode,
+		ADLBezelTransientMode **  	lppBezelMode,
+		int *  	lpNumTransientMode,
+		ADLBezelTransientMode **  	lppTransientMode,
+		int *  	lpNumSLSOffset,
+		ADLSLSOffset **  	lppSLSOffset,
+		int  	iOption )
+{
+    return ADL2_Display_SLSMapConfig_Get(&global_adl_context, iAdapterIndex, iSLSMapIndex, lpSLSMap, lpNumSLSTarget,
+        lppSLSTarget, lpNumNativeMode, lppNativeMode, lpNumBezelMode, lppBezelMode, lpNumTransientMode,
+        lppTransientMode, lpNumSLSOffset, lppSLSOffset, iOption);
+}
+
+int AMDAPI ADL2_Display_EdidData_Get(ADL_CONTEXT *context, int adapter_index, int display_index, ADLDisplayEDIDData *data)
+{
+    FIXME("(%p, %d, %d, %p) stub\n", context, adapter_index, display_index, data);
+
+    if (!data) return ADL_ERR;
+
+    memset(data, 0, sizeof(ADLDisplayEDIDData));
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_EdidData_Get(int adapter_index, int display_index, ADLDisplayEDIDData *data)
+{
+    return ADL2_Display_EdidData_Get(&global_adl_context, adapter_index, display_index, data);
+}
+
+int AMDAPI ADL2_Adapter_Active_Get(ADL_CONTEXT *context, int index, int *status)
+{
+    FIXME("(%p %d %p) stub!\n", context, index, status);
+
+    if(!context || !status)
+        return ADL_ERR;
+
+    *status = ADL_TRUE;
+
+    return ADL_OK;
+}
+
+typedef struct
+{
+    /* TODO: what are the elements? */
+    int xyz;
+} ADLDisplayContentAttribute;
+
+int AMDAPI ADL2_Display_SourceContentAttribute_Set(ADL_CONTEXT *context, int adapter_index, int display_index, ADLDisplayContentAttribute *attribute)
+{
+    FIXME("(%p %d %d %p) stub!\n", context, adapter_index, display_index, attribute);
+
+    if(!context || !attribute)
+        return ADL_ERR;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Adapter_Crossfire_Caps(ADL_CONTEXT *context, int adapter_index, int *preffer, int *numComb, ADLCrossfireComb **combs) {
+
+    if(!context || !preffer || !numComb)
+        return ADL_ERR;
+
+    FIXME("(%p %d %p %p %p) stub!\n", context, adapter_index, preffer, numComb, combs);
+
+    *preffer = 0;
+    *numComb = 0;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_OverdriveN_Temperature_Get(ADL_CONTEXT *context, int adapter_index, int temptype, int *temp)
+{
+
+    if(!context || !temp)
+        return ADL_ERR;
+
+    FIXME("(%p %d %d %p) stub!\n", context, adapter_index, temptype, temp);
+
+    *temp = 0;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_OverdriveN_PerformanceStatus_Get(ADL_CONTEXT *context, int adapter_index, ADLODNPerformanceStatus *status)
+{
+    int temp;
+    if(!context || !status)
+        return ADL_ERR;
+
+    FIXME("(%p %d %p) semi-stub!\n", context, adapter_index, status);
+
+    return ADL_Adapter_ObservedGameClockInfo_Get(context, adapter_index, &status->iCoreClock, &temp, &temp, &status->iMemoryClock);
+}
diff --git a/dlls/atiadlxx/dxvk_interfaces.idl b/dlls/atiadlxx/dxvk_interfaces.idl
new file mode 100644
index 00000000000..9e405a32a06
--- /dev/null
+++ b/dlls/atiadlxx/dxvk_interfaces.idl
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/atiadlxx/unixlib.c b/dlls/atiadlxx/unixlib.c
new file mode 100644
index 00000000000..95849bc0292
--- /dev/null
+++ b/dlls/atiadlxx/unixlib.c
@@ -0,0 +1,285 @@
+/*
+ * Unix library for atiadlxx functions
+ *
+ * Copyright 2023 Paul Gofman for CodeWeavers
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include <xf86drm.h>
+#include <amdgpu_drm.h>
+#include <amdgpu.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "wine/debug.h"
+
+#include "unixlib.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(atiadlxx);
+
+#define MAX_DEVICE_COUNT 64
+
+static unsigned int device_count;
+static struct drm_amdgpu_info_device *amd_info;
+
+static NTSTATUS init( void *args )
+{
+    drmDevicePtr devices[MAX_DEVICE_COUNT];
+    amdgpu_device_handle h;
+    uint32_t major, minor;
+    int i, count, fd, ret;
+
+    device_count = 0;
+
+    if ((count = drmGetDevices(devices, MAX_DEVICE_COUNT)) <= 0)
+    {
+        ERR("drmGetDevices failed, err %d.\n", count);
+        return STATUS_UNSUCCESSFUL;
+    }
+    TRACE("Got %d devices.\n", count);
+    for (i = 0; i < count; ++i)
+    {
+        if (!devices[i] || !devices[i]->nodes[DRM_NODE_RENDER])
+        {
+            TRACE("No render node, skipping.\n");
+            continue;
+        }
+        if ((fd = open(devices[i]->nodes[DRM_NODE_RENDER], O_RDONLY | O_CLOEXEC)) < 0)
+        {
+            ERR("Failed to open device %s, errno %d.\n", devices[i]->nodes[DRM_NODE_RENDER], errno);
+            continue;
+        }
+        if ((ret = amdgpu_device_initialize(fd, &major, &minor, &h)))
+        {
+            WARN("Failed to initialize amdgpu device bustype %d, %04x:%04x, err %d.\n", devices[i]->bustype,
+                    devices[i]->deviceinfo.pci->vendor_id, devices[i]->deviceinfo.pci->device_id, ret);
+            close(fd);
+            continue;
+        }
+        amd_info = realloc(amd_info, (device_count + 1) * sizeof(*amd_info));
+        /* amdgpu_query_info() doesn't fail on short buffer (filling in the available buffer size). So older or
+         * newer DRM version should be fine but zero init the structure to avoid random values. */
+        memset(&amd_info[device_count], 0, sizeof(*amd_info));
+        if (!(ret = amdgpu_query_info(h, AMDGPU_INFO_DEV_INFO, sizeof(*amd_info), &amd_info[device_count])))
+        {
+            TRACE("Got amdgpu info for device id %04x, family %#x, external_rev %#x, chip_rev %#x.\n",
+                    amd_info[device_count].device_id, amd_info[device_count].family, amd_info[device_count].external_rev,
+                    amd_info[device_count].chip_rev);
+            ++device_count;
+        }
+        else
+        {
+            ERR("amdgpu_query_info failed, ret %d.\n", ret);
+        }
+        amdgpu_device_deinitialize(h);
+        close(fd);
+    }
+    drmFreeDevices(devices, count);
+    return STATUS_SUCCESS;
+}
+
+#ifndef AMDGPU_VRAM_TYPE_DDR5
+#   define AMDGPU_VRAM_TYPE_DDR5  10
+#endif
+#ifndef AMDGPU_VRAM_TYPE_LPDDR4
+#   define AMDGPU_VRAM_TYPE_LPDDR4 11
+#endif
+#ifndef AMDGPU_VRAM_TYPE_LPDDR5
+#   define AMDGPU_VRAM_TYPE_LPDDR5 12
+#endif
+
+/* From Mesa source. */
+static uint32_t memory_ops_per_clock(uint32_t vram_type)
+{
+   /* Based on MemoryOpsPerClockTable from PAL. */
+   switch (vram_type) {
+   case AMDGPU_VRAM_TYPE_GDDR1:
+   case AMDGPU_VRAM_TYPE_GDDR3: /* last in low-end Evergreen */
+   case AMDGPU_VRAM_TYPE_GDDR4: /* last in R7xx, not used much */
+   case AMDGPU_VRAM_TYPE_UNKNOWN:
+   default:
+      return 0;
+   case AMDGPU_VRAM_TYPE_DDR2:
+   case AMDGPU_VRAM_TYPE_DDR3:
+   case AMDGPU_VRAM_TYPE_DDR4:
+   case AMDGPU_VRAM_TYPE_LPDDR4:
+   case AMDGPU_VRAM_TYPE_HBM: /* same for HBM2 and HBM3 */
+      return 2;
+   case AMDGPU_VRAM_TYPE_DDR5:
+   case AMDGPU_VRAM_TYPE_LPDDR5:
+   case AMDGPU_VRAM_TYPE_GDDR5: /* last in Polaris and low-end Navi14 */
+      return 4;
+   case AMDGPU_VRAM_TYPE_GDDR6:
+      return 16;
+   }
+}
+
+/* Constants from Mesa source. */
+#define FAMILY_UNKNOWN 0x00
+#define FAMILY_TN      0x69 /* # 105 / Trinity APUs */
+#define FAMILY_SI      0x6E /* # 110 / Southern Islands: Tahiti, Pitcairn, CapeVerde, Oland, Hainan */
+#define FAMILY_CI      0x78 /* # 120 / Sea Islands: Bonaire, Hawaii */
+#define FAMILY_KV      0x7D /* # 125 / Kaveri APUs: Spectre, Spooky, Kalindi, Godavari */
+#define FAMILY_VI      0x82 /* # 130 / Volcanic Islands: Iceland, Tonga, Fiji */
+#define FAMILY_POLARIS 0x82 /* # 130 / Polaris: 10, 11, 12 */
+#define FAMILY_CZ      0x87 /* # 135 / Carrizo APUs: Carrizo, Stoney */
+#define FAMILY_AI      0x8D /* # 141 / Vega: 10, 20 */
+#define FAMILY_RV      0x8E /* # 142 / Raven */
+#define FAMILY_NV      0x8F /* # 143 / Navi: 10 */
+#define FAMILY_VGH     0x90 /* # 144 / Van Gogh */
+#define FAMILY_NV3     0x91 /* # 145 / Navi: 3x */
+#define FAMILY_RMB     0x92 /* # 146 / Rembrandt */
+#define FAMILY_RPL     0x95 /* # 149 / Raphael */
+#define FAMILY_GFX1103 0x94
+#define FAMILY_GFX1150 0x96
+#define FAMILY_MDN     0x97 /* # 151 / Mendocino */
+
+#define ROUND_DIV(value, div) (((value) + (div) / 2) / (div))
+
+static void fill_device_info(struct drm_amdgpu_info_device *info, struct get_device_info_params *out)
+{
+    uint32_t erev = info->external_rev;
+    uint64_t max_engine_clock_khz, max_memory_clock_khz;
+
+    out->asic_family = AsicFamily_Unknown;
+    switch (info->family)
+    {
+        case FAMILY_AI:
+        case FAMILY_RV:
+            out->asic_family = AsicFamily_Vega;
+            break;
+
+        /* Treat pre-Polaris cards as Polaris. */
+        case FAMILY_CZ:
+        case FAMILY_SI:
+        case FAMILY_CI:
+        case FAMILY_KV:
+        case FAMILY_POLARIS:
+            out->asic_family = AsicFamily_GCN4;
+            break;
+
+        case FAMILY_NV:
+            if (erev >= 0x01 && erev < 0x28)
+                out->asic_family = AsicFamily_RDNA;
+            else if (erev >= 0x28 && erev < 0x50)
+                out->asic_family = AsicFamily_RDNA2;
+            break;
+
+        case FAMILY_RMB:
+        case FAMILY_RPL:
+        case FAMILY_MDN:
+        case FAMILY_VGH:
+            out->asic_family = AsicFamily_RDNA2;
+            break;
+
+        case FAMILY_NV3:
+        case FAMILY_GFX1103:
+        case FAMILY_GFX1150:
+            out->asic_family = AsicFamily_RDNA3;
+            break;
+    }
+    TRACE("family %u, erev %#x -> asicFamily %d.\n", info->family, erev, out->asic_family);
+    if (out->asic_family == AsicFamily_Unknown && info->family != FAMILY_UNKNOWN)
+    {
+        if (info->family > FAMILY_GFX1150)
+            out->asic_family = AsicFamily_RDNA3;
+        else
+            out->asic_family = AsicFamily_GCN4;
+
+        FIXME("Unrecognized family %u, erev %#x -> defaulting to %d.\n", info->family, erev,
+                out->asic_family);
+    }
+
+    out->num_cu = info->cu_active_number;
+    out->num_wgp = out->asic_family >= AsicFamily_RDNA ? out->num_cu / 2 : 0;
+    out->num_rops = info->num_rb_pipes * 4;
+    TRACE("num_cu %d, num_wgp %d, num_rops %d.\n", out->num_cu, out->num_wgp, out->num_rops);
+    /* These numbers are zero on Vangogh, workaround that (similar to how it is currently done
+     * in Mesa src/amd/common/ac_rgp.c. */
+    if (!(max_engine_clock_khz = info->max_engine_clock))
+        max_engine_clock_khz = 1300000;
+    if (!(max_memory_clock_khz = info->max_memory_clock))
+        max_memory_clock_khz = 687000;
+    out->core_clock = ROUND_DIV(max_engine_clock_khz, 1000);
+    out->memory_clock = ROUND_DIV(max_memory_clock_khz, 1000);
+    out->memory_bandwidth = ROUND_DIV(max_memory_clock_khz * memory_ops_per_clock(info->vram_type)
+            * info->vram_bit_width / 8, 1000);
+    /* out->min_memory_clock = ROUND_DIV(info->min_memory_clock, 1000);
+    out->min_core_clock = ROUND_DIV(info->min_engine_clock, 1000); */
+    TRACE("core_clock %uMHz, memory_clock %uMHz, memory_bandwidth %u.\n",
+            out->core_clock, out->memory_clock, out->memory_bandwidth);
+    out->teraflops = 1e-9f * max_engine_clock_khz * info->cu_active_number * 64 * 2;
+    out->is_apu = info->ids_flags & AMDGPU_IDS_FLAGS_FUSION;
+    TRACE("teraflops %.2f.\n", out->teraflops);
+}
+
+static NTSTATUS get_device_info( void *args )
+{
+    struct get_device_info_params *params = args;
+    unsigned int i;
+
+    for (i = 0; i < device_count; ++i)
+    {
+        if (amd_info[i].device_id != params->device_id)
+            continue;
+        TRACE("device %04x found.\n", params->device_id);
+        fill_device_info(&amd_info[i], params);
+        return STATUS_SUCCESS;
+    }
+    TRACE("Device %04x not found.\n", params->device_id);
+    return STATUS_NOT_FOUND;
+}
+
+static NTSTATUS wow64_init( void *args )
+{
+    /* no args lmao */
+    return init(args);
+}
+
+static NTSTATUS wow64_get_device_info( void *args )
+{
+    /* everything should be same size on x64 and x86 */
+    return get_device_info(args);
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    init,
+    get_device_info,
+};
+
+const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
+{
+    wow64_init,
+    wow64_get_device_info,
+};
diff --git a/dlls/atiadlxx/unixlib.h b/dlls/atiadlxx/unixlib.h
new file mode 100644
index 00000000000..ebe038a1b00
--- /dev/null
+++ b/dlls/atiadlxx/unixlib.h
@@ -0,0 +1,61 @@
+/*
+ * Unix library interface
+ *
+ * Copyright 2023 Paul Gofman for CodeWeavers
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdbool.h>
+#include "wine/unixlib.h"
+
+enum amd_ags_funcs
+{
+    unix_init,
+    unix_get_device_info,
+};
+
+typedef enum AsicFamily
+{
+    AsicFamily_Unknown,                                         ///< Unknown architecture, potentially from another IHV. Check \ref AGSDeviceInfo::vendorId
+    AsicFamily_PreGCN,                                          ///< Pre GCN architecture.
+    AsicFamily_GCN1,                                            ///< AMD GCN 1 architecture: Oland, Cape Verde, Pitcairn & Tahiti.
+    AsicFamily_GCN2,                                            ///< AMD GCN 2 architecture: Hawaii & Bonaire.  This also includes APUs Kaveri and Carrizo.
+    AsicFamily_GCN3,                                            ///< AMD GCN 3 architecture: Tonga & Fiji.
+    AsicFamily_GCN4,                                            ///< AMD GCN 4 architecture: Polaris.
+    AsicFamily_Vega,                                            ///< AMD Vega architecture, including Raven Ridge (ie AMD Ryzen CPU + AMD Vega GPU).
+    AsicFamily_RDNA,                                            ///< AMD RDNA architecture
+    AsicFamily_RDNA2,                                           ///< AMD RDNA2 architecture
+    AsicFamily_RDNA3,                                           ///< AMD RDNA3 architecture
+} AsicFamily;
+
+struct get_device_info_params
+{
+    uint32_t device_id;
+    uint32_t _pad;
+    /* Output parameters. */
+    uint32_t asic_family;
+    uint32_t num_cu;
+    uint32_t num_wgp;
+    uint32_t num_rops;
+    uint32_t core_clock;
+    uint32_t memory_clock;
+    uint32_t memory_bandwidth;
+    uint32_t min_core_clock;
+    uint32_t min_memory_clock;
+    bool is_apu;
+    float teraflops;
+};
diff --git a/dlls/atidxx64/Makefile.in b/dlls/atidxx64/Makefile.in
new file mode 100644
index 00000000000..e4c1d2875c8
--- /dev/null
+++ b/dlls/atidxx64/Makefile.in
@@ -0,0 +1,9 @@
+MODULE = atidxx64.dll
+IMPORTS = version vulkan-1 user32 gdi32
+IMPORTLIB = atidxx64
+
+EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
+
+SOURCES = \
+	main.c \
+	dxvk_interfaces.idl
diff --git a/dlls/atidxx64/atidxx.h b/dlls/atidxx64/atidxx.h
new file mode 100644
index 00000000000..b57776daafd
--- /dev/null
+++ b/dlls/atidxx64/atidxx.h
@@ -0,0 +1,137 @@
+#include "objbase.h"
+
+typedef struct
+{
+    unsigned int        majorVersion;
+    unsigned int        minorVersion;
+} AmdDxExtVersion;
+
+typedef enum
+{
+                                                       // D3D10_DDI_PRIMITIVE_TOPOLOGY_* values
+    AmdDxExtPrimitiveTopology_Undefined          = 0,  // D3D10 UNDEFINED
+    AmdDxExtPrimitiveTopology_PointList          = 1,  // D3D10 POINTLIST
+    AmdDxExtPrimitiveTopology_LineList           = 2,  // D3D10 LINELIST
+    AmdDxExtPrimitiveTopology_LineStrip          = 3,  // D3D10 LINESTRIP
+    AmdDxExtPrimitiveTopology_TriangleList       = 4,  // D3D10 TRIANGLELIST
+    AmdDxExtPrimitiveTopology_TriangleStrip      = 5,  // D3D10 TRIANGLESTRIP
+                                                       // 6 is reserved for legacy triangle fans
+    AmdDxExtPrimitiveTopology_ExtQuadList        = 7,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_ExtPatch           = 8,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_ExtScreenRectList  = 9,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_LineListAdj        = 10, // D3D10 LINELIST_ADJ
+    AmdDxExtPrimitiveTopology_LineStripAdj       = 11, // D3D10 LINESTRIP_ADJ
+    AmdDxExtPrimitiveTopology_TriangleListAdj    = 12, // D3D10 TRIANGLELIST_ADJ
+    AmdDxExtPrimitiveTopology_TriangleStripAdj   = 13, // D3D10 TRIANGLESTRIP_ADJ
+    AmdDxExtPrimitiveTopology_Max                = 14
+} AmdDxExtPrimitiveTopology;
+
+typedef enum
+{
+    AmdDxExtFeature_ScreenRectSupport           = 1, // Screen Rect supported - data is BOOL
+    AmdDxExtFeature_DeviceHp3d                  = 2, // HP3D support
+    AmdDxExtFeature_DeviceCtxSupport            = 3, // Device Ctx Support
+} AmdDxExtFeatureToken;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+#define THISCALLMETHOD_(type,method)  virtual type __thiscall method
+#else
+#define THISCALLMETHOD_(type,method)  type (__thiscall *method)
+#endif
+
+#define INTERFACE IAmdDxExtInterface
+DECLARE_INTERFACE(IAmdDxExtInterface)
+{
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExt
+DECLARE_INTERFACE_(IAmdDxExt, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExt methods ***/
+    THISCALLMETHOD_(HRESULT, IaGetPrimitiveTopology)(THIS_ AmdDxExtPrimitiveTopology *topology) PURE;
+    THISCALLMETHOD_(HRESULT, GetVersion)(THIS_ AmdDxExtVersion *version) PURE;
+    THISCALLMETHOD_(IAmdDxExtInterface*,GetExtInterface)(THIS_ unsigned int iface) PURE;
+
+
+    THISCALLMETHOD_(HRESULT, IaSetPrimitiveTopology)(THIS_ D3D_PRIMITIVE_TOPOLOGY topology) PURE;
+    THISCALLMETHOD_(HRESULT, SetSingleSampleRead)(THIS_ ID3D10Resource *res, BOOL single_sample) PURE;
+    THISCALLMETHOD_(HRESULT, SetSingleSampleRead11)(THIS_ ID3D11Resource *res, BOOL single_sample) PURE;
+    THISCALLMETHOD_(HRESULT, IaSetPrimitiveTopologyCtx)(THIS_ unsigned int topology, ID3D11DeviceContext *ctx) PURE;
+    THISCALLMETHOD_(HRESULT, QueryFeatureSupport)(THIS_ unsigned int feature_token, void *data, unsigned int data_size) PURE;
+    THISCALLMETHOD_(HRESULT, IaGetPrimitiveTopologyCtx)(THIS_ AmdDxExtPrimitiveTopology *topology, ID3D11DeviceContext *ctx) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtUAVOverlap
+DECLARE_INTERFACE_(IAmdDxExtUAVOverlap, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtUAVOverlap methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, BeginUAVOverlap)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, EndUAVOverlap)(THIS) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion* version) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtQuadBufferStereo
+DECLARE_INTERFACE_(IAmdDxExtQuadBufferStereo, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtQuadBufferStereo methods ***/
+    THISCALLMETHOD_(HRESULT, EnableQuadBufferStereo)(THIS, BOOL enable) PURE;
+    THISCALLMETHOD_(UINT, GetLineOffset)(THIS, IDXGISwapChain *swapchain) PURE;
+    THISCALLMETHOD_(HRESULT, GetDisplayModeList)(THIS, DXGI_FORMAT format, unsigned int flags, unsigned int *num_modes, DXGI_MODE_DESC *desc) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtDepthBounds
+DECLARE_INTERFACE_(IAmdDxExtDepthBounds, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtDepthBounds methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, SetDepthBounds)(THIS, BOOL enabled, float min, float max) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion *version) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtMultidrawIndirect
+DECLARE_INTERFACE_(IAmdDxExtMultidrawIndirect, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtMultidrawIndirect methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion *version) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndirect)(THIS, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndexedIndirect)(THIS, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndirectCount)(THIS, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndexedIndirectCount)(THIS, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+};
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/dlls/atidxx64/atidxx64.spec b/dlls/atidxx64/atidxx64.spec
new file mode 100644
index 00000000000..4012dcb0303
--- /dev/null
+++ b/dlls/atidxx64/atidxx64.spec
@@ -0,0 +1,17 @@
+@ stub AmdD3D11CreateDevice
+@ stub AmdD3D11CreateDeviceAndSwapChain
+@ stub AmdD3D11CreateDeviceAndSwapChainExt()
+@ stdcall AmdD3D11CreateDeviceExt(ptr long ptr long ptr long long ptr ptr ptr ptr)
+@ cdecl AmdDxExtCreate11(ptr ptr)
+@ stub AmdDxExtCreate
+@ stub AmdDxShimQueryInterface
+@ stub XdxInitXopAdapterServices
+@ stub XdxInitXopServices
+@ stub XdxQueryTlsLookupTable
+@ stub AmdDxGsaCompileShader
+@ stub AmdDxGsaFreeCompiledShader
+@ stub AmdGetDxxModuleHandle
+@ stub AmdLiquidVrAffinityInit
+@ stub AmdLiquidVrAffinityTerm
+@ stub AmdLiquidVrD3D11CreateDevice
+@ stub AmdLiquidVrD3D11WrapDeviceContext
diff --git a/dlls/atidxx64/dxvk_interfaces.idl b/dlls/atidxx64/dxvk_interfaces.idl
new file mode 100644
index 00000000000..9e405a32a06
--- /dev/null
+++ b/dlls/atidxx64/dxvk_interfaces.idl
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/atidxx64/main.c b/dlls/atidxx64/main.c
new file mode 100644
index 00000000000..5d4def2d383
--- /dev/null
+++ b/dlls/atidxx64/main.c
@@ -0,0 +1,677 @@
+/*
+ * atidxx64 implementation
+ *
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "wine/vulkan.h"
+#include "wine/asm.h"
+
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
+
+#include "dxgi1_6.h"
+
+#include "dxvk_interfaces.h"
+#include "atidxx.h"
+
+#include <wingdi.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(atidxx);
+
+static HMODULE d3d11_module;
+static HRESULT (WINAPI *pD3D11CreateDevice)(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_type,
+        HMODULE swrast, UINT flags, const D3D_FEATURE_LEVEL *feature_levels, UINT levels,
+        UINT sdk_version, ID3D11Device **device_out, D3D_FEATURE_LEVEL *obtained_feature_level,
+        ID3D11DeviceContext **immediate_context);
+
+typedef void (*vtable_ptr)(void);
+
+static HRESULT load_d3d11(void)
+{
+    if (!d3d11_module)
+        d3d11_module = LoadLibraryA("d3d11.dll");
+
+    if (!d3d11_module)
+    {
+        ERR("Failed to load d3d11.dll\n");
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+
+HRESULT WINAPI AmdD3D11CreateDeviceExt(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_type, HMODULE swrast, UINT flags,
+        const D3D_FEATURE_LEVEL *feature_levels, UINT levels, UINT sdk_version, ID3D11Device **device_out,
+        D3D_FEATURE_LEVEL *obtained_feature_level, ID3D11DeviceContext **immediate_context, void *unk)
+{
+    HRESULT ret;
+    FIXME("%p semi-stub\n", unk);
+
+    if ((ret = load_d3d11()))
+        return ret;
+
+    if (!pD3D11CreateDevice)
+        pD3D11CreateDevice = (void*)GetProcAddress(d3d11_module, "D3D11CreateDevice");
+
+    return pD3D11CreateDevice(adapter, driver_type, swrast, flags, feature_levels, levels, sdk_version,
+            device_out, obtained_feature_level, immediate_context);
+}
+
+/*
+    Ext Ifaces to implement:
+    field_0x170 = 0x11
+    field_0x190 = 0x17
+    field_0x188 = 0x15
+    field_0x178 = 0x14
+    field_0x1a0 = 0x1d
+    field_0x168 = 0xb
+    field_0x160 = 0xf
+    field_0x198 = 0x17
+ */
+
+/* field_0x160 (0xf)
+
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = BeginUAVOverlap
+    0x20 = EndUAVOverlap
+    0x28 = GetVersion (called on init, prob some kind of version getter)
+
+*/
+
+/* field_0x168 (0xb)
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = SetDepthBounds
+    0x20 = GetVersion
+*/
+
+/* field_0x170 (0x11)
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = GetVersion
+    0x20 = MultiDrawIndirect
+    0x28 = MultiDrawIndexedIndirect
+    0x30 = MultiDrawIndirectCount
+    0x38 = MultiDrawIndexedIndirectCount
+*/
+
+typedef struct
+{
+    IAmdDxExt IAmdDxExt_iface;
+    IAmdDxExtUAVOverlap IAmdDxExtUAVOverlap_iface;
+    IAmdDxExtQuadBufferStereo IAmdDxExtQuadBufferStereo_iface;
+    IAmdDxExtDepthBounds IAmdDxExtDepthBounds_iface;
+    IAmdDxExtMultidrawIndirect IAmdDxExtMultidrawIndirect_iface;
+    LONG ref;
+    //could also be a d3d10 device, just cast
+    ID3D11Device *device;
+    ID3D11DeviceContext *context;
+    ID3D11VkExtContext *ext_context;
+    BOOL is_d3d11;
+    BOOL uav_overlap;
+    BOOL depth_bounds;
+    BOOL multi_draw_indirect;
+    BOOL multi_draw_indirect_count;
+} AmdDxExt;
+
+static inline AmdDxExt *impl_from_IAmdDxExt(IAmdDxExt *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExt_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtUAVOverlap_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtQuadBufferStereo(IAmdDxExtQuadBufferStereo *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtQuadBufferStereo_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtDepthBounds(IAmdDxExtDepthBounds *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtDepthBounds_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtMultidrawIndirect(IAmdDxExtMultidrawIndirect *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtMultidrawIndirect_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_AddRef, 4)
+unsigned int __thiscall AmdDxExt_AddRef(IAmdDxExt *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(iface);
+    return InterlockedIncrement(&This->ref);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_Release, 4)
+unsigned int __thiscall AmdDxExt_Release(IAmdDxExt *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+    if(ref == 0)
+    {
+        if(This->is_d3d11)
+        {
+            ID3D11Device_Release(This->device);
+            ID3D11DeviceContext_Release(This->context);
+            ID3D11VkExtContext_Release(This->ext_context);
+        }
+        free(This);
+    }
+    return ref;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_GetVersion, 8)
+HRESULT __thiscall AmdDxExt_GetVersion(IAmdDxExt *ext, AmdDxExtVersion *version)
+{
+    FIXME("%p %p\n", ext, version);
+
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_AddRef, 4)
+unsigned int __thiscall AmdDxExtUAVOverlap_AddRef(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_Release, 4)
+unsigned int __thiscall AmdDxExtUAVOverlap_Release(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_GetExtInterface, 8)
+IAmdDxExtInterface* __thiscall AmdDxExt_GetExtInterface(IAmdDxExt *ext, unsigned int iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(ext);
+    IAmdDxExtInterface *ret = NULL;
+    TRACE("%p %x\n", ext, iface);
+
+    switch(iface)
+    {
+        case 0x2:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtQuadBufferStereo_iface;
+            break;
+        case 0xb:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtDepthBounds_iface;
+            break;
+        case 0xf:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtUAVOverlap_iface;
+            break;
+        case 0x11:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtMultidrawIndirect_iface;
+            break;
+        default:
+        {
+            FIXME("Unknown interface %x\n", iface);
+            break;
+        }
+    }
+
+    if (ret)
+    {
+        AmdDxExt_AddRef(ext);
+    }
+
+    return ret;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaSetPrimitiveTopology, 8)
+HRESULT __thiscall AmdDxExt_IaSetPrimitiveTopology(IAmdDxExt *ext, D3D_PRIMITIVE_TOPOLOGY topology)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(ext);
+    TRACE("%p %u\n", ext, topology);
+
+    if(This->is_d3d11)
+    {
+        ID3D11DeviceContext_IASetPrimitiveTopology(This->context, topology);
+    }
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaGetPrimitiveTopology, 8)
+HRESULT __thiscall AmdDxExt_IaGetPrimitiveTopology(IAmdDxExt *ext, AmdDxExtPrimitiveTopology *topology)
+{
+    FIXME("%p %p stub\n", ext, topology);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_SetSingleSampleRead, 12)
+HRESULT __thiscall AmdDxExt_SetSingleSampleRead(IAmdDxExt *iface, ID3D10Resource *res, BOOL single_sample)
+{
+    FIXME("%p %p %u stub\n", iface, res, single_sample);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_SetSingleSampleRead11, 12)
+HRESULT __thiscall AmdDxExt_SetSingleSampleRead11(IAmdDxExt *iface, ID3D11Resource *res, BOOL single_sample)
+{
+    FIXME("%p %p %u stub\n", iface, res, single_sample);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_QueryFeatureSupport, 16)
+HRESULT __thiscall AmdDxExt_QueryFeatureSupport(IAmdDxExt *iface, unsigned int feature_token, void *data, unsigned int data_size)
+{
+    FIXME("%p %u %p %u stub\n", iface, feature_token, data, data_size);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaSetPrimitiveTopologyCtx, 12)
+HRESULT __thiscall AmdDxExt_IaSetPrimitiveTopologyCtx(IAmdDxExt *iface, unsigned int topology, ID3D11DeviceContext *ctx)
+{
+    FIXME("%p %u %p stub\n", iface, topology, ctx);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaGetPrimitiveTopologyCtx, 12)
+HRESULT __thiscall AmdDxExt_IaGetPrimitiveTopologyCtx(IAmdDxExt *iface, AmdDxExtPrimitiveTopology *topology, ID3D11DeviceContext *ctx)
+{
+    FIXME("%p %p %p stub\n", iface, topology, ctx);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_Unk1, 4)
+void __thiscall AmdDxExtUAVOverlap_Unk1(IAmdDxExtUAVOverlap *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_BeginUAVOverlap, 4)
+HRESULT __thiscall AmdDxExtUAVOverlap_BeginUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    TRACE("%p\n", iface);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->uav_overlap) return E_FAIL;
+
+    ID3D11VkExtContext_SetBarrierControl(This->ext_context, D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_EndUAVOverlap, 4)
+HRESULT __thiscall AmdDxExtUAVOverlap_EndUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    TRACE("%p\n", iface);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->uav_overlap) return E_FAIL;
+
+    ID3D11VkExtContext_SetBarrierControl(This->ext_context, 0);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_GetVersion, 8)
+void __thiscall AmdDxExtUAVOverlap_GetVersion(IAmdDxExtUAVOverlap *iface, AmdDxExtVersion* version)
+{
+    FIXME("%p %p stub!\n", iface, version);
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_AddRef, 4)
+unsigned int __thiscall AmdDxExtQuadBufferStereo_AddRef(IAmdDxExtQuadBufferStereo *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtQuadBufferStereo(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_Release, 4)
+unsigned int __thiscall AmdDxExtQuadBufferStereo_Release(IAmdDxExtQuadBufferStereo *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtQuadBufferStereo(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_EnableQuadBufferStereo, 8)
+HRESULT __thiscall AmdDxExtQuadBufferStereo_EnableQuadBufferStereo(IAmdDxExtQuadBufferStereo *iface, BOOL enable)
+{
+    FIXME("%p %u stub\n", iface, enable);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_GetDisplayModeList, 20)
+HRESULT __thiscall AmdDxExtQuadBufferStereo_GetDisplayModeList(IAmdDxExtQuadBufferStereo *iface, DXGI_FORMAT format, UINT flags, UINT *num_modes, DXGI_MODE_DESC *desc)
+{
+    FIXME("%p %u %u %p %p stub\n", iface, format, flags, num_modes, desc);
+
+    if (!num_modes) return E_INVALIDARG;
+
+    *num_modes = 0;
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_GetLineOffset, 8)
+UINT __thiscall AmdDxExtQuadBufferStereo_GetLineOffset(IAmdDxExtQuadBufferStereo *iface, IDXGISwapChain *swapchain)
+{
+    FIXME("%p %p stub\n", iface, swapchain);
+
+    return 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_AddRef, 4)
+unsigned int __thiscall AmdDxExtDepthBounds_AddRef(IAmdDxExtDepthBounds *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_Release, 4)
+unsigned int __thiscall AmdDxExtDepthBounds_Release(IAmdDxExtDepthBounds *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_GetVersion, 8)
+void __thiscall AmdDxExtDepthBounds_GetVersion(IAmdDxExtDepthBounds *iface, AmdDxExtVersion* version)
+{
+    FIXME("%p %p stub!\n", iface, version);
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_SetDepthBounds, 16)
+HRESULT __thiscall AmdDxExtDepthBounds_SetDepthBounds(IAmdDxExtDepthBounds *iface, BOOL enabled, float min, float max)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+
+    TRACE("%p %u %f %f\n", iface, enabled, min, max);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->depth_bounds) return E_FAIL;
+
+    ID3D11VkExtContext_SetDepthBoundsTest(This->ext_context, enabled, min, max);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_Unk1, 4)
+void __thiscall AmdDxExtDepthBounds_Unk1(IAmdDxExtDepthBounds *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_AddRef, 4)
+unsigned int __thiscall AmdDxExtMultidrawIndirect_AddRef(IAmdDxExtMultidrawIndirect *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_Release, 4)
+unsigned int __thiscall AmdDxExtMultidrawIndirect_Release(IAmdDxExtMultidrawIndirect *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_Unk1, 4)
+void __thiscall AmdDxExtMultidrawIndirect_Unk1(IAmdDxExtMultidrawIndirect *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_GetVersion, 8)
+void __thiscall AmdDxExtMultidrawIndirect_GetVersion(IAmdDxExtMultidrawIndirect *iface, AmdDxExtVersion* version)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    FIXME("%p %p semi-stub!\n", iface, version);
+    version->majorVersion = 1;
+    /* needed for indirect count */
+    version->minorVersion = This->multi_draw_indirect_count ? 2 : 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_MultiDrawIndirect, 20)
+HRESULT __thiscall AmdDxExtMultidrawIndirect_MultiDrawIndirect(IAmdDxExtMultidrawIndirect *iface, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    TRACE("%p %u %p %u %u\n", iface, draw_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect) return E_FAIL;
+
+    ID3D11VkExtContext_MultiDrawIndirect(This->ext_context, draw_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect, 20)
+HRESULT __thiscall AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect(IAmdDxExtMultidrawIndirect *iface, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    TRACE("%p %u %p %u %u\n", iface, draw_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect) return E_FAIL;
+
+    ID3D11VkExtContext_MultiDrawIndexedIndirect(This->ext_context, draw_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+static unsigned int get_max_draw_count(ID3D11Buffer *buffer, unsigned int offset, unsigned int stride, unsigned int size)
+{
+    D3D11_BUFFER_DESC desc;
+    unsigned int count;
+
+    ID3D11Buffer_GetDesc(buffer, &desc);
+
+    if(offset >= desc.ByteWidth)
+    {
+        WARN("Offset %u, buffer size %u.", offset, desc.ByteWidth);
+        return 0;
+    }
+
+    count = (desc.ByteWidth - offset) / stride;
+    if (desc.ByteWidth - offset - count * stride >= size)
+        ++count;
+
+    if (!count)
+        WARN("zero count, buffer size %u, offset %u, stride %u, size %u.\n", desc.ByteWidth, offset, stride, size);
+
+    return count;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxextMultiDrawIndirect_MultiDrawIndirectCount, 24)
+HRESULT __thiscall AmdDxextMultiDrawIndirect_MultiDrawIndirectCount(IAmdDxExtMultidrawIndirect *iface, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    unsigned int max_draw_count;
+    TRACE("%p %p %u %p %u %u\n", iface, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect_count) return E_FAIL;
+
+    max_draw_count = get_max_draw_count(buffer, byte_offset, byte_stride, sizeof(D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS));
+
+    ID3D11VkExtContext_MultiDrawIndirectCount(This->ext_context, max_draw_count, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount, 24)
+HRESULT __thiscall AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount(IAmdDxExtMultidrawIndirect *iface, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    unsigned int max_draw_count;
+    TRACE("%p %p %u %p %u %u\n", iface, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect_count) return E_FAIL;
+
+    max_draw_count = get_max_draw_count(buffer, byte_offset, byte_stride, sizeof(D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS));
+
+    ID3D11VkExtContext_MultiDrawIndexedIndirectCount(This->ext_context, max_draw_count, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+static const IAmdDxExtUAVOverlapVtbl amddxext_uav_vtable =
+{
+    THISCALL(AmdDxExtUAVOverlap_AddRef),
+    THISCALL(AmdDxExtUAVOverlap_Release),
+    THISCALL(AmdDxExtUAVOverlap_Unk1),
+    THISCALL(AmdDxExtUAVOverlap_BeginUAVOverlap),
+    THISCALL(AmdDxExtUAVOverlap_EndUAVOverlap),
+    THISCALL(AmdDxExtUAVOverlap_GetVersion)
+};
+
+static const IAmdDxExtVtbl AmdDxExt_vtable =
+{
+    THISCALL(AmdDxExt_AddRef), //0
+    THISCALL(AmdDxExt_Release), //0x8
+    THISCALL(AmdDxExt_IaGetPrimitiveTopology), // 0x10 ??
+    THISCALL(AmdDxExt_GetVersion), //0x18
+    THISCALL(AmdDxExt_GetExtInterface), //0x20
+    THISCALL(AmdDxExt_IaSetPrimitiveTopology), //0x28
+    THISCALL(AmdDxExt_SetSingleSampleRead), //0x30 ??
+    THISCALL(AmdDxExt_SetSingleSampleRead11), //0x38 ??
+    THISCALL(AmdDxExt_IaSetPrimitiveTopologyCtx), //0x40 ??
+    THISCALL(AmdDxExt_QueryFeatureSupport), //0x48
+    THISCALL(AmdDxExt_IaGetPrimitiveTopologyCtx) //0x50 ??
+};
+
+static const IAmdDxExtQuadBufferStereoVtbl quadbufstereo_vtable =
+{
+    THISCALL(AmdDxExtQuadBufferStereo_AddRef),
+    THISCALL(AmdDxExtQuadBufferStereo_Release),
+    THISCALL(AmdDxExtQuadBufferStereo_EnableQuadBufferStereo),
+    THISCALL(AmdDxExtQuadBufferStereo_GetLineOffset),
+    THISCALL(AmdDxExtQuadBufferStereo_GetDisplayModeList),
+};
+
+static const IAmdDxExtDepthBoundsVtbl amddxext_depth_vtable =
+{
+    THISCALL(AmdDxExtDepthBounds_AddRef),
+    THISCALL(AmdDxExtDepthBounds_Release),
+    THISCALL(AmdDxExtDepthBounds_Unk1),
+    THISCALL(AmdDxExtDepthBounds_SetDepthBounds),
+    THISCALL(AmdDxExtDepthBounds_GetVersion)
+};
+
+static const IAmdDxExtMultidrawIndirectVtbl amddxext_multidraw_vtable =
+{
+    THISCALL(AmdDxExtMultidrawIndirect_AddRef),
+    THISCALL(AmdDxExtMultidrawIndirect_Release),
+    THISCALL(AmdDxExtMultidrawIndirect_Unk1),
+    THISCALL(AmdDxExtMultidrawIndirect_GetVersion),
+    THISCALL(AmdDxExtMultidrawIndirect_MultiDrawIndirect),
+    THISCALL(AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect),
+    THISCALL(AmdDxextMultiDrawIndirect_MultiDrawIndirectCount),
+    THISCALL(AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount)
+};
+
+HRESULT CDECL AmdDxExtCreate11(ID3D11Device *device, IAmdDxExt **ext)
+{
+    HRESULT ret;
+    AmdDxExt *obj;
+    ID3D11VkExtDevice *ext_device;
+    TRACE("%p %p\n", device, ext);
+
+    if((ret = load_d3d11()) != S_OK)
+        return ret;
+
+    obj = malloc(sizeof(AmdDxExt));
+    if(!obj)
+        return E_OUTOFMEMORY;
+
+    obj->device = device;
+    ID3D11Device_AddRef(device);
+    ID3D11Device_GetImmediateContext(device, &obj->context);
+
+    if(FAILED(ret = ID3D11DeviceContext_QueryInterface(obj->context, &IID_ID3D11VkExtContext, (void**)&obj->ext_context)))
+    {
+        ERR("Failed to get ID3D11VkExtContext\n");
+        return ret;
+    }
+
+    if(FAILED(ret = ID3D11Device_QueryInterface(device, &IID_ID3D11VkExtDevice, (void**)&ext_device)))
+    {
+        ERR("Failed to get ID3D11VkExtDevice\n");
+        return ret;
+    }
+
+    obj->IAmdDxExt_iface.lpVtbl = &AmdDxExt_vtable;
+    obj->IAmdDxExtUAVOverlap_iface.lpVtbl = &amddxext_uav_vtable;
+    obj->IAmdDxExtQuadBufferStereo_iface.lpVtbl = &quadbufstereo_vtable;
+    obj->IAmdDxExtDepthBounds_iface.lpVtbl = &amddxext_depth_vtable;
+    obj->IAmdDxExtMultidrawIndirect_iface.lpVtbl = &amddxext_multidraw_vtable;
+    obj->is_d3d11 = TRUE;
+    obj->ref = 1;
+
+    obj->depth_bounds = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_DEPTH_BOUNDS);
+    obj->uav_overlap = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_BARRIER_CONTROL);
+    obj->multi_draw_indirect = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_MULTI_DRAW_INDIRECT);
+    obj->multi_draw_indirect_count = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT);
+
+    TRACE("Supported extensions:\n DepthBounds: %d, UAVOverlap: %d, MultiDrawIndirect: %d, MultiDrawIndirectCount: %d\n",
+            obj->depth_bounds, obj->uav_overlap, obj->multi_draw_indirect, obj->multi_draw_indirect_count);
+
+    *ext = &obj->IAmdDxExt_iface;
+
+    ID3D11VkExtDevice_Release(ext_device);
+
+    return S_OK;
+}
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 3fae4230e6a..e0222e091f9 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2988,6 +2988,7 @@ HKCU,Software\Wine\DllOverrides,"ucrtbase",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"vcomp140",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"vcruntime140",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"atiadlxx",,"disabled"
+HKCU,Software\Wine\DllOverrides,"atidxx64",,"disabled"
 HKCU,Software\Wine\DllOverrides,"nvcuda",0x2,"disabled"
 HKCU,Software\Wine\DllOverrides,"vcruntime140_1",0x2,"native,builtin"
 HKCU,Software\Wine\AppDefaults\ShadowOfWar.exe\DllOverrides,"amd_ags_x64",,"disabled"
-- 
2.50.0

